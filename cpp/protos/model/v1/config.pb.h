// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/model/v1/config.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fconfig_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fconfig_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/model/v1/ros.pb.h"
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmodel_2fv1_2fconfig_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[27]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmodel_2fv1_2fconfig_2eproto;
namespace v1 {
namespace model {
class AdapterConfiguration;
struct AdapterConfigurationDefaultTypeInternal;
extern AdapterConfigurationDefaultTypeInternal _AdapterConfiguration_default_instance_;
class AgentConfiguration;
struct AgentConfigurationDefaultTypeInternal;
extern AgentConfigurationDefaultTypeInternal _AgentConfiguration_default_instance_;
class AgentConfigurationDocument;
struct AgentConfigurationDocumentDefaultTypeInternal;
extern AgentConfigurationDocumentDefaultTypeInternal _AgentConfigurationDocument_default_instance_;
class AgentConfigurationDocument_TagsEntry_DoNotUse;
struct AgentConfigurationDocument_TagsEntry_DoNotUseDefaultTypeInternal;
extern AgentConfigurationDocument_TagsEntry_DoNotUseDefaultTypeInternal _AgentConfigurationDocument_TagsEntry_DoNotUse_default_instance_;
class AgentConfigurationStore;
struct AgentConfigurationStoreDefaultTypeInternal;
extern AgentConfigurationStoreDefaultTypeInternal _AgentConfigurationStore_default_instance_;
class AgentFeatureSet;
struct AgentFeatureSetDefaultTypeInternal;
extern AgentFeatureSetDefaultTypeInternal _AgentFeatureSet_default_instance_;
class ApplicationConfiguration;
struct ApplicationConfigurationDefaultTypeInternal;
extern ApplicationConfigurationDefaultTypeInternal _ApplicationConfiguration_default_instance_;
class ApplicationConfiguration_ConfigurationMapEntry_DoNotUse;
struct ApplicationConfiguration_ConfigurationMapEntry_DoNotUseDefaultTypeInternal;
extern ApplicationConfiguration_ConfigurationMapEntry_DoNotUseDefaultTypeInternal _ApplicationConfiguration_ConfigurationMapEntry_DoNotUse_default_instance_;
class BlobData;
struct BlobDataDefaultTypeInternal;
extern BlobDataDefaultTypeInternal _BlobData_default_instance_;
class Custom;
struct CustomDefaultTypeInternal;
extern CustomDefaultTypeInternal _Custom_default_instance_;
class Diagnostics;
struct DiagnosticsDefaultTypeInternal;
extern DiagnosticsDefaultTypeInternal _Diagnostics_default_instance_;
class DirectoryWatch;
struct DirectoryWatchDefaultTypeInternal;
extern DirectoryWatchDefaultTypeInternal _DirectoryWatch_default_instance_;
class DiskConfiguration;
struct DiskConfigurationDefaultTypeInternal;
extern DiskConfigurationDefaultTypeInternal _DiskConfiguration_default_instance_;
class FileTail;
struct FileTailDefaultTypeInternal;
extern FileTailDefaultTypeInternal _FileTail_default_instance_;
class Hardware;
struct HardwareDefaultTypeInternal;
extern HardwareDefaultTypeInternal _Hardware_default_instance_;
class PortForwardingConfiguration;
struct PortForwardingConfigurationDefaultTypeInternal;
extern PortForwardingConfigurationDefaultTypeInternal _PortForwardingConfiguration_default_instance_;
class ROSConfiguration;
struct ROSConfigurationDefaultTypeInternal;
extern ROSConfigurationDefaultTypeInternal _ROSConfiguration_default_instance_;
class ResourcesConfiguration;
struct ResourcesConfigurationDefaultTypeInternal;
extern ResourcesConfigurationDefaultTypeInternal _ResourcesConfiguration_default_instance_;
class RtcInfo;
struct RtcInfoDefaultTypeInternal;
extern RtcInfoDefaultTypeInternal _RtcInfo_default_instance_;
class StreamConfiguration;
struct StreamConfigurationDefaultTypeInternal;
extern StreamConfigurationDefaultTypeInternal _StreamConfiguration_default_instance_;
class StreamConfiguration_TagsEntry_DoNotUse;
struct StreamConfiguration_TagsEntry_DoNotUseDefaultTypeInternal;
extern StreamConfiguration_TagsEntry_DoNotUseDefaultTypeInternal _StreamConfiguration_TagsEntry_DoNotUse_default_instance_;
class StreamTransformConfiguration;
struct StreamTransformConfigurationDefaultTypeInternal;
extern StreamTransformConfigurationDefaultTypeInternal _StreamTransformConfiguration_default_instance_;
class TelemetryConfiguration;
struct TelemetryConfigurationDefaultTypeInternal;
extern TelemetryConfigurationDefaultTypeInternal _TelemetryConfiguration_default_instance_;
class TeleopConfiguration;
struct TeleopConfigurationDefaultTypeInternal;
extern TeleopConfigurationDefaultTypeInternal _TeleopConfiguration_default_instance_;
class TeleopCustomStreamConfiguration;
struct TeleopCustomStreamConfigurationDefaultTypeInternal;
extern TeleopCustomStreamConfigurationDefaultTypeInternal _TeleopCustomStreamConfiguration_default_instance_;
class TeleopHardwareStreamConfiguration;
struct TeleopHardwareStreamConfigurationDefaultTypeInternal;
extern TeleopHardwareStreamConfigurationDefaultTypeInternal _TeleopHardwareStreamConfiguration_default_instance_;
class TeleopRosStreamConfiguration;
struct TeleopRosStreamConfigurationDefaultTypeInternal;
extern TeleopRosStreamConfigurationDefaultTypeInternal _TeleopRosStreamConfiguration_default_instance_;
}  // namespace model
}  // namespace v1
PROTOBUF_NAMESPACE_OPEN
template<> ::v1::model::AdapterConfiguration* Arena::CreateMaybeMessage<::v1::model::AdapterConfiguration>(Arena*);
template<> ::v1::model::AgentConfiguration* Arena::CreateMaybeMessage<::v1::model::AgentConfiguration>(Arena*);
template<> ::v1::model::AgentConfigurationDocument* Arena::CreateMaybeMessage<::v1::model::AgentConfigurationDocument>(Arena*);
template<> ::v1::model::AgentConfigurationDocument_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::AgentConfigurationDocument_TagsEntry_DoNotUse>(Arena*);
template<> ::v1::model::AgentConfigurationStore* Arena::CreateMaybeMessage<::v1::model::AgentConfigurationStore>(Arena*);
template<> ::v1::model::AgentFeatureSet* Arena::CreateMaybeMessage<::v1::model::AgentFeatureSet>(Arena*);
template<> ::v1::model::ApplicationConfiguration* Arena::CreateMaybeMessage<::v1::model::ApplicationConfiguration>(Arena*);
template<> ::v1::model::ApplicationConfiguration_ConfigurationMapEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::ApplicationConfiguration_ConfigurationMapEntry_DoNotUse>(Arena*);
template<> ::v1::model::BlobData* Arena::CreateMaybeMessage<::v1::model::BlobData>(Arena*);
template<> ::v1::model::Custom* Arena::CreateMaybeMessage<::v1::model::Custom>(Arena*);
template<> ::v1::model::Diagnostics* Arena::CreateMaybeMessage<::v1::model::Diagnostics>(Arena*);
template<> ::v1::model::DirectoryWatch* Arena::CreateMaybeMessage<::v1::model::DirectoryWatch>(Arena*);
template<> ::v1::model::DiskConfiguration* Arena::CreateMaybeMessage<::v1::model::DiskConfiguration>(Arena*);
template<> ::v1::model::FileTail* Arena::CreateMaybeMessage<::v1::model::FileTail>(Arena*);
template<> ::v1::model::Hardware* Arena::CreateMaybeMessage<::v1::model::Hardware>(Arena*);
template<> ::v1::model::PortForwardingConfiguration* Arena::CreateMaybeMessage<::v1::model::PortForwardingConfiguration>(Arena*);
template<> ::v1::model::ROSConfiguration* Arena::CreateMaybeMessage<::v1::model::ROSConfiguration>(Arena*);
template<> ::v1::model::ResourcesConfiguration* Arena::CreateMaybeMessage<::v1::model::ResourcesConfiguration>(Arena*);
template<> ::v1::model::RtcInfo* Arena::CreateMaybeMessage<::v1::model::RtcInfo>(Arena*);
template<> ::v1::model::StreamConfiguration* Arena::CreateMaybeMessage<::v1::model::StreamConfiguration>(Arena*);
template<> ::v1::model::StreamConfiguration_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::StreamConfiguration_TagsEntry_DoNotUse>(Arena*);
template<> ::v1::model::StreamTransformConfiguration* Arena::CreateMaybeMessage<::v1::model::StreamTransformConfiguration>(Arena*);
template<> ::v1::model::TelemetryConfiguration* Arena::CreateMaybeMessage<::v1::model::TelemetryConfiguration>(Arena*);
template<> ::v1::model::TeleopConfiguration* Arena::CreateMaybeMessage<::v1::model::TeleopConfiguration>(Arena*);
template<> ::v1::model::TeleopCustomStreamConfiguration* Arena::CreateMaybeMessage<::v1::model::TeleopCustomStreamConfiguration>(Arena*);
template<> ::v1::model::TeleopHardwareStreamConfiguration* Arena::CreateMaybeMessage<::v1::model::TeleopHardwareStreamConfiguration>(Arena*);
template<> ::v1::model::TeleopRosStreamConfiguration* Arena::CreateMaybeMessage<::v1::model::TeleopRosStreamConfiguration>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v1 {
namespace model {

enum TeleopMode : int {
  COMMAND = 0,
  OBSERVE = 1,
  TeleopMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TeleopMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TeleopMode_IsValid(int value);
constexpr TeleopMode TeleopMode_MIN = COMMAND;
constexpr TeleopMode TeleopMode_MAX = OBSERVE;
constexpr int TeleopMode_ARRAYSIZE = TeleopMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TeleopMode_descriptor();
template<typename T>
inline const std::string& TeleopMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TeleopMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TeleopMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TeleopMode_descriptor(), enum_t_value);
}
inline bool TeleopMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TeleopMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TeleopMode>(
    TeleopMode_descriptor(), name, value);
}
enum FileFormat : int {
  PLAIN_TEXT = 0,
  JSON = 1,
  FileFormat_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileFormat_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileFormat_IsValid(int value);
constexpr FileFormat FileFormat_MIN = PLAIN_TEXT;
constexpr FileFormat FileFormat_MAX = JSON;
constexpr int FileFormat_ARRAYSIZE = FileFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileFormat_descriptor();
template<typename T>
inline const std::string& FileFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileFormat_descriptor(), enum_t_value);
}
inline bool FileFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileFormat>(
    FileFormat_descriptor(), name, value);
}
enum FileType : int {
  FILE = 0,
  IMAGE = 1,
  POINT_CLOUD = 4,
  VIDEO = 5,
  FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool FileType_IsValid(int value);
constexpr FileType FileType_MIN = FILE;
constexpr FileType FileType_MAX = VIDEO;
constexpr int FileType_ARRAYSIZE = FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FileType_descriptor();
template<typename T>
inline const std::string& FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FileType_descriptor(), enum_t_value);
}
inline bool FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FileType>(
    FileType_descriptor(), name, value);
}
// ===================================================================

class AgentConfigurationStore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AgentConfigurationStore) */ {
 public:
  inline AgentConfigurationStore() : AgentConfigurationStore(nullptr) {}
  ~AgentConfigurationStore() override;
  explicit constexpr AgentConfigurationStore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentConfigurationStore(const AgentConfigurationStore& from);
  AgentConfigurationStore(AgentConfigurationStore&& from) noexcept
    : AgentConfigurationStore() {
    *this = ::std::move(from);
  }

  inline AgentConfigurationStore& operator=(const AgentConfigurationStore& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentConfigurationStore& operator=(AgentConfigurationStore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentConfigurationStore& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentConfigurationStore* internal_default_instance() {
    return reinterpret_cast<const AgentConfigurationStore*>(
               &_AgentConfigurationStore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AgentConfigurationStore& a, AgentConfigurationStore& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentConfigurationStore* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentConfigurationStore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentConfigurationStore* New() const final {
    return new AgentConfigurationStore();
  }

  AgentConfigurationStore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentConfigurationStore>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AgentConfigurationStore& from);
  void MergeFrom(const AgentConfigurationStore& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentConfigurationStore* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AgentConfigurationStore";
  }
  protected:
  explicit AgentConfigurationStore(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgentVersionFieldNumber = 1,
    kConfigurationFieldNumber = 2,
    kFeatureSetFieldNumber = 3,
  };
  // string agent_version = 1 [json_name = "agentVersion"];
  void clear_agent_version();
  const std::string& agent_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agent_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agent_version();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_agent_version();
  void set_allocated_agent_version(std::string* agent_version);
  private:
  const std::string& _internal_agent_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agent_version(const std::string& value);
  std::string* _internal_mutable_agent_version();
  public:

  // .v1.model.AgentConfiguration configuration = 2 [json_name = "configuration"];
  bool has_configuration() const;
  private:
  bool _internal_has_configuration() const;
  public:
  void clear_configuration();
  const ::v1::model::AgentConfiguration& configuration() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::AgentConfiguration* release_configuration();
  ::v1::model::AgentConfiguration* mutable_configuration();
  void set_allocated_configuration(::v1::model::AgentConfiguration* configuration);
  private:
  const ::v1::model::AgentConfiguration& _internal_configuration() const;
  ::v1::model::AgentConfiguration* _internal_mutable_configuration();
  public:
  void unsafe_arena_set_allocated_configuration(
      ::v1::model::AgentConfiguration* configuration);
  ::v1::model::AgentConfiguration* unsafe_arena_release_configuration();

  // .v1.model.AgentFeatureSet feature_set = 3 [json_name = "featureSet"];
  bool has_feature_set() const;
  private:
  bool _internal_has_feature_set() const;
  public:
  void clear_feature_set();
  const ::v1::model::AgentFeatureSet& feature_set() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::AgentFeatureSet* release_feature_set();
  ::v1::model::AgentFeatureSet* mutable_feature_set();
  void set_allocated_feature_set(::v1::model::AgentFeatureSet* feature_set);
  private:
  const ::v1::model::AgentFeatureSet& _internal_feature_set() const;
  ::v1::model::AgentFeatureSet* _internal_mutable_feature_set();
  public:
  void unsafe_arena_set_allocated_feature_set(
      ::v1::model::AgentFeatureSet* feature_set);
  ::v1::model::AgentFeatureSet* unsafe_arena_release_feature_set();

  // @@protoc_insertion_point(class_scope:v1.model.AgentConfigurationStore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agent_version_;
  ::v1::model::AgentConfiguration* configuration_;
  ::v1::model::AgentFeatureSet* feature_set_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class AgentFeatureSet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AgentFeatureSet) */ {
 public:
  inline AgentFeatureSet() : AgentFeatureSet(nullptr) {}
  ~AgentFeatureSet() override;
  explicit constexpr AgentFeatureSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentFeatureSet(const AgentFeatureSet& from);
  AgentFeatureSet(AgentFeatureSet&& from) noexcept
    : AgentFeatureSet() {
    *this = ::std::move(from);
  }

  inline AgentFeatureSet& operator=(const AgentFeatureSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentFeatureSet& operator=(AgentFeatureSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentFeatureSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentFeatureSet* internal_default_instance() {
    return reinterpret_cast<const AgentFeatureSet*>(
               &_AgentFeatureSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AgentFeatureSet& a, AgentFeatureSet& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentFeatureSet* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentFeatureSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentFeatureSet* New() const final {
    return new AgentFeatureSet();
  }

  AgentFeatureSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentFeatureSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AgentFeatureSet& from);
  void MergeFrom(const AgentFeatureSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentFeatureSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AgentFeatureSet";
  }
  protected:
  explicit AgentFeatureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTelemetryFieldNumber = 1,
    kInternalTelemetryFieldNumber = 2,
    kTeleopFieldNumber = 3,
    kCustomEventsFieldNumber = 4,
    kTriggeredEventsFieldNumber = 5,
    kSshFieldNumber = 6,
    kPortForwardingFieldNumber = 7,
    kCommandsFieldNumber = 8,
    kInterventionsFieldNumber = 9,
    kOnDemandFieldNumber = 10,
    kAppConfigFieldNumber = 11,
    kBlobStorageFieldNumber = 12,
  };
  // bool telemetry = 1 [json_name = "telemetry"];
  void clear_telemetry();
  bool telemetry() const;
  void set_telemetry(bool value);
  private:
  bool _internal_telemetry() const;
  void _internal_set_telemetry(bool value);
  public:

  // bool internal_telemetry = 2 [json_name = "internalTelemetry"];
  void clear_internal_telemetry();
  bool internal_telemetry() const;
  void set_internal_telemetry(bool value);
  private:
  bool _internal_internal_telemetry() const;
  void _internal_set_internal_telemetry(bool value);
  public:

  // bool teleop = 3 [json_name = "teleop"];
  void clear_teleop();
  bool teleop() const;
  void set_teleop(bool value);
  private:
  bool _internal_teleop() const;
  void _internal_set_teleop(bool value);
  public:

  // bool custom_events = 4 [json_name = "customEvents"];
  void clear_custom_events();
  bool custom_events() const;
  void set_custom_events(bool value);
  private:
  bool _internal_custom_events() const;
  void _internal_set_custom_events(bool value);
  public:

  // bool triggered_events = 5 [json_name = "triggeredEvents"];
  void clear_triggered_events();
  bool triggered_events() const;
  void set_triggered_events(bool value);
  private:
  bool _internal_triggered_events() const;
  void _internal_set_triggered_events(bool value);
  public:

  // bool ssh = 6 [json_name = "ssh"];
  void clear_ssh();
  bool ssh() const;
  void set_ssh(bool value);
  private:
  bool _internal_ssh() const;
  void _internal_set_ssh(bool value);
  public:

  // bool port_forwarding = 7 [json_name = "portForwarding"];
  void clear_port_forwarding();
  bool port_forwarding() const;
  void set_port_forwarding(bool value);
  private:
  bool _internal_port_forwarding() const;
  void _internal_set_port_forwarding(bool value);
  public:

  // bool commands = 8 [json_name = "commands"];
  void clear_commands();
  bool commands() const;
  void set_commands(bool value);
  private:
  bool _internal_commands() const;
  void _internal_set_commands(bool value);
  public:

  // bool interventions = 9 [json_name = "interventions"];
  void clear_interventions();
  bool interventions() const;
  void set_interventions(bool value);
  private:
  bool _internal_interventions() const;
  void _internal_set_interventions(bool value);
  public:

  // bool on_demand = 10 [json_name = "onDemand"];
  void clear_on_demand();
  bool on_demand() const;
  void set_on_demand(bool value);
  private:
  bool _internal_on_demand() const;
  void _internal_set_on_demand(bool value);
  public:

  // bool app_config = 11 [json_name = "appConfig"];
  void clear_app_config();
  bool app_config() const;
  void set_app_config(bool value);
  private:
  bool _internal_app_config() const;
  void _internal_set_app_config(bool value);
  public:

  // bool blob_storage = 12 [json_name = "blobStorage"];
  void clear_blob_storage();
  bool blob_storage() const;
  void set_blob_storage(bool value);
  private:
  bool _internal_blob_storage() const;
  void _internal_set_blob_storage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.AgentFeatureSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool telemetry_;
  bool internal_telemetry_;
  bool teleop_;
  bool custom_events_;
  bool triggered_events_;
  bool ssh_;
  bool port_forwarding_;
  bool commands_;
  bool interventions_;
  bool on_demand_;
  bool app_config_;
  bool blob_storage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class AgentConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AgentConfiguration) */ {
 public:
  inline AgentConfiguration() : AgentConfiguration(nullptr) {}
  ~AgentConfiguration() override;
  explicit constexpr AgentConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentConfiguration(const AgentConfiguration& from);
  AgentConfiguration(AgentConfiguration&& from) noexcept
    : AgentConfiguration() {
    *this = ::std::move(from);
  }

  inline AgentConfiguration& operator=(const AgentConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentConfiguration& operator=(AgentConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentConfiguration* internal_default_instance() {
    return reinterpret_cast<const AgentConfiguration*>(
               &_AgentConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AgentConfiguration& a, AgentConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentConfiguration* New() const final {
    return new AgentConfiguration();
  }

  AgentConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AgentConfiguration& from);
  void MergeFrom(const AgentConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AgentConfiguration";
  }
  protected:
  explicit AgentConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kDocumentFieldNumber = 3,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .v1.model.AgentConfigurationDocument document = 3 [json_name = "document"];
  bool has_document() const;
  private:
  bool _internal_has_document() const;
  public:
  void clear_document();
  const ::v1::model::AgentConfigurationDocument& document() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::AgentConfigurationDocument* release_document();
  ::v1::model::AgentConfigurationDocument* mutable_document();
  void set_allocated_document(::v1::model::AgentConfigurationDocument* document);
  private:
  const ::v1::model::AgentConfigurationDocument& _internal_document() const;
  ::v1::model::AgentConfigurationDocument* _internal_mutable_document();
  public:
  void unsafe_arena_set_allocated_document(
      ::v1::model::AgentConfigurationDocument* document);
  ::v1::model::AgentConfigurationDocument* unsafe_arena_release_document();

  // @@protoc_insertion_point(class_scope:v1.model.AgentConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::v1::model::AgentConfigurationDocument* document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class AgentConfigurationDocument_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentConfigurationDocument_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AgentConfigurationDocument_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AgentConfigurationDocument_TagsEntry_DoNotUse();
  explicit constexpr AgentConfigurationDocument_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AgentConfigurationDocument_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AgentConfigurationDocument_TagsEntry_DoNotUse& other);
  static const AgentConfigurationDocument_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AgentConfigurationDocument_TagsEntry_DoNotUse*>(&_AgentConfigurationDocument_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.AgentConfigurationDocument.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.AgentConfigurationDocument.TagsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AgentConfigurationDocument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AgentConfigurationDocument) */ {
 public:
  inline AgentConfigurationDocument() : AgentConfigurationDocument(nullptr) {}
  ~AgentConfigurationDocument() override;
  explicit constexpr AgentConfigurationDocument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentConfigurationDocument(const AgentConfigurationDocument& from);
  AgentConfigurationDocument(AgentConfigurationDocument&& from) noexcept
    : AgentConfigurationDocument() {
    *this = ::std::move(from);
  }

  inline AgentConfigurationDocument& operator=(const AgentConfigurationDocument& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentConfigurationDocument& operator=(AgentConfigurationDocument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentConfigurationDocument& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentConfigurationDocument* internal_default_instance() {
    return reinterpret_cast<const AgentConfigurationDocument*>(
               &_AgentConfigurationDocument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AgentConfigurationDocument& a, AgentConfigurationDocument& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentConfigurationDocument* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentConfigurationDocument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentConfigurationDocument* New() const final {
    return new AgentConfigurationDocument();
  }

  AgentConfigurationDocument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentConfigurationDocument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AgentConfigurationDocument& from);
  void MergeFrom(const AgentConfigurationDocument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentConfigurationDocument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AgentConfigurationDocument";
  }
  protected:
  explicit AgentConfigurationDocument(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kAdaptersFieldNumber = 11,
    kTelemetryFieldNumber = 3,
    kResourcesFieldNumber = 4,
    kApplicationFieldNumber = 5,
    kTeleopFieldNumber = 6,
    kPortForwardingFieldNumber = 7,
    kBlobDataFieldNumber = 8,
    kDiagnosticsFieldNumber = 9,
    kTerminalAccessFieldNumber = 10,
    kRtcInfoFieldNumber = 12,
    kVersionFieldNumber = 1,
  };
  // map<string, string> tags = 2 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // repeated .v1.model.AdapterConfiguration adapters = 11 [json_name = "adapters"];
  int adapters_size() const;
  private:
  int _internal_adapters_size() const;
  public:
  void clear_adapters();
  ::v1::model::AdapterConfiguration* mutable_adapters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AdapterConfiguration >*
      mutable_adapters();
  private:
  const ::v1::model::AdapterConfiguration& _internal_adapters(int index) const;
  ::v1::model::AdapterConfiguration* _internal_add_adapters();
  public:
  const ::v1::model::AdapterConfiguration& adapters(int index) const;
  ::v1::model::AdapterConfiguration* add_adapters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AdapterConfiguration >&
      adapters() const;

  // .v1.model.TelemetryConfiguration telemetry = 3 [json_name = "telemetry"];
  bool has_telemetry() const;
  private:
  bool _internal_has_telemetry() const;
  public:
  void clear_telemetry();
  const ::v1::model::TelemetryConfiguration& telemetry() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::TelemetryConfiguration* release_telemetry();
  ::v1::model::TelemetryConfiguration* mutable_telemetry();
  void set_allocated_telemetry(::v1::model::TelemetryConfiguration* telemetry);
  private:
  const ::v1::model::TelemetryConfiguration& _internal_telemetry() const;
  ::v1::model::TelemetryConfiguration* _internal_mutable_telemetry();
  public:
  void unsafe_arena_set_allocated_telemetry(
      ::v1::model::TelemetryConfiguration* telemetry);
  ::v1::model::TelemetryConfiguration* unsafe_arena_release_telemetry();

  // .v1.model.ResourcesConfiguration resources = 4 [json_name = "resources"];
  bool has_resources() const;
  private:
  bool _internal_has_resources() const;
  public:
  void clear_resources();
  const ::v1::model::ResourcesConfiguration& resources() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ResourcesConfiguration* release_resources();
  ::v1::model::ResourcesConfiguration* mutable_resources();
  void set_allocated_resources(::v1::model::ResourcesConfiguration* resources);
  private:
  const ::v1::model::ResourcesConfiguration& _internal_resources() const;
  ::v1::model::ResourcesConfiguration* _internal_mutable_resources();
  public:
  void unsafe_arena_set_allocated_resources(
      ::v1::model::ResourcesConfiguration* resources);
  ::v1::model::ResourcesConfiguration* unsafe_arena_release_resources();

  // .v1.model.ApplicationConfiguration application = 5 [json_name = "application"];
  bool has_application() const;
  private:
  bool _internal_has_application() const;
  public:
  void clear_application();
  const ::v1::model::ApplicationConfiguration& application() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ApplicationConfiguration* release_application();
  ::v1::model::ApplicationConfiguration* mutable_application();
  void set_allocated_application(::v1::model::ApplicationConfiguration* application);
  private:
  const ::v1::model::ApplicationConfiguration& _internal_application() const;
  ::v1::model::ApplicationConfiguration* _internal_mutable_application();
  public:
  void unsafe_arena_set_allocated_application(
      ::v1::model::ApplicationConfiguration* application);
  ::v1::model::ApplicationConfiguration* unsafe_arena_release_application();

  // .v1.model.TeleopConfiguration teleop = 6 [json_name = "teleop"];
  bool has_teleop() const;
  private:
  bool _internal_has_teleop() const;
  public:
  void clear_teleop();
  const ::v1::model::TeleopConfiguration& teleop() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::TeleopConfiguration* release_teleop();
  ::v1::model::TeleopConfiguration* mutable_teleop();
  void set_allocated_teleop(::v1::model::TeleopConfiguration* teleop);
  private:
  const ::v1::model::TeleopConfiguration& _internal_teleop() const;
  ::v1::model::TeleopConfiguration* _internal_mutable_teleop();
  public:
  void unsafe_arena_set_allocated_teleop(
      ::v1::model::TeleopConfiguration* teleop);
  ::v1::model::TeleopConfiguration* unsafe_arena_release_teleop();

  // .v1.model.PortForwardingConfiguration port_forwarding = 7 [json_name = "portForwarding"];
  bool has_port_forwarding() const;
  private:
  bool _internal_has_port_forwarding() const;
  public:
  void clear_port_forwarding();
  const ::v1::model::PortForwardingConfiguration& port_forwarding() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::PortForwardingConfiguration* release_port_forwarding();
  ::v1::model::PortForwardingConfiguration* mutable_port_forwarding();
  void set_allocated_port_forwarding(::v1::model::PortForwardingConfiguration* port_forwarding);
  private:
  const ::v1::model::PortForwardingConfiguration& _internal_port_forwarding() const;
  ::v1::model::PortForwardingConfiguration* _internal_mutable_port_forwarding();
  public:
  void unsafe_arena_set_allocated_port_forwarding(
      ::v1::model::PortForwardingConfiguration* port_forwarding);
  ::v1::model::PortForwardingConfiguration* unsafe_arena_release_port_forwarding();

  // .v1.model.BlobData blob_data = 8 [json_name = "blobData"];
  bool has_blob_data() const;
  private:
  bool _internal_has_blob_data() const;
  public:
  void clear_blob_data();
  const ::v1::model::BlobData& blob_data() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::BlobData* release_blob_data();
  ::v1::model::BlobData* mutable_blob_data();
  void set_allocated_blob_data(::v1::model::BlobData* blob_data);
  private:
  const ::v1::model::BlobData& _internal_blob_data() const;
  ::v1::model::BlobData* _internal_mutable_blob_data();
  public:
  void unsafe_arena_set_allocated_blob_data(
      ::v1::model::BlobData* blob_data);
  ::v1::model::BlobData* unsafe_arena_release_blob_data();

  // .v1.model.Diagnostics diagnostics = 9 [json_name = "diagnostics"];
  bool has_diagnostics() const;
  private:
  bool _internal_has_diagnostics() const;
  public:
  void clear_diagnostics();
  const ::v1::model::Diagnostics& diagnostics() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Diagnostics* release_diagnostics();
  ::v1::model::Diagnostics* mutable_diagnostics();
  void set_allocated_diagnostics(::v1::model::Diagnostics* diagnostics);
  private:
  const ::v1::model::Diagnostics& _internal_diagnostics() const;
  ::v1::model::Diagnostics* _internal_mutable_diagnostics();
  public:
  void unsafe_arena_set_allocated_diagnostics(
      ::v1::model::Diagnostics* diagnostics);
  ::v1::model::Diagnostics* unsafe_arena_release_diagnostics();

  // .google.protobuf.BoolValue terminal_access = 10 [json_name = "terminalAccess"];
  bool has_terminal_access() const;
  private:
  bool _internal_has_terminal_access() const;
  public:
  void clear_terminal_access();
  const PROTOBUF_NAMESPACE_ID::BoolValue& terminal_access() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_terminal_access();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_terminal_access();
  void set_allocated_terminal_access(PROTOBUF_NAMESPACE_ID::BoolValue* terminal_access);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_terminal_access() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_terminal_access();
  public:
  void unsafe_arena_set_allocated_terminal_access(
      PROTOBUF_NAMESPACE_ID::BoolValue* terminal_access);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_terminal_access();

  // .v1.model.RtcInfo rtc_info = 12 [json_name = "rtcInfo"];
  bool has_rtc_info() const;
  private:
  bool _internal_has_rtc_info() const;
  public:
  void clear_rtc_info();
  const ::v1::model::RtcInfo& rtc_info() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::RtcInfo* release_rtc_info();
  ::v1::model::RtcInfo* mutable_rtc_info();
  void set_allocated_rtc_info(::v1::model::RtcInfo* rtc_info);
  private:
  const ::v1::model::RtcInfo& _internal_rtc_info() const;
  ::v1::model::RtcInfo* _internal_mutable_rtc_info();
  public:
  void unsafe_arena_set_allocated_rtc_info(
      ::v1::model::RtcInfo* rtc_info);
  ::v1::model::RtcInfo* unsafe_arena_release_rtc_info();

  // int64 version = 1 [json_name = "version"];
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int64 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.AgentConfigurationDocument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AgentConfigurationDocument_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AdapterConfiguration > adapters_;
  ::v1::model::TelemetryConfiguration* telemetry_;
  ::v1::model::ResourcesConfiguration* resources_;
  ::v1::model::ApplicationConfiguration* application_;
  ::v1::model::TeleopConfiguration* teleop_;
  ::v1::model::PortForwardingConfiguration* port_forwarding_;
  ::v1::model::BlobData* blob_data_;
  ::v1::model::Diagnostics* diagnostics_;
  PROTOBUF_NAMESPACE_ID::BoolValue* terminal_access_;
  ::v1::model::RtcInfo* rtc_info_;
  ::PROTOBUF_NAMESPACE_ID::int64 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class AdapterConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AdapterConfiguration) */ {
 public:
  inline AdapterConfiguration() : AdapterConfiguration(nullptr) {}
  ~AdapterConfiguration() override;
  explicit constexpr AdapterConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdapterConfiguration(const AdapterConfiguration& from);
  AdapterConfiguration(AdapterConfiguration&& from) noexcept
    : AdapterConfiguration() {
    *this = ::std::move(from);
  }

  inline AdapterConfiguration& operator=(const AdapterConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdapterConfiguration& operator=(AdapterConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdapterConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdapterConfiguration* internal_default_instance() {
    return reinterpret_cast<const AdapterConfiguration*>(
               &_AdapterConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AdapterConfiguration& a, AdapterConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(AdapterConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdapterConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdapterConfiguration* New() const final {
    return new AdapterConfiguration();
  }

  AdapterConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdapterConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdapterConfiguration& from);
  void MergeFrom(const AdapterConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdapterConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AdapterConfiguration";
  }
  protected:
  explicit AdapterConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kFileIdFieldNumber = 3,
    kExecCommandFieldNumber = 4,
    kConfigurationFieldNumber = 5,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string name = 2 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string file_id = 3 [json_name = "fileId"];
  void clear_file_id();
  const std::string& file_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_file_id();
  void set_allocated_file_id(std::string* file_id);
  private:
  const std::string& _internal_file_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_id(const std::string& value);
  std::string* _internal_mutable_file_id();
  public:

  // string exec_command = 4 [json_name = "execCommand"];
  void clear_exec_command();
  const std::string& exec_command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_exec_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_exec_command();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_exec_command();
  void set_allocated_exec_command(std::string* exec_command);
  private:
  const std::string& _internal_exec_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_exec_command(const std::string& value);
  std::string* _internal_mutable_exec_command();
  public:

  // string configuration = 5 [json_name = "configuration"];
  void clear_configuration();
  const std::string& configuration() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configuration(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configuration();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_configuration();
  void set_allocated_configuration(std::string* configuration);
  private:
  const std::string& _internal_configuration() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configuration(const std::string& value);
  std::string* _internal_mutable_configuration();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.AdapterConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exec_command_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configuration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TeleopConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TeleopConfiguration) */ {
 public:
  inline TeleopConfiguration() : TeleopConfiguration(nullptr) {}
  ~TeleopConfiguration() override;
  explicit constexpr TeleopConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeleopConfiguration(const TeleopConfiguration& from);
  TeleopConfiguration(TeleopConfiguration&& from) noexcept
    : TeleopConfiguration() {
    *this = ::std::move(from);
  }

  inline TeleopConfiguration& operator=(const TeleopConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeleopConfiguration& operator=(TeleopConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeleopConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeleopConfiguration* internal_default_instance() {
    return reinterpret_cast<const TeleopConfiguration*>(
               &_TeleopConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TeleopConfiguration& a, TeleopConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TeleopConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeleopConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeleopConfiguration* New() const final {
    return new TeleopConfiguration();
  }

  TeleopConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeleopConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeleopConfiguration& from);
  void MergeFrom(const TeleopConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeleopConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TeleopConfiguration";
  }
  protected:
  explicit TeleopConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRosStreamsFieldNumber = 1,
    kCustomStreamsFieldNumber = 2,
    kHardwareStreamsFieldNumber = 3,
  };
  // repeated .v1.model.TeleopRosStreamConfiguration ros_streams = 1 [json_name = "rosStreams"];
  int ros_streams_size() const;
  private:
  int _internal_ros_streams_size() const;
  public:
  void clear_ros_streams();
  ::v1::model::TeleopRosStreamConfiguration* mutable_ros_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopRosStreamConfiguration >*
      mutable_ros_streams();
  private:
  const ::v1::model::TeleopRosStreamConfiguration& _internal_ros_streams(int index) const;
  ::v1::model::TeleopRosStreamConfiguration* _internal_add_ros_streams();
  public:
  const ::v1::model::TeleopRosStreamConfiguration& ros_streams(int index) const;
  ::v1::model::TeleopRosStreamConfiguration* add_ros_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopRosStreamConfiguration >&
      ros_streams() const;

  // repeated .v1.model.TeleopCustomStreamConfiguration custom_streams = 2 [json_name = "customStreams"];
  int custom_streams_size() const;
  private:
  int _internal_custom_streams_size() const;
  public:
  void clear_custom_streams();
  ::v1::model::TeleopCustomStreamConfiguration* mutable_custom_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopCustomStreamConfiguration >*
      mutable_custom_streams();
  private:
  const ::v1::model::TeleopCustomStreamConfiguration& _internal_custom_streams(int index) const;
  ::v1::model::TeleopCustomStreamConfiguration* _internal_add_custom_streams();
  public:
  const ::v1::model::TeleopCustomStreamConfiguration& custom_streams(int index) const;
  ::v1::model::TeleopCustomStreamConfiguration* add_custom_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopCustomStreamConfiguration >&
      custom_streams() const;

  // repeated .v1.model.TeleopHardwareStreamConfiguration hardware_streams = 3 [json_name = "hardwareStreams"];
  int hardware_streams_size() const;
  private:
  int _internal_hardware_streams_size() const;
  public:
  void clear_hardware_streams();
  ::v1::model::TeleopHardwareStreamConfiguration* mutable_hardware_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopHardwareStreamConfiguration >*
      mutable_hardware_streams();
  private:
  const ::v1::model::TeleopHardwareStreamConfiguration& _internal_hardware_streams(int index) const;
  ::v1::model::TeleopHardwareStreamConfiguration* _internal_add_hardware_streams();
  public:
  const ::v1::model::TeleopHardwareStreamConfiguration& hardware_streams(int index) const;
  ::v1::model::TeleopHardwareStreamConfiguration* add_hardware_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopHardwareStreamConfiguration >&
      hardware_streams() const;

  // @@protoc_insertion_point(class_scope:v1.model.TeleopConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopRosStreamConfiguration > ros_streams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopCustomStreamConfiguration > custom_streams_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopHardwareStreamConfiguration > hardware_streams_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class PortForwardingConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.PortForwardingConfiguration) */ {
 public:
  inline PortForwardingConfiguration() : PortForwardingConfiguration(nullptr) {}
  ~PortForwardingConfiguration() override;
  explicit constexpr PortForwardingConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortForwardingConfiguration(const PortForwardingConfiguration& from);
  PortForwardingConfiguration(PortForwardingConfiguration&& from) noexcept
    : PortForwardingConfiguration() {
    *this = ::std::move(from);
  }

  inline PortForwardingConfiguration& operator=(const PortForwardingConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortForwardingConfiguration& operator=(PortForwardingConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortForwardingConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortForwardingConfiguration* internal_default_instance() {
    return reinterpret_cast<const PortForwardingConfiguration*>(
               &_PortForwardingConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PortForwardingConfiguration& a, PortForwardingConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(PortForwardingConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortForwardingConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PortForwardingConfiguration* New() const final {
    return new PortForwardingConfiguration();
  }

  PortForwardingConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PortForwardingConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PortForwardingConfiguration& from);
  void MergeFrom(const PortForwardingConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortForwardingConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.PortForwardingConfiguration";
  }
  protected:
  explicit PortForwardingConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // .google.protobuf.BoolValue enabled = 1 [json_name = "enabled"];
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  const PROTOBUF_NAMESPACE_ID::BoolValue& enabled() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_enabled();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_enabled();
  void set_allocated_enabled(PROTOBUF_NAMESPACE_ID::BoolValue* enabled);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_enabled() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_enabled();
  public:
  void unsafe_arena_set_allocated_enabled(
      PROTOBUF_NAMESPACE_ID::BoolValue* enabled);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_enabled();

  // @@protoc_insertion_point(class_scope:v1.model.PortForwardingConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::BoolValue* enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TeleopRosStreamConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TeleopRosStreamConfiguration) */ {
 public:
  inline TeleopRosStreamConfiguration() : TeleopRosStreamConfiguration(nullptr) {}
  ~TeleopRosStreamConfiguration() override;
  explicit constexpr TeleopRosStreamConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeleopRosStreamConfiguration(const TeleopRosStreamConfiguration& from);
  TeleopRosStreamConfiguration(TeleopRosStreamConfiguration&& from) noexcept
    : TeleopRosStreamConfiguration() {
    *this = ::std::move(from);
  }

  inline TeleopRosStreamConfiguration& operator=(const TeleopRosStreamConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeleopRosStreamConfiguration& operator=(TeleopRosStreamConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeleopRosStreamConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeleopRosStreamConfiguration* internal_default_instance() {
    return reinterpret_cast<const TeleopRosStreamConfiguration*>(
               &_TeleopRosStreamConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TeleopRosStreamConfiguration& a, TeleopRosStreamConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TeleopRosStreamConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeleopRosStreamConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeleopRosStreamConfiguration* New() const final {
    return new TeleopRosStreamConfiguration();
  }

  TeleopRosStreamConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeleopRosStreamConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeleopRosStreamConfiguration& from);
  void MergeFrom(const TeleopRosStreamConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeleopRosStreamConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TeleopRosStreamConfiguration";
  }
  protected:
  explicit TeleopRosStreamConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopicNameFieldNumber = 1,
    kAudioCodecFieldNumber = 5,
    kQualityFieldNumber = 6,
    kBaseReferenceFrameFieldNumber = 7,
    kLocalFrameFieldNumber = 8,
    kTopicTypeFieldNumber = 2,
    kModeFieldNumber = 3,
    kEncodeVideoFieldNumber = 4,
    kOverlayClockFieldNumber = 9,
  };
  // string topic_name = 1 [json_name = "topicName"];
  void clear_topic_name();
  const std::string& topic_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_topic_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_topic_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_topic_name();
  void set_allocated_topic_name(std::string* topic_name);
  private:
  const std::string& _internal_topic_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_topic_name(const std::string& value);
  std::string* _internal_mutable_topic_name();
  public:

  // string audio_codec = 5 [json_name = "audioCodec"];
  void clear_audio_codec();
  const std::string& audio_codec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_codec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_codec();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_audio_codec();
  void set_allocated_audio_codec(std::string* audio_codec);
  private:
  const std::string& _internal_audio_codec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_codec(const std::string& value);
  std::string* _internal_mutable_audio_codec();
  public:

  // string quality = 6 [json_name = "quality"];
  void clear_quality();
  const std::string& quality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quality();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_quality();
  void set_allocated_quality(std::string* quality);
  private:
  const std::string& _internal_quality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quality(const std::string& value);
  std::string* _internal_mutable_quality();
  public:

  // string base_reference_frame = 7 [json_name = "baseReferenceFrame"];
  void clear_base_reference_frame();
  const std::string& base_reference_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_base_reference_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_base_reference_frame();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_base_reference_frame();
  void set_allocated_base_reference_frame(std::string* base_reference_frame);
  private:
  const std::string& _internal_base_reference_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_base_reference_frame(const std::string& value);
  std::string* _internal_mutable_base_reference_frame();
  public:

  // string local_frame = 8 [json_name = "localFrame"];
  void clear_local_frame();
  const std::string& local_frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_frame();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_local_frame();
  void set_allocated_local_frame(std::string* local_frame);
  private:
  const std::string& _internal_local_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_frame(const std::string& value);
  std::string* _internal_mutable_local_frame();
  public:

  // .v1.model.ROSTopicType topic_type = 2 [json_name = "topicType"];
  void clear_topic_type();
  ::v1::model::ROSTopicType topic_type() const;
  void set_topic_type(::v1::model::ROSTopicType value);
  private:
  ::v1::model::ROSTopicType _internal_topic_type() const;
  void _internal_set_topic_type(::v1::model::ROSTopicType value);
  public:

  // .v1.model.TeleopMode mode = 3 [json_name = "mode"];
  void clear_mode();
  ::v1::model::TeleopMode mode() const;
  void set_mode(::v1::model::TeleopMode value);
  private:
  ::v1::model::TeleopMode _internal_mode() const;
  void _internal_set_mode(::v1::model::TeleopMode value);
  public:

  // bool encode_video = 4 [json_name = "encodeVideo"];
  void clear_encode_video();
  bool encode_video() const;
  void set_encode_video(bool value);
  private:
  bool _internal_encode_video() const;
  void _internal_set_encode_video(bool value);
  public:

  // bool overlay_clock = 9 [json_name = "overlayClock"];
  void clear_overlay_clock();
  bool overlay_clock() const;
  void set_overlay_clock(bool value);
  private:
  bool _internal_overlay_clock() const;
  void _internal_set_overlay_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.TeleopRosStreamConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr topic_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_codec_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quality_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr base_reference_frame_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_frame_;
  int topic_type_;
  int mode_;
  bool encode_video_;
  bool overlay_clock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TeleopHardwareStreamConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TeleopHardwareStreamConfiguration) */ {
 public:
  inline TeleopHardwareStreamConfiguration() : TeleopHardwareStreamConfiguration(nullptr) {}
  ~TeleopHardwareStreamConfiguration() override;
  explicit constexpr TeleopHardwareStreamConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeleopHardwareStreamConfiguration(const TeleopHardwareStreamConfiguration& from);
  TeleopHardwareStreamConfiguration(TeleopHardwareStreamConfiguration&& from) noexcept
    : TeleopHardwareStreamConfiguration() {
    *this = ::std::move(from);
  }

  inline TeleopHardwareStreamConfiguration& operator=(const TeleopHardwareStreamConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeleopHardwareStreamConfiguration& operator=(TeleopHardwareStreamConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeleopHardwareStreamConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeleopHardwareStreamConfiguration* internal_default_instance() {
    return reinterpret_cast<const TeleopHardwareStreamConfiguration*>(
               &_TeleopHardwareStreamConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TeleopHardwareStreamConfiguration& a, TeleopHardwareStreamConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TeleopHardwareStreamConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeleopHardwareStreamConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeleopHardwareStreamConfiguration* New() const final {
    return new TeleopHardwareStreamConfiguration();
  }

  TeleopHardwareStreamConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeleopHardwareStreamConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeleopHardwareStreamConfiguration& from);
  void MergeFrom(const TeleopHardwareStreamConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeleopHardwareStreamConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TeleopHardwareStreamConfiguration";
  }
  protected:
  explicit TeleopHardwareStreamConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRtcStreamTypeFieldNumber = 2,
    kHwDescriptorFieldNumber = 4,
    kQualityFieldNumber = 5,
    kHardwareTypeFieldNumber = 6,
    kIpCamUsernameFieldNumber = 9,
    kIpCamPasswordFieldNumber = 10,
    kModeFieldNumber = 3,
    kRtspEncodingNeededFieldNumber = 7,
    kIsOnvifFieldNumber = 8,
    kOverlayClockFieldNumber = 11,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string rtc_stream_type = 2 [json_name = "rtcStreamType"];
  void clear_rtc_stream_type();
  const std::string& rtc_stream_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rtc_stream_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rtc_stream_type();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_rtc_stream_type();
  void set_allocated_rtc_stream_type(std::string* rtc_stream_type);
  private:
  const std::string& _internal_rtc_stream_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtc_stream_type(const std::string& value);
  std::string* _internal_mutable_rtc_stream_type();
  public:

  // string hw_descriptor = 4 [json_name = "hwDescriptor"];
  void clear_hw_descriptor();
  const std::string& hw_descriptor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hw_descriptor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hw_descriptor();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_hw_descriptor();
  void set_allocated_hw_descriptor(std::string* hw_descriptor);
  private:
  const std::string& _internal_hw_descriptor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hw_descriptor(const std::string& value);
  std::string* _internal_mutable_hw_descriptor();
  public:

  // string quality = 5 [json_name = "quality"];
  void clear_quality();
  const std::string& quality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quality();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_quality();
  void set_allocated_quality(std::string* quality);
  private:
  const std::string& _internal_quality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quality(const std::string& value);
  std::string* _internal_mutable_quality();
  public:

  // string hardware_type = 6 [json_name = "hardwareType"];
  void clear_hardware_type();
  const std::string& hardware_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardware_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardware_type();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_hardware_type();
  void set_allocated_hardware_type(std::string* hardware_type);
  private:
  const std::string& _internal_hardware_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_type(const std::string& value);
  std::string* _internal_mutable_hardware_type();
  public:

  // string ip_cam_username = 9 [json_name = "ipCamUsername"];
  void clear_ip_cam_username();
  const std::string& ip_cam_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_cam_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_cam_username();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_ip_cam_username();
  void set_allocated_ip_cam_username(std::string* ip_cam_username);
  private:
  const std::string& _internal_ip_cam_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_cam_username(const std::string& value);
  std::string* _internal_mutable_ip_cam_username();
  public:

  // string ip_cam_password = 10 [json_name = "ipCamPassword"];
  void clear_ip_cam_password();
  const std::string& ip_cam_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_cam_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_cam_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_ip_cam_password();
  void set_allocated_ip_cam_password(std::string* ip_cam_password);
  private:
  const std::string& _internal_ip_cam_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_cam_password(const std::string& value);
  std::string* _internal_mutable_ip_cam_password();
  public:

  // .v1.model.TeleopMode mode = 3 [json_name = "mode"];
  void clear_mode();
  ::v1::model::TeleopMode mode() const;
  void set_mode(::v1::model::TeleopMode value);
  private:
  ::v1::model::TeleopMode _internal_mode() const;
  void _internal_set_mode(::v1::model::TeleopMode value);
  public:

  // bool rtsp_encoding_needed = 7 [json_name = "rtspEncodingNeeded"];
  void clear_rtsp_encoding_needed();
  bool rtsp_encoding_needed() const;
  void set_rtsp_encoding_needed(bool value);
  private:
  bool _internal_rtsp_encoding_needed() const;
  void _internal_set_rtsp_encoding_needed(bool value);
  public:

  // bool is_onvif = 8 [json_name = "isOnvif"];
  void clear_is_onvif();
  bool is_onvif() const;
  void set_is_onvif(bool value);
  private:
  bool _internal_is_onvif() const;
  void _internal_set_is_onvif(bool value);
  public:

  // bool overlay_clock = 11 [json_name = "overlayClock"];
  void clear_overlay_clock();
  bool overlay_clock() const;
  void set_overlay_clock(bool value);
  private:
  bool _internal_overlay_clock() const;
  void _internal_set_overlay_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.TeleopHardwareStreamConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rtc_stream_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hw_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quality_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardware_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_cam_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_cam_password_;
  int mode_;
  bool rtsp_encoding_needed_;
  bool is_onvif_;
  bool overlay_clock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TeleopCustomStreamConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TeleopCustomStreamConfiguration) */ {
 public:
  inline TeleopCustomStreamConfiguration() : TeleopCustomStreamConfiguration(nullptr) {}
  ~TeleopCustomStreamConfiguration() override;
  explicit constexpr TeleopCustomStreamConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeleopCustomStreamConfiguration(const TeleopCustomStreamConfiguration& from);
  TeleopCustomStreamConfiguration(TeleopCustomStreamConfiguration&& from) noexcept
    : TeleopCustomStreamConfiguration() {
    *this = ::std::move(from);
  }

  inline TeleopCustomStreamConfiguration& operator=(const TeleopCustomStreamConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeleopCustomStreamConfiguration& operator=(TeleopCustomStreamConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeleopCustomStreamConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeleopCustomStreamConfiguration* internal_default_instance() {
    return reinterpret_cast<const TeleopCustomStreamConfiguration*>(
               &_TeleopCustomStreamConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TeleopCustomStreamConfiguration& a, TeleopCustomStreamConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TeleopCustomStreamConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeleopCustomStreamConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TeleopCustomStreamConfiguration* New() const final {
    return new TeleopCustomStreamConfiguration();
  }

  TeleopCustomStreamConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TeleopCustomStreamConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TeleopCustomStreamConfiguration& from);
  void MergeFrom(const TeleopCustomStreamConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeleopCustomStreamConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TeleopCustomStreamConfiguration";
  }
  protected:
  explicit TeleopCustomStreamConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kRtcStreamTypeFieldNumber = 2,
    kQualityFieldNumber = 5,
    kModeFieldNumber = 3,
    kEncodeVideoFieldNumber = 4,
    kOverlayClockFieldNumber = 6,
  };
  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string rtc_stream_type = 2 [json_name = "rtcStreamType"];
  void clear_rtc_stream_type();
  const std::string& rtc_stream_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rtc_stream_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rtc_stream_type();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_rtc_stream_type();
  void set_allocated_rtc_stream_type(std::string* rtc_stream_type);
  private:
  const std::string& _internal_rtc_stream_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtc_stream_type(const std::string& value);
  std::string* _internal_mutable_rtc_stream_type();
  public:

  // string quality = 5 [json_name = "quality"];
  void clear_quality();
  const std::string& quality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quality();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_quality();
  void set_allocated_quality(std::string* quality);
  private:
  const std::string& _internal_quality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quality(const std::string& value);
  std::string* _internal_mutable_quality();
  public:

  // .v1.model.TeleopMode mode = 3 [json_name = "mode"];
  void clear_mode();
  ::v1::model::TeleopMode mode() const;
  void set_mode(::v1::model::TeleopMode value);
  private:
  ::v1::model::TeleopMode _internal_mode() const;
  void _internal_set_mode(::v1::model::TeleopMode value);
  public:

  // bool encode_video = 4 [json_name = "encodeVideo"];
  void clear_encode_video();
  bool encode_video() const;
  void set_encode_video(bool value);
  private:
  bool _internal_encode_video() const;
  void _internal_set_encode_video(bool value);
  public:

  // bool overlay_clock = 6 [json_name = "overlayClock"];
  void clear_overlay_clock();
  bool overlay_clock() const;
  void set_overlay_clock(bool value);
  private:
  bool _internal_overlay_clock() const;
  void _internal_set_overlay_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.TeleopCustomStreamConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rtc_stream_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quality_;
  int mode_;
  bool encode_video_;
  bool overlay_clock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class TelemetryConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TelemetryConfiguration) */ {
 public:
  inline TelemetryConfiguration() : TelemetryConfiguration(nullptr) {}
  ~TelemetryConfiguration() override;
  explicit constexpr TelemetryConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TelemetryConfiguration(const TelemetryConfiguration& from);
  TelemetryConfiguration(TelemetryConfiguration&& from) noexcept
    : TelemetryConfiguration() {
    *this = ::std::move(from);
  }

  inline TelemetryConfiguration& operator=(const TelemetryConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline TelemetryConfiguration& operator=(TelemetryConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TelemetryConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const TelemetryConfiguration* internal_default_instance() {
    return reinterpret_cast<const TelemetryConfiguration*>(
               &_TelemetryConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TelemetryConfiguration& a, TelemetryConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(TelemetryConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TelemetryConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TelemetryConfiguration* New() const final {
    return new TelemetryConfiguration();
  }

  TelemetryConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TelemetryConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TelemetryConfiguration& from);
  void MergeFrom(const TelemetryConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TelemetryConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TelemetryConfiguration";
  }
  protected:
  explicit TelemetryConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamsFieldNumber = 1,
    kRosFieldNumber = 2,
  };
  // repeated .v1.model.StreamConfiguration streams = 1 [json_name = "streams"];
  int streams_size() const;
  private:
  int _internal_streams_size() const;
  public:
  void clear_streams();
  ::v1::model::StreamConfiguration* mutable_streams(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::StreamConfiguration >*
      mutable_streams();
  private:
  const ::v1::model::StreamConfiguration& _internal_streams(int index) const;
  ::v1::model::StreamConfiguration* _internal_add_streams();
  public:
  const ::v1::model::StreamConfiguration& streams(int index) const;
  ::v1::model::StreamConfiguration* add_streams();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::StreamConfiguration >&
      streams() const;

  // .v1.model.ROSConfiguration ros = 2 [json_name = "ros"];
  bool has_ros() const;
  private:
  bool _internal_has_ros() const;
  public:
  void clear_ros();
  const ::v1::model::ROSConfiguration& ros() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ROSConfiguration* release_ros();
  ::v1::model::ROSConfiguration* mutable_ros();
  void set_allocated_ros(::v1::model::ROSConfiguration* ros);
  private:
  const ::v1::model::ROSConfiguration& _internal_ros() const;
  ::v1::model::ROSConfiguration* _internal_mutable_ros();
  public:
  void unsafe_arena_set_allocated_ros(
      ::v1::model::ROSConfiguration* ros);
  ::v1::model::ROSConfiguration* unsafe_arena_release_ros();

  // @@protoc_insertion_point(class_scope:v1.model.TelemetryConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::StreamConfiguration > streams_;
  ::v1::model::ROSConfiguration* ros_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ApplicationConfiguration_ConfigurationMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ApplicationConfiguration_ConfigurationMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ApplicationConfiguration_ConfigurationMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  ApplicationConfiguration_ConfigurationMapEntry_DoNotUse();
  explicit constexpr ApplicationConfiguration_ConfigurationMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit ApplicationConfiguration_ConfigurationMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ApplicationConfiguration_ConfigurationMapEntry_DoNotUse& other);
  static const ApplicationConfiguration_ConfigurationMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ApplicationConfiguration_ConfigurationMapEntry_DoNotUse*>(&_ApplicationConfiguration_ConfigurationMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.ApplicationConfiguration.ConfigurationMapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.ApplicationConfiguration.ConfigurationMapEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class ApplicationConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.ApplicationConfiguration) */ {
 public:
  inline ApplicationConfiguration() : ApplicationConfiguration(nullptr) {}
  ~ApplicationConfiguration() override;
  explicit constexpr ApplicationConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplicationConfiguration(const ApplicationConfiguration& from);
  ApplicationConfiguration(ApplicationConfiguration&& from) noexcept
    : ApplicationConfiguration() {
    *this = ::std::move(from);
  }

  inline ApplicationConfiguration& operator=(const ApplicationConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplicationConfiguration& operator=(ApplicationConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplicationConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplicationConfiguration* internal_default_instance() {
    return reinterpret_cast<const ApplicationConfiguration*>(
               &_ApplicationConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ApplicationConfiguration& a, ApplicationConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplicationConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplicationConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ApplicationConfiguration* New() const final {
    return new ApplicationConfiguration();
  }

  ApplicationConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ApplicationConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ApplicationConfiguration& from);
  void MergeFrom(const ApplicationConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplicationConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.ApplicationConfiguration";
  }
  protected:
  explicit ApplicationConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationMapFieldNumber = 1,
  };
  // map<string, string> configuration_map = 1 [json_name = "configurationMap"];
  int configuration_map_size() const;
  private:
  int _internal_configuration_map_size() const;
  public:
  void clear_configuration_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_configuration_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_configuration_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      configuration_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_configuration_map();

  // @@protoc_insertion_point(class_scope:v1.model.ApplicationConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ApplicationConfiguration_ConfigurationMapEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> configuration_map_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ResourcesConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.ResourcesConfiguration) */ {
 public:
  inline ResourcesConfiguration() : ResourcesConfiguration(nullptr) {}
  ~ResourcesConfiguration() override;
  explicit constexpr ResourcesConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResourcesConfiguration(const ResourcesConfiguration& from);
  ResourcesConfiguration(ResourcesConfiguration&& from) noexcept
    : ResourcesConfiguration() {
    *this = ::std::move(from);
  }

  inline ResourcesConfiguration& operator=(const ResourcesConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResourcesConfiguration& operator=(ResourcesConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResourcesConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResourcesConfiguration* internal_default_instance() {
    return reinterpret_cast<const ResourcesConfiguration*>(
               &_ResourcesConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ResourcesConfiguration& a, ResourcesConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ResourcesConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResourcesConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResourcesConfiguration* New() const final {
    return new ResourcesConfiguration();
  }

  ResourcesConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResourcesConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResourcesConfiguration& from);
  void MergeFrom(const ResourcesConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourcesConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.ResourcesConfiguration";
  }
  protected:
  explicit ResourcesConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiskFieldNumber = 1,
    kStreamThrottleHzFieldNumber = 2,
    kDatapointBatchSizeFieldNumber = 4,
    kDatapointBatchLifetimeMsFieldNumber = 5,
    kAssetBatchSizeFieldNumber = 6,
    kAssetBatchLifetimeMsFieldNumber = 7,
    kLowBandwidthAgentFieldNumber = 3,
  };
  // .v1.model.DiskConfiguration disk = 1 [json_name = "disk"];
  bool has_disk() const;
  private:
  bool _internal_has_disk() const;
  public:
  void clear_disk();
  const ::v1::model::DiskConfiguration& disk() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::DiskConfiguration* release_disk();
  ::v1::model::DiskConfiguration* mutable_disk();
  void set_allocated_disk(::v1::model::DiskConfiguration* disk);
  private:
  const ::v1::model::DiskConfiguration& _internal_disk() const;
  ::v1::model::DiskConfiguration* _internal_mutable_disk();
  public:
  void unsafe_arena_set_allocated_disk(
      ::v1::model::DiskConfiguration* disk);
  ::v1::model::DiskConfiguration* unsafe_arena_release_disk();

  // .google.protobuf.DoubleValue stream_throttle_hz = 2 [json_name = "streamThrottleHz"];
  bool has_stream_throttle_hz() const;
  private:
  bool _internal_has_stream_throttle_hz() const;
  public:
  void clear_stream_throttle_hz();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& stream_throttle_hz() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_stream_throttle_hz();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_stream_throttle_hz();
  void set_allocated_stream_throttle_hz(PROTOBUF_NAMESPACE_ID::DoubleValue* stream_throttle_hz);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_stream_throttle_hz() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_stream_throttle_hz();
  public:
  void unsafe_arena_set_allocated_stream_throttle_hz(
      PROTOBUF_NAMESPACE_ID::DoubleValue* stream_throttle_hz);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_stream_throttle_hz();

  // uint64 datapoint_batch_size = 4 [json_name = "datapointBatchSize"];
  void clear_datapoint_batch_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 datapoint_batch_size() const;
  void set_datapoint_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_datapoint_batch_size() const;
  void _internal_set_datapoint_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 datapoint_batchLifetime_ms = 5 [json_name = "datapointBatchLifetimeMs"];
  void clear_datapoint_batchlifetime_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 datapoint_batchlifetime_ms() const;
  void set_datapoint_batchlifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_datapoint_batchlifetime_ms() const;
  void _internal_set_datapoint_batchlifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 asset_batch_size = 6 [json_name = "assetBatchSize"];
  void clear_asset_batch_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 asset_batch_size() const;
  void set_asset_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_asset_batch_size() const;
  void _internal_set_asset_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 asset_batch_lifetime_ms = 7 [json_name = "assetBatchLifetimeMs"];
  void clear_asset_batch_lifetime_ms();
  ::PROTOBUF_NAMESPACE_ID::uint64 asset_batch_lifetime_ms() const;
  void set_asset_batch_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_asset_batch_lifetime_ms() const;
  void _internal_set_asset_batch_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool low_bandwidth_agent = 3 [json_name = "lowBandwidthAgent"];
  void clear_low_bandwidth_agent();
  bool low_bandwidth_agent() const;
  void set_low_bandwidth_agent(bool value);
  private:
  bool _internal_low_bandwidth_agent() const;
  void _internal_set_low_bandwidth_agent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.ResourcesConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::v1::model::DiskConfiguration* disk_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* stream_throttle_hz_;
  ::PROTOBUF_NAMESPACE_ID::uint64 datapoint_batch_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 datapoint_batchlifetime_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint64 asset_batch_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 asset_batch_lifetime_ms_;
  bool low_bandwidth_agent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class DiskConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.DiskConfiguration) */ {
 public:
  inline DiskConfiguration() : DiskConfiguration(nullptr) {}
  ~DiskConfiguration() override;
  explicit constexpr DiskConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DiskConfiguration(const DiskConfiguration& from);
  DiskConfiguration(DiskConfiguration&& from) noexcept
    : DiskConfiguration() {
    *this = ::std::move(from);
  }

  inline DiskConfiguration& operator=(const DiskConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline DiskConfiguration& operator=(DiskConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DiskConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const DiskConfiguration* internal_default_instance() {
    return reinterpret_cast<const DiskConfiguration*>(
               &_DiskConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DiskConfiguration& a, DiskConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(DiskConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DiskConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DiskConfiguration* New() const final {
    return new DiskConfiguration();
  }

  DiskConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DiskConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DiskConfiguration& from);
  void MergeFrom(const DiskConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DiskConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.DiskConfiguration";
  }
  protected:
  explicit DiskConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufferSizeFieldNumber = 1,
    kOnDemandBufferSizeFieldNumber = 2,
  };
  // int64 buffer_size = 1 [json_name = "bufferSize"];
  void clear_buffer_size();
  ::PROTOBUF_NAMESPACE_ID::int64 buffer_size() const;
  void set_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_buffer_size() const;
  void _internal_set_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 on_demand_buffer_size = 2 [json_name = "onDemandBufferSize"];
  void clear_on_demand_buffer_size();
  ::PROTOBUF_NAMESPACE_ID::int64 on_demand_buffer_size() const;
  void set_on_demand_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_on_demand_buffer_size() const;
  void _internal_set_on_demand_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.DiskConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 buffer_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 on_demand_buffer_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class ROSConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.ROSConfiguration) */ {
 public:
  inline ROSConfiguration() : ROSConfiguration(nullptr) {}
  ~ROSConfiguration() override;
  explicit constexpr ROSConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ROSConfiguration(const ROSConfiguration& from);
  ROSConfiguration(ROSConfiguration&& from) noexcept
    : ROSConfiguration() {
    *this = ::std::move(from);
  }

  inline ROSConfiguration& operator=(const ROSConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline ROSConfiguration& operator=(ROSConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ROSConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const ROSConfiguration* internal_default_instance() {
    return reinterpret_cast<const ROSConfiguration*>(
               &_ROSConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ROSConfiguration& a, ROSConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(ROSConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ROSConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ROSConfiguration* New() const final {
    return new ROSConfiguration();
  }

  ROSConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ROSConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ROSConfiguration& from);
  void MergeFrom(const ROSConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ROSConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.ROSConfiguration";
  }
  protected:
  explicit ROSConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldReferenceFrameIdFieldNumber = 1,
  };
  // string world_reference_frame_id = 1 [json_name = "worldReferenceFrameId"];
  void clear_world_reference_frame_id();
  const std::string& world_reference_frame_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_world_reference_frame_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_world_reference_frame_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_world_reference_frame_id();
  void set_allocated_world_reference_frame_id(std::string* world_reference_frame_id);
  private:
  const std::string& _internal_world_reference_frame_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_world_reference_frame_id(const std::string& value);
  std::string* _internal_mutable_world_reference_frame_id();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.ROSConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr world_reference_frame_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class StreamConfiguration_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StreamConfiguration_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<StreamConfiguration_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  StreamConfiguration_TagsEntry_DoNotUse();
  explicit constexpr StreamConfiguration_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit StreamConfiguration_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const StreamConfiguration_TagsEntry_DoNotUse& other);
  static const StreamConfiguration_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const StreamConfiguration_TagsEntry_DoNotUse*>(&_StreamConfiguration_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.StreamConfiguration.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.StreamConfiguration.TagsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class StreamConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.StreamConfiguration) */ {
 public:
  inline StreamConfiguration() : StreamConfiguration(nullptr) {}
  ~StreamConfiguration() override;
  explicit constexpr StreamConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamConfiguration(const StreamConfiguration& from);
  StreamConfiguration(StreamConfiguration&& from) noexcept
    : StreamConfiguration() {
    *this = ::std::move(from);
  }

  inline StreamConfiguration& operator=(const StreamConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamConfiguration& operator=(StreamConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamConfiguration& default_instance() {
    return *internal_default_instance();
  }
  enum ConfigurationCase {
    kRosTopic = 3,
    kRosLocalization = 4,
    kDirectoryWatch = 5,
    kFileTail = 6,
    kRosTransformTree = 7,
    kCustom = 9,
    kHardware = 10,
    CONFIGURATION_NOT_SET = 0,
  };

  static inline const StreamConfiguration* internal_default_instance() {
    return reinterpret_cast<const StreamConfiguration*>(
               &_StreamConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StreamConfiguration& a, StreamConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamConfiguration* New() const final {
    return new StreamConfiguration();
  }

  StreamConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamConfiguration& from);
  void MergeFrom(const StreamConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.StreamConfiguration";
  }
  protected:
  explicit StreamConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 2,
    kNameFieldNumber = 1,
    kQualityFieldNumber = 22,
    kThrottleHzFieldNumber = 8,
    kDisabledFieldNumber = 19,
    kOnDemandFieldNumber = 20,
    kTransformFieldNumber = 21,
    kRosTopicFieldNumber = 3,
    kRosLocalizationFieldNumber = 4,
    kDirectoryWatchFieldNumber = 5,
    kFileTailFieldNumber = 6,
    kRosTransformTreeFieldNumber = 7,
    kCustomFieldNumber = 9,
    kHardwareFieldNumber = 10,
  };
  // map<string, string> tags = 2 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string name = 1 [json_name = "name"];
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string quality = 22 [json_name = "quality"];
  void clear_quality();
  const std::string& quality() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_quality(ArgT0&& arg0, ArgT... args);
  std::string* mutable_quality();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_quality();
  void set_allocated_quality(std::string* quality);
  private:
  const std::string& _internal_quality() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_quality(const std::string& value);
  std::string* _internal_mutable_quality();
  public:

  // .google.protobuf.DoubleValue throttle_hz = 8 [json_name = "throttleHz"];
  bool has_throttle_hz() const;
  private:
  bool _internal_has_throttle_hz() const;
  public:
  void clear_throttle_hz();
  const PROTOBUF_NAMESPACE_ID::DoubleValue& throttle_hz() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::DoubleValue* release_throttle_hz();
  PROTOBUF_NAMESPACE_ID::DoubleValue* mutable_throttle_hz();
  void set_allocated_throttle_hz(PROTOBUF_NAMESPACE_ID::DoubleValue* throttle_hz);
  private:
  const PROTOBUF_NAMESPACE_ID::DoubleValue& _internal_throttle_hz() const;
  PROTOBUF_NAMESPACE_ID::DoubleValue* _internal_mutable_throttle_hz();
  public:
  void unsafe_arena_set_allocated_throttle_hz(
      PROTOBUF_NAMESPACE_ID::DoubleValue* throttle_hz);
  PROTOBUF_NAMESPACE_ID::DoubleValue* unsafe_arena_release_throttle_hz();

  // .google.protobuf.BoolValue disabled = 19 [json_name = "disabled"];
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  const PROTOBUF_NAMESPACE_ID::BoolValue& disabled() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_disabled();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_disabled();
  void set_allocated_disabled(PROTOBUF_NAMESPACE_ID::BoolValue* disabled);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_disabled() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_disabled();
  public:
  void unsafe_arena_set_allocated_disabled(
      PROTOBUF_NAMESPACE_ID::BoolValue* disabled);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_disabled();

  // .google.protobuf.BoolValue on_demand = 20 [json_name = "onDemand"];
  bool has_on_demand() const;
  private:
  bool _internal_has_on_demand() const;
  public:
  void clear_on_demand();
  const PROTOBUF_NAMESPACE_ID::BoolValue& on_demand() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_on_demand();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_on_demand();
  void set_allocated_on_demand(PROTOBUF_NAMESPACE_ID::BoolValue* on_demand);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_on_demand() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_on_demand();
  public:
  void unsafe_arena_set_allocated_on_demand(
      PROTOBUF_NAMESPACE_ID::BoolValue* on_demand);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_on_demand();

  // .v1.model.StreamTransformConfiguration transform = 21 [json_name = "transform"];
  bool has_transform() const;
  private:
  bool _internal_has_transform() const;
  public:
  void clear_transform();
  const ::v1::model::StreamTransformConfiguration& transform() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::StreamTransformConfiguration* release_transform();
  ::v1::model::StreamTransformConfiguration* mutable_transform();
  void set_allocated_transform(::v1::model::StreamTransformConfiguration* transform);
  private:
  const ::v1::model::StreamTransformConfiguration& _internal_transform() const;
  ::v1::model::StreamTransformConfiguration* _internal_mutable_transform();
  public:
  void unsafe_arena_set_allocated_transform(
      ::v1::model::StreamTransformConfiguration* transform);
  ::v1::model::StreamTransformConfiguration* unsafe_arena_release_transform();

  // .v1.model.ROSTopic ros_topic = 3 [json_name = "rosTopic"];
  bool has_ros_topic() const;
  private:
  bool _internal_has_ros_topic() const;
  public:
  void clear_ros_topic();
  const ::v1::model::ROSTopic& ros_topic() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ROSTopic* release_ros_topic();
  ::v1::model::ROSTopic* mutable_ros_topic();
  void set_allocated_ros_topic(::v1::model::ROSTopic* ros_topic);
  private:
  const ::v1::model::ROSTopic& _internal_ros_topic() const;
  ::v1::model::ROSTopic* _internal_mutable_ros_topic();
  public:
  void unsafe_arena_set_allocated_ros_topic(
      ::v1::model::ROSTopic* ros_topic);
  ::v1::model::ROSTopic* unsafe_arena_release_ros_topic();

  // .v1.model.ROSLocalization ros_localization = 4 [json_name = "rosLocalization"];
  bool has_ros_localization() const;
  private:
  bool _internal_has_ros_localization() const;
  public:
  void clear_ros_localization();
  const ::v1::model::ROSLocalization& ros_localization() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ROSLocalization* release_ros_localization();
  ::v1::model::ROSLocalization* mutable_ros_localization();
  void set_allocated_ros_localization(::v1::model::ROSLocalization* ros_localization);
  private:
  const ::v1::model::ROSLocalization& _internal_ros_localization() const;
  ::v1::model::ROSLocalization* _internal_mutable_ros_localization();
  public:
  void unsafe_arena_set_allocated_ros_localization(
      ::v1::model::ROSLocalization* ros_localization);
  ::v1::model::ROSLocalization* unsafe_arena_release_ros_localization();

  // .v1.model.DirectoryWatch directory_watch = 5 [json_name = "directoryWatch"];
  bool has_directory_watch() const;
  private:
  bool _internal_has_directory_watch() const;
  public:
  void clear_directory_watch();
  const ::v1::model::DirectoryWatch& directory_watch() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::DirectoryWatch* release_directory_watch();
  ::v1::model::DirectoryWatch* mutable_directory_watch();
  void set_allocated_directory_watch(::v1::model::DirectoryWatch* directory_watch);
  private:
  const ::v1::model::DirectoryWatch& _internal_directory_watch() const;
  ::v1::model::DirectoryWatch* _internal_mutable_directory_watch();
  public:
  void unsafe_arena_set_allocated_directory_watch(
      ::v1::model::DirectoryWatch* directory_watch);
  ::v1::model::DirectoryWatch* unsafe_arena_release_directory_watch();

  // .v1.model.FileTail file_tail = 6 [json_name = "fileTail"];
  bool has_file_tail() const;
  private:
  bool _internal_has_file_tail() const;
  public:
  void clear_file_tail();
  const ::v1::model::FileTail& file_tail() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::FileTail* release_file_tail();
  ::v1::model::FileTail* mutable_file_tail();
  void set_allocated_file_tail(::v1::model::FileTail* file_tail);
  private:
  const ::v1::model::FileTail& _internal_file_tail() const;
  ::v1::model::FileTail* _internal_mutable_file_tail();
  public:
  void unsafe_arena_set_allocated_file_tail(
      ::v1::model::FileTail* file_tail);
  ::v1::model::FileTail* unsafe_arena_release_file_tail();

  // .v1.model.ROSTransformTree ros_transform_tree = 7 [json_name = "rosTransformTree"];
  bool has_ros_transform_tree() const;
  private:
  bool _internal_has_ros_transform_tree() const;
  public:
  void clear_ros_transform_tree();
  const ::v1::model::ROSTransformTree& ros_transform_tree() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ROSTransformTree* release_ros_transform_tree();
  ::v1::model::ROSTransformTree* mutable_ros_transform_tree();
  void set_allocated_ros_transform_tree(::v1::model::ROSTransformTree* ros_transform_tree);
  private:
  const ::v1::model::ROSTransformTree& _internal_ros_transform_tree() const;
  ::v1::model::ROSTransformTree* _internal_mutable_ros_transform_tree();
  public:
  void unsafe_arena_set_allocated_ros_transform_tree(
      ::v1::model::ROSTransformTree* ros_transform_tree);
  ::v1::model::ROSTransformTree* unsafe_arena_release_ros_transform_tree();

  // .v1.model.Custom custom = 9 [json_name = "custom"];
  bool has_custom() const;
  private:
  bool _internal_has_custom() const;
  public:
  void clear_custom();
  const ::v1::model::Custom& custom() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Custom* release_custom();
  ::v1::model::Custom* mutable_custom();
  void set_allocated_custom(::v1::model::Custom* custom);
  private:
  const ::v1::model::Custom& _internal_custom() const;
  ::v1::model::Custom* _internal_mutable_custom();
  public:
  void unsafe_arena_set_allocated_custom(
      ::v1::model::Custom* custom);
  ::v1::model::Custom* unsafe_arena_release_custom();

  // .v1.model.Hardware hardware = 10 [json_name = "hardware"];
  bool has_hardware() const;
  private:
  bool _internal_has_hardware() const;
  public:
  void clear_hardware();
  const ::v1::model::Hardware& hardware() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Hardware* release_hardware();
  ::v1::model::Hardware* mutable_hardware();
  void set_allocated_hardware(::v1::model::Hardware* hardware);
  private:
  const ::v1::model::Hardware& _internal_hardware() const;
  ::v1::model::Hardware* _internal_mutable_hardware();
  public:
  void unsafe_arena_set_allocated_hardware(
      ::v1::model::Hardware* hardware);
  ::v1::model::Hardware* unsafe_arena_release_hardware();

  void clear_configuration();
  ConfigurationCase configuration_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.StreamConfiguration)
 private:
  class _Internal;
  void set_has_ros_topic();
  void set_has_ros_localization();
  void set_has_directory_watch();
  void set_has_file_tail();
  void set_has_ros_transform_tree();
  void set_has_custom();
  void set_has_hardware();

  inline bool has_configuration() const;
  inline void clear_has_configuration();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      StreamConfiguration_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quality_;
  PROTOBUF_NAMESPACE_ID::DoubleValue* throttle_hz_;
  PROTOBUF_NAMESPACE_ID::BoolValue* disabled_;
  PROTOBUF_NAMESPACE_ID::BoolValue* on_demand_;
  ::v1::model::StreamTransformConfiguration* transform_;
  union ConfigurationUnion {
    constexpr ConfigurationUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::ROSTopic* ros_topic_;
    ::v1::model::ROSLocalization* ros_localization_;
    ::v1::model::DirectoryWatch* directory_watch_;
    ::v1::model::FileTail* file_tail_;
    ::v1::model::ROSTransformTree* ros_transform_tree_;
    ::v1::model::Custom* custom_;
    ::v1::model::Hardware* hardware_;
  } configuration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class StreamTransformConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.StreamTransformConfiguration) */ {
 public:
  inline StreamTransformConfiguration() : StreamTransformConfiguration(nullptr) {}
  ~StreamTransformConfiguration() override;
  explicit constexpr StreamTransformConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamTransformConfiguration(const StreamTransformConfiguration& from);
  StreamTransformConfiguration(StreamTransformConfiguration&& from) noexcept
    : StreamTransformConfiguration() {
    *this = ::std::move(from);
  }

  inline StreamTransformConfiguration& operator=(const StreamTransformConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamTransformConfiguration& operator=(StreamTransformConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StreamTransformConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamTransformConfiguration* internal_default_instance() {
    return reinterpret_cast<const StreamTransformConfiguration*>(
               &_StreamTransformConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StreamTransformConfiguration& a, StreamTransformConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(StreamTransformConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamTransformConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StreamTransformConfiguration* New() const final {
    return new StreamTransformConfiguration();
  }

  StreamTransformConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StreamTransformConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StreamTransformConfiguration& from);
  void MergeFrom(const StreamTransformConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StreamTransformConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.StreamTransformConfiguration";
  }
  protected:
  explicit StreamTransformConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoEncodingEnabledFieldNumber = 1,
  };
  // .google.protobuf.BoolValue video_encoding_enabled = 1 [json_name = "videoEncodingEnabled"];
  bool has_video_encoding_enabled() const;
  private:
  bool _internal_has_video_encoding_enabled() const;
  public:
  void clear_video_encoding_enabled();
  const PROTOBUF_NAMESPACE_ID::BoolValue& video_encoding_enabled() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_video_encoding_enabled();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_video_encoding_enabled();
  void set_allocated_video_encoding_enabled(PROTOBUF_NAMESPACE_ID::BoolValue* video_encoding_enabled);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_video_encoding_enabled() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_video_encoding_enabled();
  public:
  void unsafe_arena_set_allocated_video_encoding_enabled(
      PROTOBUF_NAMESPACE_ID::BoolValue* video_encoding_enabled);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_video_encoding_enabled();

  // @@protoc_insertion_point(class_scope:v1.model.StreamTransformConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::BoolValue* video_encoding_enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class BlobData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.BlobData) */ {
 public:
  inline BlobData() : BlobData(nullptr) {}
  ~BlobData() override;
  explicit constexpr BlobData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlobData(const BlobData& from);
  BlobData(BlobData&& from) noexcept
    : BlobData() {
    *this = ::std::move(from);
  }

  inline BlobData& operator=(const BlobData& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobData& operator=(BlobData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlobData& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlobData* internal_default_instance() {
    return reinterpret_cast<const BlobData*>(
               &_BlobData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BlobData& a, BlobData& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobData* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlobData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlobData* New() const final {
    return new BlobData();
  }

  BlobData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlobData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlobData& from);
  void MergeFrom(const BlobData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.BlobData";
  }
  protected:
  explicit BlobData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // string data = 1 [json_name = "data"];
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.BlobData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Diagnostics final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Diagnostics) */ {
 public:
  inline Diagnostics() : Diagnostics(nullptr) {}
  ~Diagnostics() override;
  explicit constexpr Diagnostics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Diagnostics(const Diagnostics& from);
  Diagnostics(Diagnostics&& from) noexcept
    : Diagnostics() {
    *this = ::std::move(from);
  }

  inline Diagnostics& operator=(const Diagnostics& from) {
    CopyFrom(from);
    return *this;
  }
  inline Diagnostics& operator=(Diagnostics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Diagnostics& default_instance() {
    return *internal_default_instance();
  }
  static inline const Diagnostics* internal_default_instance() {
    return reinterpret_cast<const Diagnostics*>(
               &_Diagnostics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Diagnostics& a, Diagnostics& b) {
    a.Swap(&b);
  }
  inline void Swap(Diagnostics* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Diagnostics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Diagnostics* New() const final {
    return new Diagnostics();
  }

  Diagnostics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Diagnostics>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Diagnostics& from);
  void MergeFrom(const Diagnostics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Diagnostics* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Diagnostics";
  }
  protected:
  explicit Diagnostics(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReportLogsFieldNumber = 1,
    kReportMetricsFieldNumber = 2,
  };
  // .google.protobuf.BoolValue report_logs = 1 [json_name = "reportLogs"];
  bool has_report_logs() const;
  private:
  bool _internal_has_report_logs() const;
  public:
  void clear_report_logs();
  const PROTOBUF_NAMESPACE_ID::BoolValue& report_logs() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_report_logs();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_report_logs();
  void set_allocated_report_logs(PROTOBUF_NAMESPACE_ID::BoolValue* report_logs);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_report_logs() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_report_logs();
  public:
  void unsafe_arena_set_allocated_report_logs(
      PROTOBUF_NAMESPACE_ID::BoolValue* report_logs);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_report_logs();

  // .google.protobuf.BoolValue report_metrics = 2 [json_name = "reportMetrics"];
  bool has_report_metrics() const;
  private:
  bool _internal_has_report_metrics() const;
  public:
  void clear_report_metrics();
  const PROTOBUF_NAMESPACE_ID::BoolValue& report_metrics() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT PROTOBUF_NAMESPACE_ID::BoolValue* release_report_metrics();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_report_metrics();
  void set_allocated_report_metrics(PROTOBUF_NAMESPACE_ID::BoolValue* report_metrics);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_report_metrics() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_report_metrics();
  public:
  void unsafe_arena_set_allocated_report_metrics(
      PROTOBUF_NAMESPACE_ID::BoolValue* report_metrics);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_report_metrics();

  // @@protoc_insertion_point(class_scope:v1.model.Diagnostics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::BoolValue* report_logs_;
  PROTOBUF_NAMESPACE_ID::BoolValue* report_metrics_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Custom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Custom) */ {
 public:
  inline Custom() : Custom(nullptr) {}
  ~Custom() override;
  explicit constexpr Custom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Custom(const Custom& from);
  Custom(Custom&& from) noexcept
    : Custom() {
    *this = ::std::move(from);
  }

  inline Custom& operator=(const Custom& from) {
    CopyFrom(from);
    return *this;
  }
  inline Custom& operator=(Custom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Custom& default_instance() {
    return *internal_default_instance();
  }
  static inline const Custom* internal_default_instance() {
    return reinterpret_cast<const Custom*>(
               &_Custom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Custom& a, Custom& b) {
    a.Swap(&b);
  }
  inline void Swap(Custom* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Custom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Custom* New() const final {
    return new Custom();
  }

  Custom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Custom>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Custom& from);
  void MergeFrom(const Custom& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Custom* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Custom";
  }
  protected:
  explicit Custom(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:v1.model.Custom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class Hardware final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Hardware) */ {
 public:
  inline Hardware() : Hardware(nullptr) {}
  ~Hardware() override;
  explicit constexpr Hardware(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hardware(const Hardware& from);
  Hardware(Hardware&& from) noexcept
    : Hardware() {
    *this = ::std::move(from);
  }

  inline Hardware& operator=(const Hardware& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hardware& operator=(Hardware&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hardware& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hardware* internal_default_instance() {
    return reinterpret_cast<const Hardware*>(
               &_Hardware_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Hardware& a, Hardware& b) {
    a.Swap(&b);
  }
  inline void Swap(Hardware* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hardware* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Hardware* New() const final {
    return new Hardware();
  }

  Hardware* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Hardware>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Hardware& from);
  void MergeFrom(const Hardware& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hardware* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Hardware";
  }
  protected:
  explicit Hardware(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHwDescriptorFieldNumber = 1,
    kAudioHwDescriptorFieldNumber = 3,
    kHardwareTypeFieldNumber = 4,
    kIpCamUsernameFieldNumber = 7,
    kIpCamPasswordFieldNumber = 8,
    kRtspEncodingNeededFieldNumber = 5,
    kIsOnvifFieldNumber = 6,
    kOverlayClockFieldNumber = 9,
  };
  // string hw_descriptor = 1 [json_name = "hwDescriptor"];
  void clear_hw_descriptor();
  const std::string& hw_descriptor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hw_descriptor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hw_descriptor();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_hw_descriptor();
  void set_allocated_hw_descriptor(std::string* hw_descriptor);
  private:
  const std::string& _internal_hw_descriptor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hw_descriptor(const std::string& value);
  std::string* _internal_mutable_hw_descriptor();
  public:

  // string audio_hw_descriptor = 3 [json_name = "audioHwDescriptor"];
  void clear_audio_hw_descriptor();
  const std::string& audio_hw_descriptor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_audio_hw_descriptor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_audio_hw_descriptor();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_audio_hw_descriptor();
  void set_allocated_audio_hw_descriptor(std::string* audio_hw_descriptor);
  private:
  const std::string& _internal_audio_hw_descriptor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_audio_hw_descriptor(const std::string& value);
  std::string* _internal_mutable_audio_hw_descriptor();
  public:

  // string hardware_type = 4 [json_name = "hardwareType"];
  void clear_hardware_type();
  const std::string& hardware_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hardware_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hardware_type();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_hardware_type();
  void set_allocated_hardware_type(std::string* hardware_type);
  private:
  const std::string& _internal_hardware_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hardware_type(const std::string& value);
  std::string* _internal_mutable_hardware_type();
  public:

  // string ip_cam_username = 7 [json_name = "ipCamUsername"];
  void clear_ip_cam_username();
  const std::string& ip_cam_username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_cam_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_cam_username();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_ip_cam_username();
  void set_allocated_ip_cam_username(std::string* ip_cam_username);
  private:
  const std::string& _internal_ip_cam_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_cam_username(const std::string& value);
  std::string* _internal_mutable_ip_cam_username();
  public:

  // string ip_cam_password = 8 [json_name = "ipCamPassword"];
  void clear_ip_cam_password();
  const std::string& ip_cam_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip_cam_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip_cam_password();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_ip_cam_password();
  void set_allocated_ip_cam_password(std::string* ip_cam_password);
  private:
  const std::string& _internal_ip_cam_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip_cam_password(const std::string& value);
  std::string* _internal_mutable_ip_cam_password();
  public:

  // bool rtsp_encoding_needed = 5 [json_name = "rtspEncodingNeeded"];
  void clear_rtsp_encoding_needed();
  bool rtsp_encoding_needed() const;
  void set_rtsp_encoding_needed(bool value);
  private:
  bool _internal_rtsp_encoding_needed() const;
  void _internal_set_rtsp_encoding_needed(bool value);
  public:

  // bool is_onvif = 6 [json_name = "isOnvif"];
  void clear_is_onvif();
  bool is_onvif() const;
  void set_is_onvif(bool value);
  private:
  bool _internal_is_onvif() const;
  void _internal_set_is_onvif(bool value);
  public:

  // bool overlay_clock = 9 [json_name = "overlayClock"];
  void clear_overlay_clock();
  bool overlay_clock() const;
  void set_overlay_clock(bool value);
  private:
  bool _internal_overlay_clock() const;
  void _internal_set_overlay_clock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.Hardware)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hw_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr audio_hw_descriptor_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hardware_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_cam_username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_cam_password_;
  bool rtsp_encoding_needed_;
  bool is_onvif_;
  bool overlay_clock_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class DirectoryWatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.DirectoryWatch) */ {
 public:
  inline DirectoryWatch() : DirectoryWatch(nullptr) {}
  ~DirectoryWatch() override;
  explicit constexpr DirectoryWatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DirectoryWatch(const DirectoryWatch& from);
  DirectoryWatch(DirectoryWatch&& from) noexcept
    : DirectoryWatch() {
    *this = ::std::move(from);
  }

  inline DirectoryWatch& operator=(const DirectoryWatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline DirectoryWatch& operator=(DirectoryWatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DirectoryWatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const DirectoryWatch* internal_default_instance() {
    return reinterpret_cast<const DirectoryWatch*>(
               &_DirectoryWatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(DirectoryWatch& a, DirectoryWatch& b) {
    a.Swap(&b);
  }
  inline void Swap(DirectoryWatch* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DirectoryWatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DirectoryWatch* New() const final {
    return new DirectoryWatch();
  }

  DirectoryWatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DirectoryWatch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DirectoryWatch& from);
  void MergeFrom(const DirectoryWatch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectoryWatch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.DirectoryWatch";
  }
  protected:
  explicit DirectoryWatch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDirectoryFieldNumber = 1,
    kExtensionFieldNumber = 2,
    kFileTypeFieldNumber = 3,
    kRemoteAgentFieldNumber = 4,
  };
  // string directory = 1 [json_name = "directory"];
  void clear_directory();
  const std::string& directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_directory();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_directory();
  void set_allocated_directory(std::string* directory);
  private:
  const std::string& _internal_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_directory(const std::string& value);
  std::string* _internal_mutable_directory();
  public:

  // string extension = 2 [json_name = "extension"];
  void clear_extension();
  const std::string& extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_extension();
  void set_allocated_extension(std::string* extension);
  private:
  const std::string& _internal_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension(const std::string& value);
  std::string* _internal_mutable_extension();
  public:

  // .v1.model.FileType file_type = 3 [json_name = "fileType"];
  void clear_file_type();
  ::v1::model::FileType file_type() const;
  void set_file_type(::v1::model::FileType value);
  private:
  ::v1::model::FileType _internal_file_type() const;
  void _internal_set_file_type(::v1::model::FileType value);
  public:

  // bool remote_agent = 4 [json_name = "remoteAgent"];
  void clear_remote_agent();
  bool remote_agent() const;
  void set_remote_agent(bool value);
  private:
  bool _internal_remote_agent() const;
  void _internal_set_remote_agent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.DirectoryWatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_;
  int file_type_;
  bool remote_agent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class FileTail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.FileTail) */ {
 public:
  inline FileTail() : FileTail(nullptr) {}
  ~FileTail() override;
  explicit constexpr FileTail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileTail(const FileTail& from);
  FileTail(FileTail&& from) noexcept
    : FileTail() {
    *this = ::std::move(from);
  }

  inline FileTail& operator=(const FileTail& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileTail& operator=(FileTail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileTail& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileTail* internal_default_instance() {
    return reinterpret_cast<const FileTail*>(
               &_FileTail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(FileTail& a, FileTail& b) {
    a.Swap(&b);
  }
  inline void Swap(FileTail* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileTail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileTail* New() const final {
    return new FileTail();
  }

  FileTail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileTail>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FileTail& from);
  void MergeFrom(const FileTail& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileTail* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.FileTail";
  }
  protected:
  explicit FileTail(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kTimeKeyFieldNumber = 3,
    kTimeFormatFieldNumber = 4,
    kRegexFieldNumber = 5,
    kFileFormatFieldNumber = 2,
  };
  // string filename = 1 [json_name = "filename"];
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string time_key = 3 [json_name = "timeKey"];
  void clear_time_key();
  const std::string& time_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_time_key();
  void set_allocated_time_key(std::string* time_key);
  private:
  const std::string& _internal_time_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_key(const std::string& value);
  std::string* _internal_mutable_time_key();
  public:

  // string time_format = 4 [json_name = "timeFormat"];
  void clear_time_format();
  const std::string& time_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_format();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_time_format();
  void set_allocated_time_format(std::string* time_format);
  private:
  const std::string& _internal_time_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_format(const std::string& value);
  std::string* _internal_mutable_time_format();
  public:

  // string regex = 5 [json_name = "regex"];
  void clear_regex();
  const std::string& regex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regex();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_regex();
  void set_allocated_regex(std::string* regex);
  private:
  const std::string& _internal_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regex(const std::string& value);
  std::string* _internal_mutable_regex();
  public:

  // .v1.model.FileFormat file_format = 2 [json_name = "fileFormat"];
  void clear_file_format();
  ::v1::model::FileFormat file_format() const;
  void set_file_format(::v1::model::FileFormat value);
  private:
  ::v1::model::FileFormat _internal_file_format() const;
  void _internal_set_file_format(::v1::model::FileFormat value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.FileTail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regex_;
  int file_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// -------------------------------------------------------------------

class RtcInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.RtcInfo) */ {
 public:
  inline RtcInfo() : RtcInfo(nullptr) {}
  ~RtcInfo() override;
  explicit constexpr RtcInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RtcInfo(const RtcInfo& from);
  RtcInfo(RtcInfo&& from) noexcept
    : RtcInfo() {
    *this = ::std::move(from);
  }

  inline RtcInfo& operator=(const RtcInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RtcInfo& operator=(RtcInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RtcInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RtcInfo* internal_default_instance() {
    return reinterpret_cast<const RtcInfo*>(
               &_RtcInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(RtcInfo& a, RtcInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RtcInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RtcInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RtcInfo* New() const final {
    return new RtcInfo();
  }

  RtcInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RtcInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RtcInfo& from);
  void MergeFrom(const RtcInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RtcInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.RtcInfo";
  }
  protected:
  explicit RtcInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRtcIceTransportPoliciesFieldNumber = 1,
    kRtcIceServerProtocolFieldNumber = 2,
    kUseAllServersFieldNumber = 3,
  };
  // repeated string rtc_ice_transport_policies = 1 [json_name = "rtcIceTransportPolicies"];
  int rtc_ice_transport_policies_size() const;
  private:
  int _internal_rtc_ice_transport_policies_size() const;
  public:
  void clear_rtc_ice_transport_policies();
  const std::string& rtc_ice_transport_policies(int index) const;
  std::string* mutable_rtc_ice_transport_policies(int index);
  void set_rtc_ice_transport_policies(int index, const std::string& value);
  void set_rtc_ice_transport_policies(int index, std::string&& value);
  void set_rtc_ice_transport_policies(int index, const char* value);
  void set_rtc_ice_transport_policies(int index, const char* value, size_t size);
  std::string* add_rtc_ice_transport_policies();
  void add_rtc_ice_transport_policies(const std::string& value);
  void add_rtc_ice_transport_policies(std::string&& value);
  void add_rtc_ice_transport_policies(const char* value);
  void add_rtc_ice_transport_policies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& rtc_ice_transport_policies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_rtc_ice_transport_policies();
  private:
  const std::string& _internal_rtc_ice_transport_policies(int index) const;
  std::string* _internal_add_rtc_ice_transport_policies();
  public:

  // string rtc_ice_server_protocol = 2 [json_name = "rtcIceServerProtocol"];
  void clear_rtc_ice_server_protocol();
  const std::string& rtc_ice_server_protocol() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rtc_ice_server_protocol(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rtc_ice_server_protocol();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_rtc_ice_server_protocol();
  void set_allocated_rtc_ice_server_protocol(std::string* rtc_ice_server_protocol);
  private:
  const std::string& _internal_rtc_ice_server_protocol() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtc_ice_server_protocol(const std::string& value);
  std::string* _internal_mutable_rtc_ice_server_protocol();
  public:

  // bool use_all_servers = 3 [json_name = "useAllServers"];
  void clear_use_all_servers();
  bool use_all_servers() const;
  void set_use_all_servers(bool value);
  private:
  bool _internal_use_all_servers() const;
  void _internal_set_use_all_servers(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.RtcInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> rtc_ice_transport_policies_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rtc_ice_server_protocol_;
  bool use_all_servers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fconfig_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AgentConfigurationStore

// string agent_version = 1 [json_name = "agentVersion"];
inline void AgentConfigurationStore::clear_agent_version() {
  agent_version_.ClearToEmpty();
}
inline const std::string& AgentConfigurationStore::agent_version() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationStore.agent_version)
  return _internal_agent_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentConfigurationStore::set_agent_version(ArgT0&& arg0, ArgT... args) {
 
 agent_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentConfigurationStore.agent_version)
}
inline std::string* AgentConfigurationStore::mutable_agent_version() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationStore.agent_version)
  return _internal_mutable_agent_version();
}
inline const std::string& AgentConfigurationStore::_internal_agent_version() const {
  return agent_version_.Get();
}
inline void AgentConfigurationStore::_internal_set_agent_version(const std::string& value) {
  
  agent_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentConfigurationStore::_internal_mutable_agent_version() {
  
  return agent_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentConfigurationStore::release_agent_version() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationStore.agent_version)
  return agent_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentConfigurationStore::set_allocated_agent_version(std::string* agent_version) {
  if (agent_version != nullptr) {
    
  } else {
    
  }
  agent_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agent_version,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationStore.agent_version)
}

// .v1.model.AgentConfiguration configuration = 2 [json_name = "configuration"];
inline bool AgentConfigurationStore::_internal_has_configuration() const {
  return this != internal_default_instance() && configuration_ != nullptr;
}
inline bool AgentConfigurationStore::has_configuration() const {
  return _internal_has_configuration();
}
inline void AgentConfigurationStore::clear_configuration() {
  if (GetArenaForAllocation() == nullptr && configuration_ != nullptr) {
    delete configuration_;
  }
  configuration_ = nullptr;
}
inline const ::v1::model::AgentConfiguration& AgentConfigurationStore::_internal_configuration() const {
  const ::v1::model::AgentConfiguration* p = configuration_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::AgentConfiguration&>(
      ::v1::model::_AgentConfiguration_default_instance_);
}
inline const ::v1::model::AgentConfiguration& AgentConfigurationStore::configuration() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationStore.configuration)
  return _internal_configuration();
}
inline void AgentConfigurationStore::unsafe_arena_set_allocated_configuration(
    ::v1::model::AgentConfiguration* configuration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(configuration_);
  }
  configuration_ = configuration;
  if (configuration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationStore.configuration)
}
inline ::v1::model::AgentConfiguration* AgentConfigurationStore::release_configuration() {
  
  ::v1::model::AgentConfiguration* temp = configuration_;
  configuration_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::AgentConfiguration* AgentConfigurationStore::unsafe_arena_release_configuration() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationStore.configuration)
  
  ::v1::model::AgentConfiguration* temp = configuration_;
  configuration_ = nullptr;
  return temp;
}
inline ::v1::model::AgentConfiguration* AgentConfigurationStore::_internal_mutable_configuration() {
  
  if (configuration_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::AgentConfiguration>(GetArenaForAllocation());
    configuration_ = p;
  }
  return configuration_;
}
inline ::v1::model::AgentConfiguration* AgentConfigurationStore::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationStore.configuration)
  return _internal_mutable_configuration();
}
inline void AgentConfigurationStore::set_allocated_configuration(::v1::model::AgentConfiguration* configuration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete configuration_;
  }
  if (configuration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::AgentConfiguration>::GetOwningArena(configuration);
    if (message_arena != submessage_arena) {
      configuration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, configuration, submessage_arena);
    }
    
  } else {
    
  }
  configuration_ = configuration;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationStore.configuration)
}

// .v1.model.AgentFeatureSet feature_set = 3 [json_name = "featureSet"];
inline bool AgentConfigurationStore::_internal_has_feature_set() const {
  return this != internal_default_instance() && feature_set_ != nullptr;
}
inline bool AgentConfigurationStore::has_feature_set() const {
  return _internal_has_feature_set();
}
inline void AgentConfigurationStore::clear_feature_set() {
  if (GetArenaForAllocation() == nullptr && feature_set_ != nullptr) {
    delete feature_set_;
  }
  feature_set_ = nullptr;
}
inline const ::v1::model::AgentFeatureSet& AgentConfigurationStore::_internal_feature_set() const {
  const ::v1::model::AgentFeatureSet* p = feature_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::AgentFeatureSet&>(
      ::v1::model::_AgentFeatureSet_default_instance_);
}
inline const ::v1::model::AgentFeatureSet& AgentConfigurationStore::feature_set() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationStore.feature_set)
  return _internal_feature_set();
}
inline void AgentConfigurationStore::unsafe_arena_set_allocated_feature_set(
    ::v1::model::AgentFeatureSet* feature_set) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_set_);
  }
  feature_set_ = feature_set;
  if (feature_set) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationStore.feature_set)
}
inline ::v1::model::AgentFeatureSet* AgentConfigurationStore::release_feature_set() {
  
  ::v1::model::AgentFeatureSet* temp = feature_set_;
  feature_set_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::AgentFeatureSet* AgentConfigurationStore::unsafe_arena_release_feature_set() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationStore.feature_set)
  
  ::v1::model::AgentFeatureSet* temp = feature_set_;
  feature_set_ = nullptr;
  return temp;
}
inline ::v1::model::AgentFeatureSet* AgentConfigurationStore::_internal_mutable_feature_set() {
  
  if (feature_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::AgentFeatureSet>(GetArenaForAllocation());
    feature_set_ = p;
  }
  return feature_set_;
}
inline ::v1::model::AgentFeatureSet* AgentConfigurationStore::mutable_feature_set() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationStore.feature_set)
  return _internal_mutable_feature_set();
}
inline void AgentConfigurationStore::set_allocated_feature_set(::v1::model::AgentFeatureSet* feature_set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete feature_set_;
  }
  if (feature_set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::AgentFeatureSet>::GetOwningArena(feature_set);
    if (message_arena != submessage_arena) {
      feature_set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_set, submessage_arena);
    }
    
  } else {
    
  }
  feature_set_ = feature_set;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationStore.feature_set)
}

// -------------------------------------------------------------------

// AgentFeatureSet

// bool telemetry = 1 [json_name = "telemetry"];
inline void AgentFeatureSet::clear_telemetry() {
  telemetry_ = false;
}
inline bool AgentFeatureSet::_internal_telemetry() const {
  return telemetry_;
}
inline bool AgentFeatureSet::telemetry() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.telemetry)
  return _internal_telemetry();
}
inline void AgentFeatureSet::_internal_set_telemetry(bool value) {
  
  telemetry_ = value;
}
inline void AgentFeatureSet::set_telemetry(bool value) {
  _internal_set_telemetry(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.telemetry)
}

// bool internal_telemetry = 2 [json_name = "internalTelemetry"];
inline void AgentFeatureSet::clear_internal_telemetry() {
  internal_telemetry_ = false;
}
inline bool AgentFeatureSet::_internal_internal_telemetry() const {
  return internal_telemetry_;
}
inline bool AgentFeatureSet::internal_telemetry() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.internal_telemetry)
  return _internal_internal_telemetry();
}
inline void AgentFeatureSet::_internal_set_internal_telemetry(bool value) {
  
  internal_telemetry_ = value;
}
inline void AgentFeatureSet::set_internal_telemetry(bool value) {
  _internal_set_internal_telemetry(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.internal_telemetry)
}

// bool teleop = 3 [json_name = "teleop"];
inline void AgentFeatureSet::clear_teleop() {
  teleop_ = false;
}
inline bool AgentFeatureSet::_internal_teleop() const {
  return teleop_;
}
inline bool AgentFeatureSet::teleop() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.teleop)
  return _internal_teleop();
}
inline void AgentFeatureSet::_internal_set_teleop(bool value) {
  
  teleop_ = value;
}
inline void AgentFeatureSet::set_teleop(bool value) {
  _internal_set_teleop(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.teleop)
}

// bool custom_events = 4 [json_name = "customEvents"];
inline void AgentFeatureSet::clear_custom_events() {
  custom_events_ = false;
}
inline bool AgentFeatureSet::_internal_custom_events() const {
  return custom_events_;
}
inline bool AgentFeatureSet::custom_events() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.custom_events)
  return _internal_custom_events();
}
inline void AgentFeatureSet::_internal_set_custom_events(bool value) {
  
  custom_events_ = value;
}
inline void AgentFeatureSet::set_custom_events(bool value) {
  _internal_set_custom_events(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.custom_events)
}

// bool triggered_events = 5 [json_name = "triggeredEvents"];
inline void AgentFeatureSet::clear_triggered_events() {
  triggered_events_ = false;
}
inline bool AgentFeatureSet::_internal_triggered_events() const {
  return triggered_events_;
}
inline bool AgentFeatureSet::triggered_events() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.triggered_events)
  return _internal_triggered_events();
}
inline void AgentFeatureSet::_internal_set_triggered_events(bool value) {
  
  triggered_events_ = value;
}
inline void AgentFeatureSet::set_triggered_events(bool value) {
  _internal_set_triggered_events(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.triggered_events)
}

// bool ssh = 6 [json_name = "ssh"];
inline void AgentFeatureSet::clear_ssh() {
  ssh_ = false;
}
inline bool AgentFeatureSet::_internal_ssh() const {
  return ssh_;
}
inline bool AgentFeatureSet::ssh() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.ssh)
  return _internal_ssh();
}
inline void AgentFeatureSet::_internal_set_ssh(bool value) {
  
  ssh_ = value;
}
inline void AgentFeatureSet::set_ssh(bool value) {
  _internal_set_ssh(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.ssh)
}

// bool port_forwarding = 7 [json_name = "portForwarding"];
inline void AgentFeatureSet::clear_port_forwarding() {
  port_forwarding_ = false;
}
inline bool AgentFeatureSet::_internal_port_forwarding() const {
  return port_forwarding_;
}
inline bool AgentFeatureSet::port_forwarding() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.port_forwarding)
  return _internal_port_forwarding();
}
inline void AgentFeatureSet::_internal_set_port_forwarding(bool value) {
  
  port_forwarding_ = value;
}
inline void AgentFeatureSet::set_port_forwarding(bool value) {
  _internal_set_port_forwarding(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.port_forwarding)
}

// bool commands = 8 [json_name = "commands"];
inline void AgentFeatureSet::clear_commands() {
  commands_ = false;
}
inline bool AgentFeatureSet::_internal_commands() const {
  return commands_;
}
inline bool AgentFeatureSet::commands() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.commands)
  return _internal_commands();
}
inline void AgentFeatureSet::_internal_set_commands(bool value) {
  
  commands_ = value;
}
inline void AgentFeatureSet::set_commands(bool value) {
  _internal_set_commands(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.commands)
}

// bool interventions = 9 [json_name = "interventions"];
inline void AgentFeatureSet::clear_interventions() {
  interventions_ = false;
}
inline bool AgentFeatureSet::_internal_interventions() const {
  return interventions_;
}
inline bool AgentFeatureSet::interventions() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.interventions)
  return _internal_interventions();
}
inline void AgentFeatureSet::_internal_set_interventions(bool value) {
  
  interventions_ = value;
}
inline void AgentFeatureSet::set_interventions(bool value) {
  _internal_set_interventions(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.interventions)
}

// bool on_demand = 10 [json_name = "onDemand"];
inline void AgentFeatureSet::clear_on_demand() {
  on_demand_ = false;
}
inline bool AgentFeatureSet::_internal_on_demand() const {
  return on_demand_;
}
inline bool AgentFeatureSet::on_demand() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.on_demand)
  return _internal_on_demand();
}
inline void AgentFeatureSet::_internal_set_on_demand(bool value) {
  
  on_demand_ = value;
}
inline void AgentFeatureSet::set_on_demand(bool value) {
  _internal_set_on_demand(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.on_demand)
}

// bool app_config = 11 [json_name = "appConfig"];
inline void AgentFeatureSet::clear_app_config() {
  app_config_ = false;
}
inline bool AgentFeatureSet::_internal_app_config() const {
  return app_config_;
}
inline bool AgentFeatureSet::app_config() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.app_config)
  return _internal_app_config();
}
inline void AgentFeatureSet::_internal_set_app_config(bool value) {
  
  app_config_ = value;
}
inline void AgentFeatureSet::set_app_config(bool value) {
  _internal_set_app_config(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.app_config)
}

// bool blob_storage = 12 [json_name = "blobStorage"];
inline void AgentFeatureSet::clear_blob_storage() {
  blob_storage_ = false;
}
inline bool AgentFeatureSet::_internal_blob_storage() const {
  return blob_storage_;
}
inline bool AgentFeatureSet::blob_storage() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentFeatureSet.blob_storage)
  return _internal_blob_storage();
}
inline void AgentFeatureSet::_internal_set_blob_storage(bool value) {
  
  blob_storage_ = value;
}
inline void AgentFeatureSet::set_blob_storage(bool value) {
  _internal_set_blob_storage(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentFeatureSet.blob_storage)
}

// -------------------------------------------------------------------

// AgentConfiguration

// string id = 1 [json_name = "id"];
inline void AgentConfiguration::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& AgentConfiguration::id() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfiguration.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentConfiguration::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentConfiguration.id)
}
inline std::string* AgentConfiguration::mutable_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfiguration.id)
  return _internal_mutable_id();
}
inline const std::string& AgentConfiguration::_internal_id() const {
  return id_.Get();
}
inline void AgentConfiguration::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentConfiguration::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentConfiguration::release_id() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfiguration.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentConfiguration::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfiguration.id)
}

// string name = 2 [json_name = "name"];
inline void AgentConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AgentConfiguration::name() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfiguration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentConfiguration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentConfiguration.name)
}
inline std::string* AgentConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& AgentConfiguration::_internal_name() const {
  return name_.Get();
}
inline void AgentConfiguration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentConfiguration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfiguration.name)
}

// .v1.model.AgentConfigurationDocument document = 3 [json_name = "document"];
inline bool AgentConfiguration::_internal_has_document() const {
  return this != internal_default_instance() && document_ != nullptr;
}
inline bool AgentConfiguration::has_document() const {
  return _internal_has_document();
}
inline void AgentConfiguration::clear_document() {
  if (GetArenaForAllocation() == nullptr && document_ != nullptr) {
    delete document_;
  }
  document_ = nullptr;
}
inline const ::v1::model::AgentConfigurationDocument& AgentConfiguration::_internal_document() const {
  const ::v1::model::AgentConfigurationDocument* p = document_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::AgentConfigurationDocument&>(
      ::v1::model::_AgentConfigurationDocument_default_instance_);
}
inline const ::v1::model::AgentConfigurationDocument& AgentConfiguration::document() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfiguration.document)
  return _internal_document();
}
inline void AgentConfiguration::unsafe_arena_set_allocated_document(
    ::v1::model::AgentConfigurationDocument* document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(document_);
  }
  document_ = document;
  if (document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfiguration.document)
}
inline ::v1::model::AgentConfigurationDocument* AgentConfiguration::release_document() {
  
  ::v1::model::AgentConfigurationDocument* temp = document_;
  document_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::AgentConfigurationDocument* AgentConfiguration::unsafe_arena_release_document() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfiguration.document)
  
  ::v1::model::AgentConfigurationDocument* temp = document_;
  document_ = nullptr;
  return temp;
}
inline ::v1::model::AgentConfigurationDocument* AgentConfiguration::_internal_mutable_document() {
  
  if (document_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::AgentConfigurationDocument>(GetArenaForAllocation());
    document_ = p;
  }
  return document_;
}
inline ::v1::model::AgentConfigurationDocument* AgentConfiguration::mutable_document() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfiguration.document)
  return _internal_mutable_document();
}
inline void AgentConfiguration::set_allocated_document(::v1::model::AgentConfigurationDocument* document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete document_;
  }
  if (document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::AgentConfigurationDocument>::GetOwningArena(document);
    if (message_arena != submessage_arena) {
      document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, document, submessage_arena);
    }
    
  } else {
    
  }
  document_ = document;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfiguration.document)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AgentConfigurationDocument

// int64 version = 1 [json_name = "version"];
inline void AgentConfigurationDocument::clear_version() {
  version_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AgentConfigurationDocument::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AgentConfigurationDocument::version() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.version)
  return _internal_version();
}
inline void AgentConfigurationDocument::_internal_set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  version_ = value;
}
inline void AgentConfigurationDocument::set_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentConfigurationDocument.version)
}

// map<string, string> tags = 2 [json_name = "tags"];
inline int AgentConfigurationDocument::_internal_tags_size() const {
  return tags_.size();
}
inline int AgentConfigurationDocument::tags_size() const {
  return _internal_tags_size();
}
inline void AgentConfigurationDocument::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AgentConfigurationDocument::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AgentConfigurationDocument::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.AgentConfigurationDocument.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AgentConfigurationDocument::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AgentConfigurationDocument::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.AgentConfigurationDocument.tags)
  return _internal_mutable_tags();
}

// .v1.model.TelemetryConfiguration telemetry = 3 [json_name = "telemetry"];
inline bool AgentConfigurationDocument::_internal_has_telemetry() const {
  return this != internal_default_instance() && telemetry_ != nullptr;
}
inline bool AgentConfigurationDocument::has_telemetry() const {
  return _internal_has_telemetry();
}
inline void AgentConfigurationDocument::clear_telemetry() {
  if (GetArenaForAllocation() == nullptr && telemetry_ != nullptr) {
    delete telemetry_;
  }
  telemetry_ = nullptr;
}
inline const ::v1::model::TelemetryConfiguration& AgentConfigurationDocument::_internal_telemetry() const {
  const ::v1::model::TelemetryConfiguration* p = telemetry_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::TelemetryConfiguration&>(
      ::v1::model::_TelemetryConfiguration_default_instance_);
}
inline const ::v1::model::TelemetryConfiguration& AgentConfigurationDocument::telemetry() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.telemetry)
  return _internal_telemetry();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_telemetry(
    ::v1::model::TelemetryConfiguration* telemetry) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(telemetry_);
  }
  telemetry_ = telemetry;
  if (telemetry) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.telemetry)
}
inline ::v1::model::TelemetryConfiguration* AgentConfigurationDocument::release_telemetry() {
  
  ::v1::model::TelemetryConfiguration* temp = telemetry_;
  telemetry_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::TelemetryConfiguration* AgentConfigurationDocument::unsafe_arena_release_telemetry() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.telemetry)
  
  ::v1::model::TelemetryConfiguration* temp = telemetry_;
  telemetry_ = nullptr;
  return temp;
}
inline ::v1::model::TelemetryConfiguration* AgentConfigurationDocument::_internal_mutable_telemetry() {
  
  if (telemetry_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::TelemetryConfiguration>(GetArenaForAllocation());
    telemetry_ = p;
  }
  return telemetry_;
}
inline ::v1::model::TelemetryConfiguration* AgentConfigurationDocument::mutable_telemetry() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.telemetry)
  return _internal_mutable_telemetry();
}
inline void AgentConfigurationDocument::set_allocated_telemetry(::v1::model::TelemetryConfiguration* telemetry) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete telemetry_;
  }
  if (telemetry) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::TelemetryConfiguration>::GetOwningArena(telemetry);
    if (message_arena != submessage_arena) {
      telemetry = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, telemetry, submessage_arena);
    }
    
  } else {
    
  }
  telemetry_ = telemetry;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.telemetry)
}

// .v1.model.ResourcesConfiguration resources = 4 [json_name = "resources"];
inline bool AgentConfigurationDocument::_internal_has_resources() const {
  return this != internal_default_instance() && resources_ != nullptr;
}
inline bool AgentConfigurationDocument::has_resources() const {
  return _internal_has_resources();
}
inline void AgentConfigurationDocument::clear_resources() {
  if (GetArenaForAllocation() == nullptr && resources_ != nullptr) {
    delete resources_;
  }
  resources_ = nullptr;
}
inline const ::v1::model::ResourcesConfiguration& AgentConfigurationDocument::_internal_resources() const {
  const ::v1::model::ResourcesConfiguration* p = resources_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::ResourcesConfiguration&>(
      ::v1::model::_ResourcesConfiguration_default_instance_);
}
inline const ::v1::model::ResourcesConfiguration& AgentConfigurationDocument::resources() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.resources)
  return _internal_resources();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_resources(
    ::v1::model::ResourcesConfiguration* resources) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(resources_);
  }
  resources_ = resources;
  if (resources) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.resources)
}
inline ::v1::model::ResourcesConfiguration* AgentConfigurationDocument::release_resources() {
  
  ::v1::model::ResourcesConfiguration* temp = resources_;
  resources_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::ResourcesConfiguration* AgentConfigurationDocument::unsafe_arena_release_resources() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.resources)
  
  ::v1::model::ResourcesConfiguration* temp = resources_;
  resources_ = nullptr;
  return temp;
}
inline ::v1::model::ResourcesConfiguration* AgentConfigurationDocument::_internal_mutable_resources() {
  
  if (resources_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::ResourcesConfiguration>(GetArenaForAllocation());
    resources_ = p;
  }
  return resources_;
}
inline ::v1::model::ResourcesConfiguration* AgentConfigurationDocument::mutable_resources() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.resources)
  return _internal_mutable_resources();
}
inline void AgentConfigurationDocument::set_allocated_resources(::v1::model::ResourcesConfiguration* resources) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete resources_;
  }
  if (resources) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::ResourcesConfiguration>::GetOwningArena(resources);
    if (message_arena != submessage_arena) {
      resources = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, resources, submessage_arena);
    }
    
  } else {
    
  }
  resources_ = resources;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.resources)
}

// .v1.model.ApplicationConfiguration application = 5 [json_name = "application"];
inline bool AgentConfigurationDocument::_internal_has_application() const {
  return this != internal_default_instance() && application_ != nullptr;
}
inline bool AgentConfigurationDocument::has_application() const {
  return _internal_has_application();
}
inline void AgentConfigurationDocument::clear_application() {
  if (GetArenaForAllocation() == nullptr && application_ != nullptr) {
    delete application_;
  }
  application_ = nullptr;
}
inline const ::v1::model::ApplicationConfiguration& AgentConfigurationDocument::_internal_application() const {
  const ::v1::model::ApplicationConfiguration* p = application_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::ApplicationConfiguration&>(
      ::v1::model::_ApplicationConfiguration_default_instance_);
}
inline const ::v1::model::ApplicationConfiguration& AgentConfigurationDocument::application() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.application)
  return _internal_application();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_application(
    ::v1::model::ApplicationConfiguration* application) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(application_);
  }
  application_ = application;
  if (application) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.application)
}
inline ::v1::model::ApplicationConfiguration* AgentConfigurationDocument::release_application() {
  
  ::v1::model::ApplicationConfiguration* temp = application_;
  application_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::ApplicationConfiguration* AgentConfigurationDocument::unsafe_arena_release_application() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.application)
  
  ::v1::model::ApplicationConfiguration* temp = application_;
  application_ = nullptr;
  return temp;
}
inline ::v1::model::ApplicationConfiguration* AgentConfigurationDocument::_internal_mutable_application() {
  
  if (application_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::ApplicationConfiguration>(GetArenaForAllocation());
    application_ = p;
  }
  return application_;
}
inline ::v1::model::ApplicationConfiguration* AgentConfigurationDocument::mutable_application() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.application)
  return _internal_mutable_application();
}
inline void AgentConfigurationDocument::set_allocated_application(::v1::model::ApplicationConfiguration* application) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete application_;
  }
  if (application) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::ApplicationConfiguration>::GetOwningArena(application);
    if (message_arena != submessage_arena) {
      application = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, application, submessage_arena);
    }
    
  } else {
    
  }
  application_ = application;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.application)
}

// .v1.model.TeleopConfiguration teleop = 6 [json_name = "teleop"];
inline bool AgentConfigurationDocument::_internal_has_teleop() const {
  return this != internal_default_instance() && teleop_ != nullptr;
}
inline bool AgentConfigurationDocument::has_teleop() const {
  return _internal_has_teleop();
}
inline void AgentConfigurationDocument::clear_teleop() {
  if (GetArenaForAllocation() == nullptr && teleop_ != nullptr) {
    delete teleop_;
  }
  teleop_ = nullptr;
}
inline const ::v1::model::TeleopConfiguration& AgentConfigurationDocument::_internal_teleop() const {
  const ::v1::model::TeleopConfiguration* p = teleop_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::TeleopConfiguration&>(
      ::v1::model::_TeleopConfiguration_default_instance_);
}
inline const ::v1::model::TeleopConfiguration& AgentConfigurationDocument::teleop() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.teleop)
  return _internal_teleop();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_teleop(
    ::v1::model::TeleopConfiguration* teleop) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(teleop_);
  }
  teleop_ = teleop;
  if (teleop) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.teleop)
}
inline ::v1::model::TeleopConfiguration* AgentConfigurationDocument::release_teleop() {
  
  ::v1::model::TeleopConfiguration* temp = teleop_;
  teleop_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::TeleopConfiguration* AgentConfigurationDocument::unsafe_arena_release_teleop() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.teleop)
  
  ::v1::model::TeleopConfiguration* temp = teleop_;
  teleop_ = nullptr;
  return temp;
}
inline ::v1::model::TeleopConfiguration* AgentConfigurationDocument::_internal_mutable_teleop() {
  
  if (teleop_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::TeleopConfiguration>(GetArenaForAllocation());
    teleop_ = p;
  }
  return teleop_;
}
inline ::v1::model::TeleopConfiguration* AgentConfigurationDocument::mutable_teleop() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.teleop)
  return _internal_mutable_teleop();
}
inline void AgentConfigurationDocument::set_allocated_teleop(::v1::model::TeleopConfiguration* teleop) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete teleop_;
  }
  if (teleop) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::TeleopConfiguration>::GetOwningArena(teleop);
    if (message_arena != submessage_arena) {
      teleop = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, teleop, submessage_arena);
    }
    
  } else {
    
  }
  teleop_ = teleop;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.teleop)
}

// .v1.model.PortForwardingConfiguration port_forwarding = 7 [json_name = "portForwarding"];
inline bool AgentConfigurationDocument::_internal_has_port_forwarding() const {
  return this != internal_default_instance() && port_forwarding_ != nullptr;
}
inline bool AgentConfigurationDocument::has_port_forwarding() const {
  return _internal_has_port_forwarding();
}
inline void AgentConfigurationDocument::clear_port_forwarding() {
  if (GetArenaForAllocation() == nullptr && port_forwarding_ != nullptr) {
    delete port_forwarding_;
  }
  port_forwarding_ = nullptr;
}
inline const ::v1::model::PortForwardingConfiguration& AgentConfigurationDocument::_internal_port_forwarding() const {
  const ::v1::model::PortForwardingConfiguration* p = port_forwarding_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::PortForwardingConfiguration&>(
      ::v1::model::_PortForwardingConfiguration_default_instance_);
}
inline const ::v1::model::PortForwardingConfiguration& AgentConfigurationDocument::port_forwarding() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.port_forwarding)
  return _internal_port_forwarding();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_port_forwarding(
    ::v1::model::PortForwardingConfiguration* port_forwarding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(port_forwarding_);
  }
  port_forwarding_ = port_forwarding;
  if (port_forwarding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.port_forwarding)
}
inline ::v1::model::PortForwardingConfiguration* AgentConfigurationDocument::release_port_forwarding() {
  
  ::v1::model::PortForwardingConfiguration* temp = port_forwarding_;
  port_forwarding_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::PortForwardingConfiguration* AgentConfigurationDocument::unsafe_arena_release_port_forwarding() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.port_forwarding)
  
  ::v1::model::PortForwardingConfiguration* temp = port_forwarding_;
  port_forwarding_ = nullptr;
  return temp;
}
inline ::v1::model::PortForwardingConfiguration* AgentConfigurationDocument::_internal_mutable_port_forwarding() {
  
  if (port_forwarding_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::PortForwardingConfiguration>(GetArenaForAllocation());
    port_forwarding_ = p;
  }
  return port_forwarding_;
}
inline ::v1::model::PortForwardingConfiguration* AgentConfigurationDocument::mutable_port_forwarding() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.port_forwarding)
  return _internal_mutable_port_forwarding();
}
inline void AgentConfigurationDocument::set_allocated_port_forwarding(::v1::model::PortForwardingConfiguration* port_forwarding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete port_forwarding_;
  }
  if (port_forwarding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::PortForwardingConfiguration>::GetOwningArena(port_forwarding);
    if (message_arena != submessage_arena) {
      port_forwarding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, port_forwarding, submessage_arena);
    }
    
  } else {
    
  }
  port_forwarding_ = port_forwarding;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.port_forwarding)
}

// .v1.model.BlobData blob_data = 8 [json_name = "blobData"];
inline bool AgentConfigurationDocument::_internal_has_blob_data() const {
  return this != internal_default_instance() && blob_data_ != nullptr;
}
inline bool AgentConfigurationDocument::has_blob_data() const {
  return _internal_has_blob_data();
}
inline void AgentConfigurationDocument::clear_blob_data() {
  if (GetArenaForAllocation() == nullptr && blob_data_ != nullptr) {
    delete blob_data_;
  }
  blob_data_ = nullptr;
}
inline const ::v1::model::BlobData& AgentConfigurationDocument::_internal_blob_data() const {
  const ::v1::model::BlobData* p = blob_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::BlobData&>(
      ::v1::model::_BlobData_default_instance_);
}
inline const ::v1::model::BlobData& AgentConfigurationDocument::blob_data() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.blob_data)
  return _internal_blob_data();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_blob_data(
    ::v1::model::BlobData* blob_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blob_data_);
  }
  blob_data_ = blob_data;
  if (blob_data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.blob_data)
}
inline ::v1::model::BlobData* AgentConfigurationDocument::release_blob_data() {
  
  ::v1::model::BlobData* temp = blob_data_;
  blob_data_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::BlobData* AgentConfigurationDocument::unsafe_arena_release_blob_data() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.blob_data)
  
  ::v1::model::BlobData* temp = blob_data_;
  blob_data_ = nullptr;
  return temp;
}
inline ::v1::model::BlobData* AgentConfigurationDocument::_internal_mutable_blob_data() {
  
  if (blob_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::BlobData>(GetArenaForAllocation());
    blob_data_ = p;
  }
  return blob_data_;
}
inline ::v1::model::BlobData* AgentConfigurationDocument::mutable_blob_data() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.blob_data)
  return _internal_mutable_blob_data();
}
inline void AgentConfigurationDocument::set_allocated_blob_data(::v1::model::BlobData* blob_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete blob_data_;
  }
  if (blob_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::BlobData>::GetOwningArena(blob_data);
    if (message_arena != submessage_arena) {
      blob_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blob_data, submessage_arena);
    }
    
  } else {
    
  }
  blob_data_ = blob_data;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.blob_data)
}

// .v1.model.Diagnostics diagnostics = 9 [json_name = "diagnostics"];
inline bool AgentConfigurationDocument::_internal_has_diagnostics() const {
  return this != internal_default_instance() && diagnostics_ != nullptr;
}
inline bool AgentConfigurationDocument::has_diagnostics() const {
  return _internal_has_diagnostics();
}
inline void AgentConfigurationDocument::clear_diagnostics() {
  if (GetArenaForAllocation() == nullptr && diagnostics_ != nullptr) {
    delete diagnostics_;
  }
  diagnostics_ = nullptr;
}
inline const ::v1::model::Diagnostics& AgentConfigurationDocument::_internal_diagnostics() const {
  const ::v1::model::Diagnostics* p = diagnostics_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::Diagnostics&>(
      ::v1::model::_Diagnostics_default_instance_);
}
inline const ::v1::model::Diagnostics& AgentConfigurationDocument::diagnostics() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.diagnostics)
  return _internal_diagnostics();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_diagnostics(
    ::v1::model::Diagnostics* diagnostics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(diagnostics_);
  }
  diagnostics_ = diagnostics;
  if (diagnostics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.diagnostics)
}
inline ::v1::model::Diagnostics* AgentConfigurationDocument::release_diagnostics() {
  
  ::v1::model::Diagnostics* temp = diagnostics_;
  diagnostics_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::Diagnostics* AgentConfigurationDocument::unsafe_arena_release_diagnostics() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.diagnostics)
  
  ::v1::model::Diagnostics* temp = diagnostics_;
  diagnostics_ = nullptr;
  return temp;
}
inline ::v1::model::Diagnostics* AgentConfigurationDocument::_internal_mutable_diagnostics() {
  
  if (diagnostics_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::Diagnostics>(GetArenaForAllocation());
    diagnostics_ = p;
  }
  return diagnostics_;
}
inline ::v1::model::Diagnostics* AgentConfigurationDocument::mutable_diagnostics() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.diagnostics)
  return _internal_mutable_diagnostics();
}
inline void AgentConfigurationDocument::set_allocated_diagnostics(::v1::model::Diagnostics* diagnostics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete diagnostics_;
  }
  if (diagnostics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::Diagnostics>::GetOwningArena(diagnostics);
    if (message_arena != submessage_arena) {
      diagnostics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, diagnostics, submessage_arena);
    }
    
  } else {
    
  }
  diagnostics_ = diagnostics;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.diagnostics)
}

// .google.protobuf.BoolValue terminal_access = 10 [json_name = "terminalAccess"];
inline bool AgentConfigurationDocument::_internal_has_terminal_access() const {
  return this != internal_default_instance() && terminal_access_ != nullptr;
}
inline bool AgentConfigurationDocument::has_terminal_access() const {
  return _internal_has_terminal_access();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& AgentConfigurationDocument::_internal_terminal_access() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = terminal_access_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& AgentConfigurationDocument::terminal_access() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.terminal_access)
  return _internal_terminal_access();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_terminal_access(
    PROTOBUF_NAMESPACE_ID::BoolValue* terminal_access) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(terminal_access_);
  }
  terminal_access_ = terminal_access;
  if (terminal_access) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.terminal_access)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* AgentConfigurationDocument::release_terminal_access() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = terminal_access_;
  terminal_access_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* AgentConfigurationDocument::unsafe_arena_release_terminal_access() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.terminal_access)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = terminal_access_;
  terminal_access_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* AgentConfigurationDocument::_internal_mutable_terminal_access() {
  
  if (terminal_access_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    terminal_access_ = p;
  }
  return terminal_access_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* AgentConfigurationDocument::mutable_terminal_access() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.terminal_access)
  return _internal_mutable_terminal_access();
}
inline void AgentConfigurationDocument::set_allocated_terminal_access(PROTOBUF_NAMESPACE_ID::BoolValue* terminal_access) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(terminal_access_);
  }
  if (terminal_access) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(terminal_access));
    if (message_arena != submessage_arena) {
      terminal_access = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, terminal_access, submessage_arena);
    }
    
  } else {
    
  }
  terminal_access_ = terminal_access;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.terminal_access)
}

// repeated .v1.model.AdapterConfiguration adapters = 11 [json_name = "adapters"];
inline int AgentConfigurationDocument::_internal_adapters_size() const {
  return adapters_.size();
}
inline int AgentConfigurationDocument::adapters_size() const {
  return _internal_adapters_size();
}
inline void AgentConfigurationDocument::clear_adapters() {
  adapters_.Clear();
}
inline ::v1::model::AdapterConfiguration* AgentConfigurationDocument::mutable_adapters(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.adapters)
  return adapters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AdapterConfiguration >*
AgentConfigurationDocument::mutable_adapters() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.AgentConfigurationDocument.adapters)
  return &adapters_;
}
inline const ::v1::model::AdapterConfiguration& AgentConfigurationDocument::_internal_adapters(int index) const {
  return adapters_.Get(index);
}
inline const ::v1::model::AdapterConfiguration& AgentConfigurationDocument::adapters(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.adapters)
  return _internal_adapters(index);
}
inline ::v1::model::AdapterConfiguration* AgentConfigurationDocument::_internal_add_adapters() {
  return adapters_.Add();
}
inline ::v1::model::AdapterConfiguration* AgentConfigurationDocument::add_adapters() {
  // @@protoc_insertion_point(field_add:v1.model.AgentConfigurationDocument.adapters)
  return _internal_add_adapters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AdapterConfiguration >&
AgentConfigurationDocument::adapters() const {
  // @@protoc_insertion_point(field_list:v1.model.AgentConfigurationDocument.adapters)
  return adapters_;
}

// .v1.model.RtcInfo rtc_info = 12 [json_name = "rtcInfo"];
inline bool AgentConfigurationDocument::_internal_has_rtc_info() const {
  return this != internal_default_instance() && rtc_info_ != nullptr;
}
inline bool AgentConfigurationDocument::has_rtc_info() const {
  return _internal_has_rtc_info();
}
inline void AgentConfigurationDocument::clear_rtc_info() {
  if (GetArenaForAllocation() == nullptr && rtc_info_ != nullptr) {
    delete rtc_info_;
  }
  rtc_info_ = nullptr;
}
inline const ::v1::model::RtcInfo& AgentConfigurationDocument::_internal_rtc_info() const {
  const ::v1::model::RtcInfo* p = rtc_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::RtcInfo&>(
      ::v1::model::_RtcInfo_default_instance_);
}
inline const ::v1::model::RtcInfo& AgentConfigurationDocument::rtc_info() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentConfigurationDocument.rtc_info)
  return _internal_rtc_info();
}
inline void AgentConfigurationDocument::unsafe_arena_set_allocated_rtc_info(
    ::v1::model::RtcInfo* rtc_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rtc_info_);
  }
  rtc_info_ = rtc_info;
  if (rtc_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentConfigurationDocument.rtc_info)
}
inline ::v1::model::RtcInfo* AgentConfigurationDocument::release_rtc_info() {
  
  ::v1::model::RtcInfo* temp = rtc_info_;
  rtc_info_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::RtcInfo* AgentConfigurationDocument::unsafe_arena_release_rtc_info() {
  // @@protoc_insertion_point(field_release:v1.model.AgentConfigurationDocument.rtc_info)
  
  ::v1::model::RtcInfo* temp = rtc_info_;
  rtc_info_ = nullptr;
  return temp;
}
inline ::v1::model::RtcInfo* AgentConfigurationDocument::_internal_mutable_rtc_info() {
  
  if (rtc_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::RtcInfo>(GetArenaForAllocation());
    rtc_info_ = p;
  }
  return rtc_info_;
}
inline ::v1::model::RtcInfo* AgentConfigurationDocument::mutable_rtc_info() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentConfigurationDocument.rtc_info)
  return _internal_mutable_rtc_info();
}
inline void AgentConfigurationDocument::set_allocated_rtc_info(::v1::model::RtcInfo* rtc_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rtc_info_;
  }
  if (rtc_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::RtcInfo>::GetOwningArena(rtc_info);
    if (message_arena != submessage_arena) {
      rtc_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rtc_info, submessage_arena);
    }
    
  } else {
    
  }
  rtc_info_ = rtc_info;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentConfigurationDocument.rtc_info)
}

// -------------------------------------------------------------------

// AdapterConfiguration

// string id = 1 [json_name = "id"];
inline void AdapterConfiguration::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& AdapterConfiguration::id() const {
  // @@protoc_insertion_point(field_get:v1.model.AdapterConfiguration.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdapterConfiguration::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AdapterConfiguration.id)
}
inline std::string* AdapterConfiguration::mutable_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.AdapterConfiguration.id)
  return _internal_mutable_id();
}
inline const std::string& AdapterConfiguration::_internal_id() const {
  return id_.Get();
}
inline void AdapterConfiguration::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::release_id() {
  // @@protoc_insertion_point(field_release:v1.model.AdapterConfiguration.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AdapterConfiguration::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AdapterConfiguration.id)
}

// string name = 2 [json_name = "name"];
inline void AdapterConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& AdapterConfiguration::name() const {
  // @@protoc_insertion_point(field_get:v1.model.AdapterConfiguration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdapterConfiguration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AdapterConfiguration.name)
}
inline std::string* AdapterConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.AdapterConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& AdapterConfiguration::_internal_name() const {
  return name_.Get();
}
inline void AdapterConfiguration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:v1.model.AdapterConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AdapterConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AdapterConfiguration.name)
}

// string file_id = 3 [json_name = "fileId"];
inline void AdapterConfiguration::clear_file_id() {
  file_id_.ClearToEmpty();
}
inline const std::string& AdapterConfiguration::file_id() const {
  // @@protoc_insertion_point(field_get:v1.model.AdapterConfiguration.file_id)
  return _internal_file_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdapterConfiguration::set_file_id(ArgT0&& arg0, ArgT... args) {
 
 file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AdapterConfiguration.file_id)
}
inline std::string* AdapterConfiguration::mutable_file_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.AdapterConfiguration.file_id)
  return _internal_mutable_file_id();
}
inline const std::string& AdapterConfiguration::_internal_file_id() const {
  return file_id_.Get();
}
inline void AdapterConfiguration::_internal_set_file_id(const std::string& value) {
  
  file_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::_internal_mutable_file_id() {
  
  return file_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::release_file_id() {
  // @@protoc_insertion_point(field_release:v1.model.AdapterConfiguration.file_id)
  return file_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AdapterConfiguration::set_allocated_file_id(std::string* file_id) {
  if (file_id != nullptr) {
    
  } else {
    
  }
  file_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AdapterConfiguration.file_id)
}

// string exec_command = 4 [json_name = "execCommand"];
inline void AdapterConfiguration::clear_exec_command() {
  exec_command_.ClearToEmpty();
}
inline const std::string& AdapterConfiguration::exec_command() const {
  // @@protoc_insertion_point(field_get:v1.model.AdapterConfiguration.exec_command)
  return _internal_exec_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdapterConfiguration::set_exec_command(ArgT0&& arg0, ArgT... args) {
 
 exec_command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AdapterConfiguration.exec_command)
}
inline std::string* AdapterConfiguration::mutable_exec_command() {
  // @@protoc_insertion_point(field_mutable:v1.model.AdapterConfiguration.exec_command)
  return _internal_mutable_exec_command();
}
inline const std::string& AdapterConfiguration::_internal_exec_command() const {
  return exec_command_.Get();
}
inline void AdapterConfiguration::_internal_set_exec_command(const std::string& value) {
  
  exec_command_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::_internal_mutable_exec_command() {
  
  return exec_command_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::release_exec_command() {
  // @@protoc_insertion_point(field_release:v1.model.AdapterConfiguration.exec_command)
  return exec_command_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AdapterConfiguration::set_allocated_exec_command(std::string* exec_command) {
  if (exec_command != nullptr) {
    
  } else {
    
  }
  exec_command_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exec_command,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AdapterConfiguration.exec_command)
}

// string configuration = 5 [json_name = "configuration"];
inline void AdapterConfiguration::clear_configuration() {
  configuration_.ClearToEmpty();
}
inline const std::string& AdapterConfiguration::configuration() const {
  // @@protoc_insertion_point(field_get:v1.model.AdapterConfiguration.configuration)
  return _internal_configuration();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdapterConfiguration::set_configuration(ArgT0&& arg0, ArgT... args) {
 
 configuration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AdapterConfiguration.configuration)
}
inline std::string* AdapterConfiguration::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable:v1.model.AdapterConfiguration.configuration)
  return _internal_mutable_configuration();
}
inline const std::string& AdapterConfiguration::_internal_configuration() const {
  return configuration_.Get();
}
inline void AdapterConfiguration::_internal_set_configuration(const std::string& value) {
  
  configuration_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::_internal_mutable_configuration() {
  
  return configuration_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AdapterConfiguration::release_configuration() {
  // @@protoc_insertion_point(field_release:v1.model.AdapterConfiguration.configuration)
  return configuration_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AdapterConfiguration::set_allocated_configuration(std::string* configuration) {
  if (configuration != nullptr) {
    
  } else {
    
  }
  configuration_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configuration,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AdapterConfiguration.configuration)
}

// -------------------------------------------------------------------

// TeleopConfiguration

// repeated .v1.model.TeleopRosStreamConfiguration ros_streams = 1 [json_name = "rosStreams"];
inline int TeleopConfiguration::_internal_ros_streams_size() const {
  return ros_streams_.size();
}
inline int TeleopConfiguration::ros_streams_size() const {
  return _internal_ros_streams_size();
}
inline void TeleopConfiguration::clear_ros_streams() {
  ros_streams_.Clear();
}
inline ::v1::model::TeleopRosStreamConfiguration* TeleopConfiguration::mutable_ros_streams(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopConfiguration.ros_streams)
  return ros_streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopRosStreamConfiguration >*
TeleopConfiguration::mutable_ros_streams() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.TeleopConfiguration.ros_streams)
  return &ros_streams_;
}
inline const ::v1::model::TeleopRosStreamConfiguration& TeleopConfiguration::_internal_ros_streams(int index) const {
  return ros_streams_.Get(index);
}
inline const ::v1::model::TeleopRosStreamConfiguration& TeleopConfiguration::ros_streams(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopConfiguration.ros_streams)
  return _internal_ros_streams(index);
}
inline ::v1::model::TeleopRosStreamConfiguration* TeleopConfiguration::_internal_add_ros_streams() {
  return ros_streams_.Add();
}
inline ::v1::model::TeleopRosStreamConfiguration* TeleopConfiguration::add_ros_streams() {
  // @@protoc_insertion_point(field_add:v1.model.TeleopConfiguration.ros_streams)
  return _internal_add_ros_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopRosStreamConfiguration >&
TeleopConfiguration::ros_streams() const {
  // @@protoc_insertion_point(field_list:v1.model.TeleopConfiguration.ros_streams)
  return ros_streams_;
}

// repeated .v1.model.TeleopCustomStreamConfiguration custom_streams = 2 [json_name = "customStreams"];
inline int TeleopConfiguration::_internal_custom_streams_size() const {
  return custom_streams_.size();
}
inline int TeleopConfiguration::custom_streams_size() const {
  return _internal_custom_streams_size();
}
inline void TeleopConfiguration::clear_custom_streams() {
  custom_streams_.Clear();
}
inline ::v1::model::TeleopCustomStreamConfiguration* TeleopConfiguration::mutable_custom_streams(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopConfiguration.custom_streams)
  return custom_streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopCustomStreamConfiguration >*
TeleopConfiguration::mutable_custom_streams() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.TeleopConfiguration.custom_streams)
  return &custom_streams_;
}
inline const ::v1::model::TeleopCustomStreamConfiguration& TeleopConfiguration::_internal_custom_streams(int index) const {
  return custom_streams_.Get(index);
}
inline const ::v1::model::TeleopCustomStreamConfiguration& TeleopConfiguration::custom_streams(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopConfiguration.custom_streams)
  return _internal_custom_streams(index);
}
inline ::v1::model::TeleopCustomStreamConfiguration* TeleopConfiguration::_internal_add_custom_streams() {
  return custom_streams_.Add();
}
inline ::v1::model::TeleopCustomStreamConfiguration* TeleopConfiguration::add_custom_streams() {
  // @@protoc_insertion_point(field_add:v1.model.TeleopConfiguration.custom_streams)
  return _internal_add_custom_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopCustomStreamConfiguration >&
TeleopConfiguration::custom_streams() const {
  // @@protoc_insertion_point(field_list:v1.model.TeleopConfiguration.custom_streams)
  return custom_streams_;
}

// repeated .v1.model.TeleopHardwareStreamConfiguration hardware_streams = 3 [json_name = "hardwareStreams"];
inline int TeleopConfiguration::_internal_hardware_streams_size() const {
  return hardware_streams_.size();
}
inline int TeleopConfiguration::hardware_streams_size() const {
  return _internal_hardware_streams_size();
}
inline void TeleopConfiguration::clear_hardware_streams() {
  hardware_streams_.Clear();
}
inline ::v1::model::TeleopHardwareStreamConfiguration* TeleopConfiguration::mutable_hardware_streams(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopConfiguration.hardware_streams)
  return hardware_streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopHardwareStreamConfiguration >*
TeleopConfiguration::mutable_hardware_streams() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.TeleopConfiguration.hardware_streams)
  return &hardware_streams_;
}
inline const ::v1::model::TeleopHardwareStreamConfiguration& TeleopConfiguration::_internal_hardware_streams(int index) const {
  return hardware_streams_.Get(index);
}
inline const ::v1::model::TeleopHardwareStreamConfiguration& TeleopConfiguration::hardware_streams(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopConfiguration.hardware_streams)
  return _internal_hardware_streams(index);
}
inline ::v1::model::TeleopHardwareStreamConfiguration* TeleopConfiguration::_internal_add_hardware_streams() {
  return hardware_streams_.Add();
}
inline ::v1::model::TeleopHardwareStreamConfiguration* TeleopConfiguration::add_hardware_streams() {
  // @@protoc_insertion_point(field_add:v1.model.TeleopConfiguration.hardware_streams)
  return _internal_add_hardware_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::TeleopHardwareStreamConfiguration >&
TeleopConfiguration::hardware_streams() const {
  // @@protoc_insertion_point(field_list:v1.model.TeleopConfiguration.hardware_streams)
  return hardware_streams_;
}

// -------------------------------------------------------------------

// PortForwardingConfiguration

// .google.protobuf.BoolValue enabled = 1 [json_name = "enabled"];
inline bool PortForwardingConfiguration::_internal_has_enabled() const {
  return this != internal_default_instance() && enabled_ != nullptr;
}
inline bool PortForwardingConfiguration::has_enabled() const {
  return _internal_has_enabled();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& PortForwardingConfiguration::_internal_enabled() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = enabled_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& PortForwardingConfiguration::enabled() const {
  // @@protoc_insertion_point(field_get:v1.model.PortForwardingConfiguration.enabled)
  return _internal_enabled();
}
inline void PortForwardingConfiguration::unsafe_arena_set_allocated_enabled(
    PROTOBUF_NAMESPACE_ID::BoolValue* enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled_);
  }
  enabled_ = enabled;
  if (enabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.PortForwardingConfiguration.enabled)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* PortForwardingConfiguration::release_enabled() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = enabled_;
  enabled_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* PortForwardingConfiguration::unsafe_arena_release_enabled() {
  // @@protoc_insertion_point(field_release:v1.model.PortForwardingConfiguration.enabled)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = enabled_;
  enabled_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* PortForwardingConfiguration::_internal_mutable_enabled() {
  
  if (enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    enabled_ = p;
  }
  return enabled_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* PortForwardingConfiguration::mutable_enabled() {
  // @@protoc_insertion_point(field_mutable:v1.model.PortForwardingConfiguration.enabled)
  return _internal_mutable_enabled();
}
inline void PortForwardingConfiguration::set_allocated_enabled(PROTOBUF_NAMESPACE_ID::BoolValue* enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled_);
  }
  if (enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enabled));
    if (message_arena != submessage_arena) {
      enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enabled, submessage_arena);
    }
    
  } else {
    
  }
  enabled_ = enabled;
  // @@protoc_insertion_point(field_set_allocated:v1.model.PortForwardingConfiguration.enabled)
}

// -------------------------------------------------------------------

// TeleopRosStreamConfiguration

// string topic_name = 1 [json_name = "topicName"];
inline void TeleopRosStreamConfiguration::clear_topic_name() {
  topic_name_.ClearToEmpty();
}
inline const std::string& TeleopRosStreamConfiguration::topic_name() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.topic_name)
  return _internal_topic_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopRosStreamConfiguration::set_topic_name(ArgT0&& arg0, ArgT... args) {
 
 topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.topic_name)
}
inline std::string* TeleopRosStreamConfiguration::mutable_topic_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopRosStreamConfiguration.topic_name)
  return _internal_mutable_topic_name();
}
inline const std::string& TeleopRosStreamConfiguration::_internal_topic_name() const {
  return topic_name_.Get();
}
inline void TeleopRosStreamConfiguration::_internal_set_topic_name(const std::string& value) {
  
  topic_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::_internal_mutable_topic_name() {
  
  return topic_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::release_topic_name() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopRosStreamConfiguration.topic_name)
  return topic_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopRosStreamConfiguration::set_allocated_topic_name(std::string* topic_name) {
  if (topic_name != nullptr) {
    
  } else {
    
  }
  topic_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), topic_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopRosStreamConfiguration.topic_name)
}

// .v1.model.ROSTopicType topic_type = 2 [json_name = "topicType"];
inline void TeleopRosStreamConfiguration::clear_topic_type() {
  topic_type_ = 0;
}
inline ::v1::model::ROSTopicType TeleopRosStreamConfiguration::_internal_topic_type() const {
  return static_cast< ::v1::model::ROSTopicType >(topic_type_);
}
inline ::v1::model::ROSTopicType TeleopRosStreamConfiguration::topic_type() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.topic_type)
  return _internal_topic_type();
}
inline void TeleopRosStreamConfiguration::_internal_set_topic_type(::v1::model::ROSTopicType value) {
  
  topic_type_ = value;
}
inline void TeleopRosStreamConfiguration::set_topic_type(::v1::model::ROSTopicType value) {
  _internal_set_topic_type(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.topic_type)
}

// .v1.model.TeleopMode mode = 3 [json_name = "mode"];
inline void TeleopRosStreamConfiguration::clear_mode() {
  mode_ = 0;
}
inline ::v1::model::TeleopMode TeleopRosStreamConfiguration::_internal_mode() const {
  return static_cast< ::v1::model::TeleopMode >(mode_);
}
inline ::v1::model::TeleopMode TeleopRosStreamConfiguration::mode() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.mode)
  return _internal_mode();
}
inline void TeleopRosStreamConfiguration::_internal_set_mode(::v1::model::TeleopMode value) {
  
  mode_ = value;
}
inline void TeleopRosStreamConfiguration::set_mode(::v1::model::TeleopMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.mode)
}

// bool encode_video = 4 [json_name = "encodeVideo"];
inline void TeleopRosStreamConfiguration::clear_encode_video() {
  encode_video_ = false;
}
inline bool TeleopRosStreamConfiguration::_internal_encode_video() const {
  return encode_video_;
}
inline bool TeleopRosStreamConfiguration::encode_video() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.encode_video)
  return _internal_encode_video();
}
inline void TeleopRosStreamConfiguration::_internal_set_encode_video(bool value) {
  
  encode_video_ = value;
}
inline void TeleopRosStreamConfiguration::set_encode_video(bool value) {
  _internal_set_encode_video(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.encode_video)
}

// string audio_codec = 5 [json_name = "audioCodec"];
inline void TeleopRosStreamConfiguration::clear_audio_codec() {
  audio_codec_.ClearToEmpty();
}
inline const std::string& TeleopRosStreamConfiguration::audio_codec() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.audio_codec)
  return _internal_audio_codec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopRosStreamConfiguration::set_audio_codec(ArgT0&& arg0, ArgT... args) {
 
 audio_codec_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.audio_codec)
}
inline std::string* TeleopRosStreamConfiguration::mutable_audio_codec() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopRosStreamConfiguration.audio_codec)
  return _internal_mutable_audio_codec();
}
inline const std::string& TeleopRosStreamConfiguration::_internal_audio_codec() const {
  return audio_codec_.Get();
}
inline void TeleopRosStreamConfiguration::_internal_set_audio_codec(const std::string& value) {
  
  audio_codec_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::_internal_mutable_audio_codec() {
  
  return audio_codec_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::release_audio_codec() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopRosStreamConfiguration.audio_codec)
  return audio_codec_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopRosStreamConfiguration::set_allocated_audio_codec(std::string* audio_codec) {
  if (audio_codec != nullptr) {
    
  } else {
    
  }
  audio_codec_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_codec,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopRosStreamConfiguration.audio_codec)
}

// string quality = 6 [json_name = "quality"];
inline void TeleopRosStreamConfiguration::clear_quality() {
  quality_.ClearToEmpty();
}
inline const std::string& TeleopRosStreamConfiguration::quality() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.quality)
  return _internal_quality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopRosStreamConfiguration::set_quality(ArgT0&& arg0, ArgT... args) {
 
 quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.quality)
}
inline std::string* TeleopRosStreamConfiguration::mutable_quality() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopRosStreamConfiguration.quality)
  return _internal_mutable_quality();
}
inline const std::string& TeleopRosStreamConfiguration::_internal_quality() const {
  return quality_.Get();
}
inline void TeleopRosStreamConfiguration::_internal_set_quality(const std::string& value) {
  
  quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::_internal_mutable_quality() {
  
  return quality_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::release_quality() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopRosStreamConfiguration.quality)
  return quality_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopRosStreamConfiguration::set_allocated_quality(std::string* quality) {
  if (quality != nullptr) {
    
  } else {
    
  }
  quality_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quality,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopRosStreamConfiguration.quality)
}

// string base_reference_frame = 7 [json_name = "baseReferenceFrame"];
inline void TeleopRosStreamConfiguration::clear_base_reference_frame() {
  base_reference_frame_.ClearToEmpty();
}
inline const std::string& TeleopRosStreamConfiguration::base_reference_frame() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.base_reference_frame)
  return _internal_base_reference_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopRosStreamConfiguration::set_base_reference_frame(ArgT0&& arg0, ArgT... args) {
 
 base_reference_frame_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.base_reference_frame)
}
inline std::string* TeleopRosStreamConfiguration::mutable_base_reference_frame() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopRosStreamConfiguration.base_reference_frame)
  return _internal_mutable_base_reference_frame();
}
inline const std::string& TeleopRosStreamConfiguration::_internal_base_reference_frame() const {
  return base_reference_frame_.Get();
}
inline void TeleopRosStreamConfiguration::_internal_set_base_reference_frame(const std::string& value) {
  
  base_reference_frame_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::_internal_mutable_base_reference_frame() {
  
  return base_reference_frame_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::release_base_reference_frame() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopRosStreamConfiguration.base_reference_frame)
  return base_reference_frame_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopRosStreamConfiguration::set_allocated_base_reference_frame(std::string* base_reference_frame) {
  if (base_reference_frame != nullptr) {
    
  } else {
    
  }
  base_reference_frame_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), base_reference_frame,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopRosStreamConfiguration.base_reference_frame)
}

// string local_frame = 8 [json_name = "localFrame"];
inline void TeleopRosStreamConfiguration::clear_local_frame() {
  local_frame_.ClearToEmpty();
}
inline const std::string& TeleopRosStreamConfiguration::local_frame() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.local_frame)
  return _internal_local_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopRosStreamConfiguration::set_local_frame(ArgT0&& arg0, ArgT... args) {
 
 local_frame_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.local_frame)
}
inline std::string* TeleopRosStreamConfiguration::mutable_local_frame() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopRosStreamConfiguration.local_frame)
  return _internal_mutable_local_frame();
}
inline const std::string& TeleopRosStreamConfiguration::_internal_local_frame() const {
  return local_frame_.Get();
}
inline void TeleopRosStreamConfiguration::_internal_set_local_frame(const std::string& value) {
  
  local_frame_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::_internal_mutable_local_frame() {
  
  return local_frame_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopRosStreamConfiguration::release_local_frame() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopRosStreamConfiguration.local_frame)
  return local_frame_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopRosStreamConfiguration::set_allocated_local_frame(std::string* local_frame) {
  if (local_frame != nullptr) {
    
  } else {
    
  }
  local_frame_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), local_frame,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopRosStreamConfiguration.local_frame)
}

// bool overlay_clock = 9 [json_name = "overlayClock"];
inline void TeleopRosStreamConfiguration::clear_overlay_clock() {
  overlay_clock_ = false;
}
inline bool TeleopRosStreamConfiguration::_internal_overlay_clock() const {
  return overlay_clock_;
}
inline bool TeleopRosStreamConfiguration::overlay_clock() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRosStreamConfiguration.overlay_clock)
  return _internal_overlay_clock();
}
inline void TeleopRosStreamConfiguration::_internal_set_overlay_clock(bool value) {
  
  overlay_clock_ = value;
}
inline void TeleopRosStreamConfiguration::set_overlay_clock(bool value) {
  _internal_set_overlay_clock(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopRosStreamConfiguration.overlay_clock)
}

// -------------------------------------------------------------------

// TeleopHardwareStreamConfiguration

// string name = 1 [json_name = "name"];
inline void TeleopHardwareStreamConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::name() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.name)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_name() const {
  return name_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.name)
}

// string rtc_stream_type = 2 [json_name = "rtcStreamType"];
inline void TeleopHardwareStreamConfiguration::clear_rtc_stream_type() {
  rtc_stream_type_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::rtc_stream_type() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.rtc_stream_type)
  return _internal_rtc_stream_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_rtc_stream_type(ArgT0&& arg0, ArgT... args) {
 
 rtc_stream_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.rtc_stream_type)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_rtc_stream_type() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.rtc_stream_type)
  return _internal_mutable_rtc_stream_type();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_rtc_stream_type() const {
  return rtc_stream_type_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_rtc_stream_type(const std::string& value) {
  
  rtc_stream_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_rtc_stream_type() {
  
  return rtc_stream_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_rtc_stream_type() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.rtc_stream_type)
  return rtc_stream_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_rtc_stream_type(std::string* rtc_stream_type) {
  if (rtc_stream_type != nullptr) {
    
  } else {
    
  }
  rtc_stream_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rtc_stream_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.rtc_stream_type)
}

// .v1.model.TeleopMode mode = 3 [json_name = "mode"];
inline void TeleopHardwareStreamConfiguration::clear_mode() {
  mode_ = 0;
}
inline ::v1::model::TeleopMode TeleopHardwareStreamConfiguration::_internal_mode() const {
  return static_cast< ::v1::model::TeleopMode >(mode_);
}
inline ::v1::model::TeleopMode TeleopHardwareStreamConfiguration::mode() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.mode)
  return _internal_mode();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_mode(::v1::model::TeleopMode value) {
  
  mode_ = value;
}
inline void TeleopHardwareStreamConfiguration::set_mode(::v1::model::TeleopMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.mode)
}

// string hw_descriptor = 4 [json_name = "hwDescriptor"];
inline void TeleopHardwareStreamConfiguration::clear_hw_descriptor() {
  hw_descriptor_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::hw_descriptor() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.hw_descriptor)
  return _internal_hw_descriptor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_hw_descriptor(ArgT0&& arg0, ArgT... args) {
 
 hw_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.hw_descriptor)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_hw_descriptor() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.hw_descriptor)
  return _internal_mutable_hw_descriptor();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_hw_descriptor() const {
  return hw_descriptor_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_hw_descriptor(const std::string& value) {
  
  hw_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_hw_descriptor() {
  
  return hw_descriptor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_hw_descriptor() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.hw_descriptor)
  return hw_descriptor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_hw_descriptor(std::string* hw_descriptor) {
  if (hw_descriptor != nullptr) {
    
  } else {
    
  }
  hw_descriptor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hw_descriptor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.hw_descriptor)
}

// string quality = 5 [json_name = "quality"];
inline void TeleopHardwareStreamConfiguration::clear_quality() {
  quality_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::quality() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.quality)
  return _internal_quality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_quality(ArgT0&& arg0, ArgT... args) {
 
 quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.quality)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_quality() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.quality)
  return _internal_mutable_quality();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_quality() const {
  return quality_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_quality(const std::string& value) {
  
  quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_quality() {
  
  return quality_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_quality() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.quality)
  return quality_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_quality(std::string* quality) {
  if (quality != nullptr) {
    
  } else {
    
  }
  quality_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quality,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.quality)
}

// string hardware_type = 6 [json_name = "hardwareType"];
inline void TeleopHardwareStreamConfiguration::clear_hardware_type() {
  hardware_type_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::hardware_type() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.hardware_type)
  return _internal_hardware_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_hardware_type(ArgT0&& arg0, ArgT... args) {
 
 hardware_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.hardware_type)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_hardware_type() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.hardware_type)
  return _internal_mutable_hardware_type();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_hardware_type() const {
  return hardware_type_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_hardware_type(const std::string& value) {
  
  hardware_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_hardware_type() {
  
  return hardware_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_hardware_type() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.hardware_type)
  return hardware_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_hardware_type(std::string* hardware_type) {
  if (hardware_type != nullptr) {
    
  } else {
    
  }
  hardware_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hardware_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.hardware_type)
}

// bool rtsp_encoding_needed = 7 [json_name = "rtspEncodingNeeded"];
inline void TeleopHardwareStreamConfiguration::clear_rtsp_encoding_needed() {
  rtsp_encoding_needed_ = false;
}
inline bool TeleopHardwareStreamConfiguration::_internal_rtsp_encoding_needed() const {
  return rtsp_encoding_needed_;
}
inline bool TeleopHardwareStreamConfiguration::rtsp_encoding_needed() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.rtsp_encoding_needed)
  return _internal_rtsp_encoding_needed();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_rtsp_encoding_needed(bool value) {
  
  rtsp_encoding_needed_ = value;
}
inline void TeleopHardwareStreamConfiguration::set_rtsp_encoding_needed(bool value) {
  _internal_set_rtsp_encoding_needed(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.rtsp_encoding_needed)
}

// bool is_onvif = 8 [json_name = "isOnvif"];
inline void TeleopHardwareStreamConfiguration::clear_is_onvif() {
  is_onvif_ = false;
}
inline bool TeleopHardwareStreamConfiguration::_internal_is_onvif() const {
  return is_onvif_;
}
inline bool TeleopHardwareStreamConfiguration::is_onvif() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.is_onvif)
  return _internal_is_onvif();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_is_onvif(bool value) {
  
  is_onvif_ = value;
}
inline void TeleopHardwareStreamConfiguration::set_is_onvif(bool value) {
  _internal_set_is_onvif(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.is_onvif)
}

// string ip_cam_username = 9 [json_name = "ipCamUsername"];
inline void TeleopHardwareStreamConfiguration::clear_ip_cam_username() {
  ip_cam_username_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::ip_cam_username() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.ip_cam_username)
  return _internal_ip_cam_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_ip_cam_username(ArgT0&& arg0, ArgT... args) {
 
 ip_cam_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.ip_cam_username)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_ip_cam_username() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.ip_cam_username)
  return _internal_mutable_ip_cam_username();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_ip_cam_username() const {
  return ip_cam_username_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_ip_cam_username(const std::string& value) {
  
  ip_cam_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_ip_cam_username() {
  
  return ip_cam_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_ip_cam_username() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.ip_cam_username)
  return ip_cam_username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_ip_cam_username(std::string* ip_cam_username) {
  if (ip_cam_username != nullptr) {
    
  } else {
    
  }
  ip_cam_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_cam_username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.ip_cam_username)
}

// string ip_cam_password = 10 [json_name = "ipCamPassword"];
inline void TeleopHardwareStreamConfiguration::clear_ip_cam_password() {
  ip_cam_password_.ClearToEmpty();
}
inline const std::string& TeleopHardwareStreamConfiguration::ip_cam_password() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.ip_cam_password)
  return _internal_ip_cam_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopHardwareStreamConfiguration::set_ip_cam_password(ArgT0&& arg0, ArgT... args) {
 
 ip_cam_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.ip_cam_password)
}
inline std::string* TeleopHardwareStreamConfiguration::mutable_ip_cam_password() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopHardwareStreamConfiguration.ip_cam_password)
  return _internal_mutable_ip_cam_password();
}
inline const std::string& TeleopHardwareStreamConfiguration::_internal_ip_cam_password() const {
  return ip_cam_password_.Get();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_ip_cam_password(const std::string& value) {
  
  ip_cam_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::_internal_mutable_ip_cam_password() {
  
  return ip_cam_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopHardwareStreamConfiguration::release_ip_cam_password() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopHardwareStreamConfiguration.ip_cam_password)
  return ip_cam_password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopHardwareStreamConfiguration::set_allocated_ip_cam_password(std::string* ip_cam_password) {
  if (ip_cam_password != nullptr) {
    
  } else {
    
  }
  ip_cam_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_cam_password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopHardwareStreamConfiguration.ip_cam_password)
}

// bool overlay_clock = 11 [json_name = "overlayClock"];
inline void TeleopHardwareStreamConfiguration::clear_overlay_clock() {
  overlay_clock_ = false;
}
inline bool TeleopHardwareStreamConfiguration::_internal_overlay_clock() const {
  return overlay_clock_;
}
inline bool TeleopHardwareStreamConfiguration::overlay_clock() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopHardwareStreamConfiguration.overlay_clock)
  return _internal_overlay_clock();
}
inline void TeleopHardwareStreamConfiguration::_internal_set_overlay_clock(bool value) {
  
  overlay_clock_ = value;
}
inline void TeleopHardwareStreamConfiguration::set_overlay_clock(bool value) {
  _internal_set_overlay_clock(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopHardwareStreamConfiguration.overlay_clock)
}

// -------------------------------------------------------------------

// TeleopCustomStreamConfiguration

// string name = 1 [json_name = "name"];
inline void TeleopCustomStreamConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& TeleopCustomStreamConfiguration::name() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopCustomStreamConfiguration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopCustomStreamConfiguration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopCustomStreamConfiguration.name)
}
inline std::string* TeleopCustomStreamConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopCustomStreamConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& TeleopCustomStreamConfiguration::_internal_name() const {
  return name_.Get();
}
inline void TeleopCustomStreamConfiguration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopCustomStreamConfiguration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopCustomStreamConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopCustomStreamConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopCustomStreamConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopCustomStreamConfiguration.name)
}

// string rtc_stream_type = 2 [json_name = "rtcStreamType"];
inline void TeleopCustomStreamConfiguration::clear_rtc_stream_type() {
  rtc_stream_type_.ClearToEmpty();
}
inline const std::string& TeleopCustomStreamConfiguration::rtc_stream_type() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopCustomStreamConfiguration.rtc_stream_type)
  return _internal_rtc_stream_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopCustomStreamConfiguration::set_rtc_stream_type(ArgT0&& arg0, ArgT... args) {
 
 rtc_stream_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopCustomStreamConfiguration.rtc_stream_type)
}
inline std::string* TeleopCustomStreamConfiguration::mutable_rtc_stream_type() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopCustomStreamConfiguration.rtc_stream_type)
  return _internal_mutable_rtc_stream_type();
}
inline const std::string& TeleopCustomStreamConfiguration::_internal_rtc_stream_type() const {
  return rtc_stream_type_.Get();
}
inline void TeleopCustomStreamConfiguration::_internal_set_rtc_stream_type(const std::string& value) {
  
  rtc_stream_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopCustomStreamConfiguration::_internal_mutable_rtc_stream_type() {
  
  return rtc_stream_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopCustomStreamConfiguration::release_rtc_stream_type() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopCustomStreamConfiguration.rtc_stream_type)
  return rtc_stream_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopCustomStreamConfiguration::set_allocated_rtc_stream_type(std::string* rtc_stream_type) {
  if (rtc_stream_type != nullptr) {
    
  } else {
    
  }
  rtc_stream_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rtc_stream_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopCustomStreamConfiguration.rtc_stream_type)
}

// .v1.model.TeleopMode mode = 3 [json_name = "mode"];
inline void TeleopCustomStreamConfiguration::clear_mode() {
  mode_ = 0;
}
inline ::v1::model::TeleopMode TeleopCustomStreamConfiguration::_internal_mode() const {
  return static_cast< ::v1::model::TeleopMode >(mode_);
}
inline ::v1::model::TeleopMode TeleopCustomStreamConfiguration::mode() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopCustomStreamConfiguration.mode)
  return _internal_mode();
}
inline void TeleopCustomStreamConfiguration::_internal_set_mode(::v1::model::TeleopMode value) {
  
  mode_ = value;
}
inline void TeleopCustomStreamConfiguration::set_mode(::v1::model::TeleopMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopCustomStreamConfiguration.mode)
}

// bool encode_video = 4 [json_name = "encodeVideo"];
inline void TeleopCustomStreamConfiguration::clear_encode_video() {
  encode_video_ = false;
}
inline bool TeleopCustomStreamConfiguration::_internal_encode_video() const {
  return encode_video_;
}
inline bool TeleopCustomStreamConfiguration::encode_video() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopCustomStreamConfiguration.encode_video)
  return _internal_encode_video();
}
inline void TeleopCustomStreamConfiguration::_internal_set_encode_video(bool value) {
  
  encode_video_ = value;
}
inline void TeleopCustomStreamConfiguration::set_encode_video(bool value) {
  _internal_set_encode_video(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopCustomStreamConfiguration.encode_video)
}

// string quality = 5 [json_name = "quality"];
inline void TeleopCustomStreamConfiguration::clear_quality() {
  quality_.ClearToEmpty();
}
inline const std::string& TeleopCustomStreamConfiguration::quality() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopCustomStreamConfiguration.quality)
  return _internal_quality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopCustomStreamConfiguration::set_quality(ArgT0&& arg0, ArgT... args) {
 
 quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopCustomStreamConfiguration.quality)
}
inline std::string* TeleopCustomStreamConfiguration::mutable_quality() {
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopCustomStreamConfiguration.quality)
  return _internal_mutable_quality();
}
inline const std::string& TeleopCustomStreamConfiguration::_internal_quality() const {
  return quality_.Get();
}
inline void TeleopCustomStreamConfiguration::_internal_set_quality(const std::string& value) {
  
  quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TeleopCustomStreamConfiguration::_internal_mutable_quality() {
  
  return quality_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TeleopCustomStreamConfiguration::release_quality() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopCustomStreamConfiguration.quality)
  return quality_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TeleopCustomStreamConfiguration::set_allocated_quality(std::string* quality) {
  if (quality != nullptr) {
    
  } else {
    
  }
  quality_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quality,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopCustomStreamConfiguration.quality)
}

// bool overlay_clock = 6 [json_name = "overlayClock"];
inline void TeleopCustomStreamConfiguration::clear_overlay_clock() {
  overlay_clock_ = false;
}
inline bool TeleopCustomStreamConfiguration::_internal_overlay_clock() const {
  return overlay_clock_;
}
inline bool TeleopCustomStreamConfiguration::overlay_clock() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopCustomStreamConfiguration.overlay_clock)
  return _internal_overlay_clock();
}
inline void TeleopCustomStreamConfiguration::_internal_set_overlay_clock(bool value) {
  
  overlay_clock_ = value;
}
inline void TeleopCustomStreamConfiguration::set_overlay_clock(bool value) {
  _internal_set_overlay_clock(value);
  // @@protoc_insertion_point(field_set:v1.model.TeleopCustomStreamConfiguration.overlay_clock)
}

// -------------------------------------------------------------------

// TelemetryConfiguration

// repeated .v1.model.StreamConfiguration streams = 1 [json_name = "streams"];
inline int TelemetryConfiguration::_internal_streams_size() const {
  return streams_.size();
}
inline int TelemetryConfiguration::streams_size() const {
  return _internal_streams_size();
}
inline void TelemetryConfiguration::clear_streams() {
  streams_.Clear();
}
inline ::v1::model::StreamConfiguration* TelemetryConfiguration::mutable_streams(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.TelemetryConfiguration.streams)
  return streams_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::StreamConfiguration >*
TelemetryConfiguration::mutable_streams() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.TelemetryConfiguration.streams)
  return &streams_;
}
inline const ::v1::model::StreamConfiguration& TelemetryConfiguration::_internal_streams(int index) const {
  return streams_.Get(index);
}
inline const ::v1::model::StreamConfiguration& TelemetryConfiguration::streams(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.TelemetryConfiguration.streams)
  return _internal_streams(index);
}
inline ::v1::model::StreamConfiguration* TelemetryConfiguration::_internal_add_streams() {
  return streams_.Add();
}
inline ::v1::model::StreamConfiguration* TelemetryConfiguration::add_streams() {
  // @@protoc_insertion_point(field_add:v1.model.TelemetryConfiguration.streams)
  return _internal_add_streams();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::StreamConfiguration >&
TelemetryConfiguration::streams() const {
  // @@protoc_insertion_point(field_list:v1.model.TelemetryConfiguration.streams)
  return streams_;
}

// .v1.model.ROSConfiguration ros = 2 [json_name = "ros"];
inline bool TelemetryConfiguration::_internal_has_ros() const {
  return this != internal_default_instance() && ros_ != nullptr;
}
inline bool TelemetryConfiguration::has_ros() const {
  return _internal_has_ros();
}
inline void TelemetryConfiguration::clear_ros() {
  if (GetArenaForAllocation() == nullptr && ros_ != nullptr) {
    delete ros_;
  }
  ros_ = nullptr;
}
inline const ::v1::model::ROSConfiguration& TelemetryConfiguration::_internal_ros() const {
  const ::v1::model::ROSConfiguration* p = ros_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::ROSConfiguration&>(
      ::v1::model::_ROSConfiguration_default_instance_);
}
inline const ::v1::model::ROSConfiguration& TelemetryConfiguration::ros() const {
  // @@protoc_insertion_point(field_get:v1.model.TelemetryConfiguration.ros)
  return _internal_ros();
}
inline void TelemetryConfiguration::unsafe_arena_set_allocated_ros(
    ::v1::model::ROSConfiguration* ros) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ros_);
  }
  ros_ = ros;
  if (ros) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.TelemetryConfiguration.ros)
}
inline ::v1::model::ROSConfiguration* TelemetryConfiguration::release_ros() {
  
  ::v1::model::ROSConfiguration* temp = ros_;
  ros_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::ROSConfiguration* TelemetryConfiguration::unsafe_arena_release_ros() {
  // @@protoc_insertion_point(field_release:v1.model.TelemetryConfiguration.ros)
  
  ::v1::model::ROSConfiguration* temp = ros_;
  ros_ = nullptr;
  return temp;
}
inline ::v1::model::ROSConfiguration* TelemetryConfiguration::_internal_mutable_ros() {
  
  if (ros_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::ROSConfiguration>(GetArenaForAllocation());
    ros_ = p;
  }
  return ros_;
}
inline ::v1::model::ROSConfiguration* TelemetryConfiguration::mutable_ros() {
  // @@protoc_insertion_point(field_mutable:v1.model.TelemetryConfiguration.ros)
  return _internal_mutable_ros();
}
inline void TelemetryConfiguration::set_allocated_ros(::v1::model::ROSConfiguration* ros) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ros_;
  }
  if (ros) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::ROSConfiguration>::GetOwningArena(ros);
    if (message_arena != submessage_arena) {
      ros = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ros, submessage_arena);
    }
    
  } else {
    
  }
  ros_ = ros;
  // @@protoc_insertion_point(field_set_allocated:v1.model.TelemetryConfiguration.ros)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ApplicationConfiguration

// map<string, string> configuration_map = 1 [json_name = "configurationMap"];
inline int ApplicationConfiguration::_internal_configuration_map_size() const {
  return configuration_map_.size();
}
inline int ApplicationConfiguration::configuration_map_size() const {
  return _internal_configuration_map_size();
}
inline void ApplicationConfiguration::clear_configuration_map() {
  configuration_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ApplicationConfiguration::_internal_configuration_map() const {
  return configuration_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ApplicationConfiguration::configuration_map() const {
  // @@protoc_insertion_point(field_map:v1.model.ApplicationConfiguration.configuration_map)
  return _internal_configuration_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ApplicationConfiguration::_internal_mutable_configuration_map() {
  return configuration_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ApplicationConfiguration::mutable_configuration_map() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.ApplicationConfiguration.configuration_map)
  return _internal_mutable_configuration_map();
}

// -------------------------------------------------------------------

// ResourcesConfiguration

// .v1.model.DiskConfiguration disk = 1 [json_name = "disk"];
inline bool ResourcesConfiguration::_internal_has_disk() const {
  return this != internal_default_instance() && disk_ != nullptr;
}
inline bool ResourcesConfiguration::has_disk() const {
  return _internal_has_disk();
}
inline void ResourcesConfiguration::clear_disk() {
  if (GetArenaForAllocation() == nullptr && disk_ != nullptr) {
    delete disk_;
  }
  disk_ = nullptr;
}
inline const ::v1::model::DiskConfiguration& ResourcesConfiguration::_internal_disk() const {
  const ::v1::model::DiskConfiguration* p = disk_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::DiskConfiguration&>(
      ::v1::model::_DiskConfiguration_default_instance_);
}
inline const ::v1::model::DiskConfiguration& ResourcesConfiguration::disk() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.disk)
  return _internal_disk();
}
inline void ResourcesConfiguration::unsafe_arena_set_allocated_disk(
    ::v1::model::DiskConfiguration* disk) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disk_);
  }
  disk_ = disk;
  if (disk) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ResourcesConfiguration.disk)
}
inline ::v1::model::DiskConfiguration* ResourcesConfiguration::release_disk() {
  
  ::v1::model::DiskConfiguration* temp = disk_;
  disk_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::DiskConfiguration* ResourcesConfiguration::unsafe_arena_release_disk() {
  // @@protoc_insertion_point(field_release:v1.model.ResourcesConfiguration.disk)
  
  ::v1::model::DiskConfiguration* temp = disk_;
  disk_ = nullptr;
  return temp;
}
inline ::v1::model::DiskConfiguration* ResourcesConfiguration::_internal_mutable_disk() {
  
  if (disk_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::DiskConfiguration>(GetArenaForAllocation());
    disk_ = p;
  }
  return disk_;
}
inline ::v1::model::DiskConfiguration* ResourcesConfiguration::mutable_disk() {
  // @@protoc_insertion_point(field_mutable:v1.model.ResourcesConfiguration.disk)
  return _internal_mutable_disk();
}
inline void ResourcesConfiguration::set_allocated_disk(::v1::model::DiskConfiguration* disk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete disk_;
  }
  if (disk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::DiskConfiguration>::GetOwningArena(disk);
    if (message_arena != submessage_arena) {
      disk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disk, submessage_arena);
    }
    
  } else {
    
  }
  disk_ = disk;
  // @@protoc_insertion_point(field_set_allocated:v1.model.ResourcesConfiguration.disk)
}

// .google.protobuf.DoubleValue stream_throttle_hz = 2 [json_name = "streamThrottleHz"];
inline bool ResourcesConfiguration::_internal_has_stream_throttle_hz() const {
  return this != internal_default_instance() && stream_throttle_hz_ != nullptr;
}
inline bool ResourcesConfiguration::has_stream_throttle_hz() const {
  return _internal_has_stream_throttle_hz();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& ResourcesConfiguration::_internal_stream_throttle_hz() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = stream_throttle_hz_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& ResourcesConfiguration::stream_throttle_hz() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.stream_throttle_hz)
  return _internal_stream_throttle_hz();
}
inline void ResourcesConfiguration::unsafe_arena_set_allocated_stream_throttle_hz(
    PROTOBUF_NAMESPACE_ID::DoubleValue* stream_throttle_hz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_throttle_hz_);
  }
  stream_throttle_hz_ = stream_throttle_hz;
  if (stream_throttle_hz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ResourcesConfiguration.stream_throttle_hz)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* ResourcesConfiguration::release_stream_throttle_hz() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = stream_throttle_hz_;
  stream_throttle_hz_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* ResourcesConfiguration::unsafe_arena_release_stream_throttle_hz() {
  // @@protoc_insertion_point(field_release:v1.model.ResourcesConfiguration.stream_throttle_hz)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = stream_throttle_hz_;
  stream_throttle_hz_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* ResourcesConfiguration::_internal_mutable_stream_throttle_hz() {
  
  if (stream_throttle_hz_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    stream_throttle_hz_ = p;
  }
  return stream_throttle_hz_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* ResourcesConfiguration::mutable_stream_throttle_hz() {
  // @@protoc_insertion_point(field_mutable:v1.model.ResourcesConfiguration.stream_throttle_hz)
  return _internal_mutable_stream_throttle_hz();
}
inline void ResourcesConfiguration::set_allocated_stream_throttle_hz(PROTOBUF_NAMESPACE_ID::DoubleValue* stream_throttle_hz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_throttle_hz_);
  }
  if (stream_throttle_hz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(stream_throttle_hz));
    if (message_arena != submessage_arena) {
      stream_throttle_hz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stream_throttle_hz, submessage_arena);
    }
    
  } else {
    
  }
  stream_throttle_hz_ = stream_throttle_hz;
  // @@protoc_insertion_point(field_set_allocated:v1.model.ResourcesConfiguration.stream_throttle_hz)
}

// bool low_bandwidth_agent = 3 [json_name = "lowBandwidthAgent"];
inline void ResourcesConfiguration::clear_low_bandwidth_agent() {
  low_bandwidth_agent_ = false;
}
inline bool ResourcesConfiguration::_internal_low_bandwidth_agent() const {
  return low_bandwidth_agent_;
}
inline bool ResourcesConfiguration::low_bandwidth_agent() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.low_bandwidth_agent)
  return _internal_low_bandwidth_agent();
}
inline void ResourcesConfiguration::_internal_set_low_bandwidth_agent(bool value) {
  
  low_bandwidth_agent_ = value;
}
inline void ResourcesConfiguration::set_low_bandwidth_agent(bool value) {
  _internal_set_low_bandwidth_agent(value);
  // @@protoc_insertion_point(field_set:v1.model.ResourcesConfiguration.low_bandwidth_agent)
}

// uint64 datapoint_batch_size = 4 [json_name = "datapointBatchSize"];
inline void ResourcesConfiguration::clear_datapoint_batch_size() {
  datapoint_batch_size_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::_internal_datapoint_batch_size() const {
  return datapoint_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::datapoint_batch_size() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.datapoint_batch_size)
  return _internal_datapoint_batch_size();
}
inline void ResourcesConfiguration::_internal_set_datapoint_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  datapoint_batch_size_ = value;
}
inline void ResourcesConfiguration::set_datapoint_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_datapoint_batch_size(value);
  // @@protoc_insertion_point(field_set:v1.model.ResourcesConfiguration.datapoint_batch_size)
}

// uint64 datapoint_batchLifetime_ms = 5 [json_name = "datapointBatchLifetimeMs"];
inline void ResourcesConfiguration::clear_datapoint_batchlifetime_ms() {
  datapoint_batchlifetime_ms_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::_internal_datapoint_batchlifetime_ms() const {
  return datapoint_batchlifetime_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::datapoint_batchlifetime_ms() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.datapoint_batchLifetime_ms)
  return _internal_datapoint_batchlifetime_ms();
}
inline void ResourcesConfiguration::_internal_set_datapoint_batchlifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  datapoint_batchlifetime_ms_ = value;
}
inline void ResourcesConfiguration::set_datapoint_batchlifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_datapoint_batchlifetime_ms(value);
  // @@protoc_insertion_point(field_set:v1.model.ResourcesConfiguration.datapoint_batchLifetime_ms)
}

// uint64 asset_batch_size = 6 [json_name = "assetBatchSize"];
inline void ResourcesConfiguration::clear_asset_batch_size() {
  asset_batch_size_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::_internal_asset_batch_size() const {
  return asset_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::asset_batch_size() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.asset_batch_size)
  return _internal_asset_batch_size();
}
inline void ResourcesConfiguration::_internal_set_asset_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  asset_batch_size_ = value;
}
inline void ResourcesConfiguration::set_asset_batch_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_asset_batch_size(value);
  // @@protoc_insertion_point(field_set:v1.model.ResourcesConfiguration.asset_batch_size)
}

// uint64 asset_batch_lifetime_ms = 7 [json_name = "assetBatchLifetimeMs"];
inline void ResourcesConfiguration::clear_asset_batch_lifetime_ms() {
  asset_batch_lifetime_ms_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::_internal_asset_batch_lifetime_ms() const {
  return asset_batch_lifetime_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ResourcesConfiguration::asset_batch_lifetime_ms() const {
  // @@protoc_insertion_point(field_get:v1.model.ResourcesConfiguration.asset_batch_lifetime_ms)
  return _internal_asset_batch_lifetime_ms();
}
inline void ResourcesConfiguration::_internal_set_asset_batch_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  asset_batch_lifetime_ms_ = value;
}
inline void ResourcesConfiguration::set_asset_batch_lifetime_ms(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_asset_batch_lifetime_ms(value);
  // @@protoc_insertion_point(field_set:v1.model.ResourcesConfiguration.asset_batch_lifetime_ms)
}

// -------------------------------------------------------------------

// DiskConfiguration

// int64 buffer_size = 1 [json_name = "bufferSize"];
inline void DiskConfiguration::clear_buffer_size() {
  buffer_size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskConfiguration::_internal_buffer_size() const {
  return buffer_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskConfiguration::buffer_size() const {
  // @@protoc_insertion_point(field_get:v1.model.DiskConfiguration.buffer_size)
  return _internal_buffer_size();
}
inline void DiskConfiguration::_internal_set_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  buffer_size_ = value;
}
inline void DiskConfiguration::set_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_buffer_size(value);
  // @@protoc_insertion_point(field_set:v1.model.DiskConfiguration.buffer_size)
}

// int64 on_demand_buffer_size = 2 [json_name = "onDemandBufferSize"];
inline void DiskConfiguration::clear_on_demand_buffer_size() {
  on_demand_buffer_size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskConfiguration::_internal_on_demand_buffer_size() const {
  return on_demand_buffer_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DiskConfiguration::on_demand_buffer_size() const {
  // @@protoc_insertion_point(field_get:v1.model.DiskConfiguration.on_demand_buffer_size)
  return _internal_on_demand_buffer_size();
}
inline void DiskConfiguration::_internal_set_on_demand_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  on_demand_buffer_size_ = value;
}
inline void DiskConfiguration::set_on_demand_buffer_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_on_demand_buffer_size(value);
  // @@protoc_insertion_point(field_set:v1.model.DiskConfiguration.on_demand_buffer_size)
}

// -------------------------------------------------------------------

// ROSConfiguration

// string world_reference_frame_id = 1 [json_name = "worldReferenceFrameId"];
inline void ROSConfiguration::clear_world_reference_frame_id() {
  world_reference_frame_id_.ClearToEmpty();
}
inline const std::string& ROSConfiguration::world_reference_frame_id() const {
  // @@protoc_insertion_point(field_get:v1.model.ROSConfiguration.world_reference_frame_id)
  return _internal_world_reference_frame_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ROSConfiguration::set_world_reference_frame_id(ArgT0&& arg0, ArgT... args) {
 
 world_reference_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.ROSConfiguration.world_reference_frame_id)
}
inline std::string* ROSConfiguration::mutable_world_reference_frame_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.ROSConfiguration.world_reference_frame_id)
  return _internal_mutable_world_reference_frame_id();
}
inline const std::string& ROSConfiguration::_internal_world_reference_frame_id() const {
  return world_reference_frame_id_.Get();
}
inline void ROSConfiguration::_internal_set_world_reference_frame_id(const std::string& value) {
  
  world_reference_frame_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ROSConfiguration::_internal_mutable_world_reference_frame_id() {
  
  return world_reference_frame_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ROSConfiguration::release_world_reference_frame_id() {
  // @@protoc_insertion_point(field_release:v1.model.ROSConfiguration.world_reference_frame_id)
  return world_reference_frame_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ROSConfiguration::set_allocated_world_reference_frame_id(std::string* world_reference_frame_id) {
  if (world_reference_frame_id != nullptr) {
    
  } else {
    
  }
  world_reference_frame_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), world_reference_frame_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.ROSConfiguration.world_reference_frame_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// StreamConfiguration

// string name = 1 [json_name = "name"];
inline void StreamConfiguration::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& StreamConfiguration::name() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamConfiguration::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.StreamConfiguration.name)
}
inline std::string* StreamConfiguration::mutable_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.name)
  return _internal_mutable_name();
}
inline const std::string& StreamConfiguration::_internal_name() const {
  return name_.Get();
}
inline void StreamConfiguration::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamConfiguration::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamConfiguration::release_name() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamConfiguration::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamConfiguration.name)
}

// map<string, string> tags = 2 [json_name = "tags"];
inline int StreamConfiguration::_internal_tags_size() const {
  return tags_.size();
}
inline int StreamConfiguration::tags_size() const {
  return _internal_tags_size();
}
inline void StreamConfiguration::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StreamConfiguration::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
StreamConfiguration::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.StreamConfiguration.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StreamConfiguration::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
StreamConfiguration::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.StreamConfiguration.tags)
  return _internal_mutable_tags();
}

// .v1.model.ROSTopic ros_topic = 3 [json_name = "rosTopic"];
inline bool StreamConfiguration::_internal_has_ros_topic() const {
  return configuration_case() == kRosTopic;
}
inline bool StreamConfiguration::has_ros_topic() const {
  return _internal_has_ros_topic();
}
inline void StreamConfiguration::set_has_ros_topic() {
  _oneof_case_[0] = kRosTopic;
}
inline ::v1::model::ROSTopic* StreamConfiguration::release_ros_topic() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.ros_topic)
  if (_internal_has_ros_topic()) {
    clear_has_configuration();
      ::v1::model::ROSTopic* temp = configuration_.ros_topic_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.ros_topic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::ROSTopic& StreamConfiguration::_internal_ros_topic() const {
  return _internal_has_ros_topic()
      ? *configuration_.ros_topic_
      : reinterpret_cast< ::v1::model::ROSTopic&>(::v1::model::_ROSTopic_default_instance_);
}
inline const ::v1::model::ROSTopic& StreamConfiguration::ros_topic() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.ros_topic)
  return _internal_ros_topic();
}
inline ::v1::model::ROSTopic* StreamConfiguration::unsafe_arena_release_ros_topic() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.ros_topic)
  if (_internal_has_ros_topic()) {
    clear_has_configuration();
    ::v1::model::ROSTopic* temp = configuration_.ros_topic_;
    configuration_.ros_topic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_ros_topic(::v1::model::ROSTopic* ros_topic) {
  clear_configuration();
  if (ros_topic) {
    set_has_ros_topic();
    configuration_.ros_topic_ = ros_topic;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.ros_topic)
}
inline ::v1::model::ROSTopic* StreamConfiguration::_internal_mutable_ros_topic() {
  if (!_internal_has_ros_topic()) {
    clear_configuration();
    set_has_ros_topic();
    configuration_.ros_topic_ = CreateMaybeMessage< ::v1::model::ROSTopic >(GetArenaForAllocation());
  }
  return configuration_.ros_topic_;
}
inline ::v1::model::ROSTopic* StreamConfiguration::mutable_ros_topic() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.ros_topic)
  return _internal_mutable_ros_topic();
}

// .v1.model.ROSLocalization ros_localization = 4 [json_name = "rosLocalization"];
inline bool StreamConfiguration::_internal_has_ros_localization() const {
  return configuration_case() == kRosLocalization;
}
inline bool StreamConfiguration::has_ros_localization() const {
  return _internal_has_ros_localization();
}
inline void StreamConfiguration::set_has_ros_localization() {
  _oneof_case_[0] = kRosLocalization;
}
inline ::v1::model::ROSLocalization* StreamConfiguration::release_ros_localization() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.ros_localization)
  if (_internal_has_ros_localization()) {
    clear_has_configuration();
      ::v1::model::ROSLocalization* temp = configuration_.ros_localization_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.ros_localization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::ROSLocalization& StreamConfiguration::_internal_ros_localization() const {
  return _internal_has_ros_localization()
      ? *configuration_.ros_localization_
      : reinterpret_cast< ::v1::model::ROSLocalization&>(::v1::model::_ROSLocalization_default_instance_);
}
inline const ::v1::model::ROSLocalization& StreamConfiguration::ros_localization() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.ros_localization)
  return _internal_ros_localization();
}
inline ::v1::model::ROSLocalization* StreamConfiguration::unsafe_arena_release_ros_localization() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.ros_localization)
  if (_internal_has_ros_localization()) {
    clear_has_configuration();
    ::v1::model::ROSLocalization* temp = configuration_.ros_localization_;
    configuration_.ros_localization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_ros_localization(::v1::model::ROSLocalization* ros_localization) {
  clear_configuration();
  if (ros_localization) {
    set_has_ros_localization();
    configuration_.ros_localization_ = ros_localization;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.ros_localization)
}
inline ::v1::model::ROSLocalization* StreamConfiguration::_internal_mutable_ros_localization() {
  if (!_internal_has_ros_localization()) {
    clear_configuration();
    set_has_ros_localization();
    configuration_.ros_localization_ = CreateMaybeMessage< ::v1::model::ROSLocalization >(GetArenaForAllocation());
  }
  return configuration_.ros_localization_;
}
inline ::v1::model::ROSLocalization* StreamConfiguration::mutable_ros_localization() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.ros_localization)
  return _internal_mutable_ros_localization();
}

// .v1.model.DirectoryWatch directory_watch = 5 [json_name = "directoryWatch"];
inline bool StreamConfiguration::_internal_has_directory_watch() const {
  return configuration_case() == kDirectoryWatch;
}
inline bool StreamConfiguration::has_directory_watch() const {
  return _internal_has_directory_watch();
}
inline void StreamConfiguration::set_has_directory_watch() {
  _oneof_case_[0] = kDirectoryWatch;
}
inline void StreamConfiguration::clear_directory_watch() {
  if (_internal_has_directory_watch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete configuration_.directory_watch_;
    }
    clear_has_configuration();
  }
}
inline ::v1::model::DirectoryWatch* StreamConfiguration::release_directory_watch() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.directory_watch)
  if (_internal_has_directory_watch()) {
    clear_has_configuration();
      ::v1::model::DirectoryWatch* temp = configuration_.directory_watch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.directory_watch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::DirectoryWatch& StreamConfiguration::_internal_directory_watch() const {
  return _internal_has_directory_watch()
      ? *configuration_.directory_watch_
      : reinterpret_cast< ::v1::model::DirectoryWatch&>(::v1::model::_DirectoryWatch_default_instance_);
}
inline const ::v1::model::DirectoryWatch& StreamConfiguration::directory_watch() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.directory_watch)
  return _internal_directory_watch();
}
inline ::v1::model::DirectoryWatch* StreamConfiguration::unsafe_arena_release_directory_watch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.directory_watch)
  if (_internal_has_directory_watch()) {
    clear_has_configuration();
    ::v1::model::DirectoryWatch* temp = configuration_.directory_watch_;
    configuration_.directory_watch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_directory_watch(::v1::model::DirectoryWatch* directory_watch) {
  clear_configuration();
  if (directory_watch) {
    set_has_directory_watch();
    configuration_.directory_watch_ = directory_watch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.directory_watch)
}
inline ::v1::model::DirectoryWatch* StreamConfiguration::_internal_mutable_directory_watch() {
  if (!_internal_has_directory_watch()) {
    clear_configuration();
    set_has_directory_watch();
    configuration_.directory_watch_ = CreateMaybeMessage< ::v1::model::DirectoryWatch >(GetArenaForAllocation());
  }
  return configuration_.directory_watch_;
}
inline ::v1::model::DirectoryWatch* StreamConfiguration::mutable_directory_watch() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.directory_watch)
  return _internal_mutable_directory_watch();
}

// .v1.model.FileTail file_tail = 6 [json_name = "fileTail"];
inline bool StreamConfiguration::_internal_has_file_tail() const {
  return configuration_case() == kFileTail;
}
inline bool StreamConfiguration::has_file_tail() const {
  return _internal_has_file_tail();
}
inline void StreamConfiguration::set_has_file_tail() {
  _oneof_case_[0] = kFileTail;
}
inline void StreamConfiguration::clear_file_tail() {
  if (_internal_has_file_tail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete configuration_.file_tail_;
    }
    clear_has_configuration();
  }
}
inline ::v1::model::FileTail* StreamConfiguration::release_file_tail() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.file_tail)
  if (_internal_has_file_tail()) {
    clear_has_configuration();
      ::v1::model::FileTail* temp = configuration_.file_tail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.file_tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::FileTail& StreamConfiguration::_internal_file_tail() const {
  return _internal_has_file_tail()
      ? *configuration_.file_tail_
      : reinterpret_cast< ::v1::model::FileTail&>(::v1::model::_FileTail_default_instance_);
}
inline const ::v1::model::FileTail& StreamConfiguration::file_tail() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.file_tail)
  return _internal_file_tail();
}
inline ::v1::model::FileTail* StreamConfiguration::unsafe_arena_release_file_tail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.file_tail)
  if (_internal_has_file_tail()) {
    clear_has_configuration();
    ::v1::model::FileTail* temp = configuration_.file_tail_;
    configuration_.file_tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_file_tail(::v1::model::FileTail* file_tail) {
  clear_configuration();
  if (file_tail) {
    set_has_file_tail();
    configuration_.file_tail_ = file_tail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.file_tail)
}
inline ::v1::model::FileTail* StreamConfiguration::_internal_mutable_file_tail() {
  if (!_internal_has_file_tail()) {
    clear_configuration();
    set_has_file_tail();
    configuration_.file_tail_ = CreateMaybeMessage< ::v1::model::FileTail >(GetArenaForAllocation());
  }
  return configuration_.file_tail_;
}
inline ::v1::model::FileTail* StreamConfiguration::mutable_file_tail() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.file_tail)
  return _internal_mutable_file_tail();
}

// .v1.model.ROSTransformTree ros_transform_tree = 7 [json_name = "rosTransformTree"];
inline bool StreamConfiguration::_internal_has_ros_transform_tree() const {
  return configuration_case() == kRosTransformTree;
}
inline bool StreamConfiguration::has_ros_transform_tree() const {
  return _internal_has_ros_transform_tree();
}
inline void StreamConfiguration::set_has_ros_transform_tree() {
  _oneof_case_[0] = kRosTransformTree;
}
inline ::v1::model::ROSTransformTree* StreamConfiguration::release_ros_transform_tree() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.ros_transform_tree)
  if (_internal_has_ros_transform_tree()) {
    clear_has_configuration();
      ::v1::model::ROSTransformTree* temp = configuration_.ros_transform_tree_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.ros_transform_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::ROSTransformTree& StreamConfiguration::_internal_ros_transform_tree() const {
  return _internal_has_ros_transform_tree()
      ? *configuration_.ros_transform_tree_
      : reinterpret_cast< ::v1::model::ROSTransformTree&>(::v1::model::_ROSTransformTree_default_instance_);
}
inline const ::v1::model::ROSTransformTree& StreamConfiguration::ros_transform_tree() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.ros_transform_tree)
  return _internal_ros_transform_tree();
}
inline ::v1::model::ROSTransformTree* StreamConfiguration::unsafe_arena_release_ros_transform_tree() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.ros_transform_tree)
  if (_internal_has_ros_transform_tree()) {
    clear_has_configuration();
    ::v1::model::ROSTransformTree* temp = configuration_.ros_transform_tree_;
    configuration_.ros_transform_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_ros_transform_tree(::v1::model::ROSTransformTree* ros_transform_tree) {
  clear_configuration();
  if (ros_transform_tree) {
    set_has_ros_transform_tree();
    configuration_.ros_transform_tree_ = ros_transform_tree;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.ros_transform_tree)
}
inline ::v1::model::ROSTransformTree* StreamConfiguration::_internal_mutable_ros_transform_tree() {
  if (!_internal_has_ros_transform_tree()) {
    clear_configuration();
    set_has_ros_transform_tree();
    configuration_.ros_transform_tree_ = CreateMaybeMessage< ::v1::model::ROSTransformTree >(GetArenaForAllocation());
  }
  return configuration_.ros_transform_tree_;
}
inline ::v1::model::ROSTransformTree* StreamConfiguration::mutable_ros_transform_tree() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.ros_transform_tree)
  return _internal_mutable_ros_transform_tree();
}

// .v1.model.Custom custom = 9 [json_name = "custom"];
inline bool StreamConfiguration::_internal_has_custom() const {
  return configuration_case() == kCustom;
}
inline bool StreamConfiguration::has_custom() const {
  return _internal_has_custom();
}
inline void StreamConfiguration::set_has_custom() {
  _oneof_case_[0] = kCustom;
}
inline void StreamConfiguration::clear_custom() {
  if (_internal_has_custom()) {
    if (GetArenaForAllocation() == nullptr) {
      delete configuration_.custom_;
    }
    clear_has_configuration();
  }
}
inline ::v1::model::Custom* StreamConfiguration::release_custom() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.custom)
  if (_internal_has_custom()) {
    clear_has_configuration();
      ::v1::model::Custom* temp = configuration_.custom_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Custom& StreamConfiguration::_internal_custom() const {
  return _internal_has_custom()
      ? *configuration_.custom_
      : reinterpret_cast< ::v1::model::Custom&>(::v1::model::_Custom_default_instance_);
}
inline const ::v1::model::Custom& StreamConfiguration::custom() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.custom)
  return _internal_custom();
}
inline ::v1::model::Custom* StreamConfiguration::unsafe_arena_release_custom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.custom)
  if (_internal_has_custom()) {
    clear_has_configuration();
    ::v1::model::Custom* temp = configuration_.custom_;
    configuration_.custom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_custom(::v1::model::Custom* custom) {
  clear_configuration();
  if (custom) {
    set_has_custom();
    configuration_.custom_ = custom;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.custom)
}
inline ::v1::model::Custom* StreamConfiguration::_internal_mutable_custom() {
  if (!_internal_has_custom()) {
    clear_configuration();
    set_has_custom();
    configuration_.custom_ = CreateMaybeMessage< ::v1::model::Custom >(GetArenaForAllocation());
  }
  return configuration_.custom_;
}
inline ::v1::model::Custom* StreamConfiguration::mutable_custom() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.custom)
  return _internal_mutable_custom();
}

// .v1.model.Hardware hardware = 10 [json_name = "hardware"];
inline bool StreamConfiguration::_internal_has_hardware() const {
  return configuration_case() == kHardware;
}
inline bool StreamConfiguration::has_hardware() const {
  return _internal_has_hardware();
}
inline void StreamConfiguration::set_has_hardware() {
  _oneof_case_[0] = kHardware;
}
inline void StreamConfiguration::clear_hardware() {
  if (_internal_has_hardware()) {
    if (GetArenaForAllocation() == nullptr) {
      delete configuration_.hardware_;
    }
    clear_has_configuration();
  }
}
inline ::v1::model::Hardware* StreamConfiguration::release_hardware() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.hardware)
  if (_internal_has_hardware()) {
    clear_has_configuration();
      ::v1::model::Hardware* temp = configuration_.hardware_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    configuration_.hardware_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Hardware& StreamConfiguration::_internal_hardware() const {
  return _internal_has_hardware()
      ? *configuration_.hardware_
      : reinterpret_cast< ::v1::model::Hardware&>(::v1::model::_Hardware_default_instance_);
}
inline const ::v1::model::Hardware& StreamConfiguration::hardware() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.hardware)
  return _internal_hardware();
}
inline ::v1::model::Hardware* StreamConfiguration::unsafe_arena_release_hardware() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.StreamConfiguration.hardware)
  if (_internal_has_hardware()) {
    clear_has_configuration();
    ::v1::model::Hardware* temp = configuration_.hardware_;
    configuration_.hardware_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StreamConfiguration::unsafe_arena_set_allocated_hardware(::v1::model::Hardware* hardware) {
  clear_configuration();
  if (hardware) {
    set_has_hardware();
    configuration_.hardware_ = hardware;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.hardware)
}
inline ::v1::model::Hardware* StreamConfiguration::_internal_mutable_hardware() {
  if (!_internal_has_hardware()) {
    clear_configuration();
    set_has_hardware();
    configuration_.hardware_ = CreateMaybeMessage< ::v1::model::Hardware >(GetArenaForAllocation());
  }
  return configuration_.hardware_;
}
inline ::v1::model::Hardware* StreamConfiguration::mutable_hardware() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.hardware)
  return _internal_mutable_hardware();
}

// .google.protobuf.DoubleValue throttle_hz = 8 [json_name = "throttleHz"];
inline bool StreamConfiguration::_internal_has_throttle_hz() const {
  return this != internal_default_instance() && throttle_hz_ != nullptr;
}
inline bool StreamConfiguration::has_throttle_hz() const {
  return _internal_has_throttle_hz();
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& StreamConfiguration::_internal_throttle_hz() const {
  const PROTOBUF_NAMESPACE_ID::DoubleValue* p = throttle_hz_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::DoubleValue&>(
      PROTOBUF_NAMESPACE_ID::_DoubleValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::DoubleValue& StreamConfiguration::throttle_hz() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.throttle_hz)
  return _internal_throttle_hz();
}
inline void StreamConfiguration::unsafe_arena_set_allocated_throttle_hz(
    PROTOBUF_NAMESPACE_ID::DoubleValue* throttle_hz) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(throttle_hz_);
  }
  throttle_hz_ = throttle_hz;
  if (throttle_hz) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.throttle_hz)
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* StreamConfiguration::release_throttle_hz() {
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = throttle_hz_;
  throttle_hz_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* StreamConfiguration::unsafe_arena_release_throttle_hz() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.throttle_hz)
  
  PROTOBUF_NAMESPACE_ID::DoubleValue* temp = throttle_hz_;
  throttle_hz_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* StreamConfiguration::_internal_mutable_throttle_hz() {
  
  if (throttle_hz_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::DoubleValue>(GetArenaForAllocation());
    throttle_hz_ = p;
  }
  return throttle_hz_;
}
inline PROTOBUF_NAMESPACE_ID::DoubleValue* StreamConfiguration::mutable_throttle_hz() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.throttle_hz)
  return _internal_mutable_throttle_hz();
}
inline void StreamConfiguration::set_allocated_throttle_hz(PROTOBUF_NAMESPACE_ID::DoubleValue* throttle_hz) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(throttle_hz_);
  }
  if (throttle_hz) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(throttle_hz));
    if (message_arena != submessage_arena) {
      throttle_hz = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, throttle_hz, submessage_arena);
    }
    
  } else {
    
  }
  throttle_hz_ = throttle_hz;
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamConfiguration.throttle_hz)
}

// .google.protobuf.BoolValue disabled = 19 [json_name = "disabled"];
inline bool StreamConfiguration::_internal_has_disabled() const {
  return this != internal_default_instance() && disabled_ != nullptr;
}
inline bool StreamConfiguration::has_disabled() const {
  return _internal_has_disabled();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& StreamConfiguration::_internal_disabled() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = disabled_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& StreamConfiguration::disabled() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.disabled)
  return _internal_disabled();
}
inline void StreamConfiguration::unsafe_arena_set_allocated_disabled(
    PROTOBUF_NAMESPACE_ID::BoolValue* disabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disabled_);
  }
  disabled_ = disabled;
  if (disabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.disabled)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::release_disabled() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = disabled_;
  disabled_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::unsafe_arena_release_disabled() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.disabled)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = disabled_;
  disabled_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::_internal_mutable_disabled() {
  
  if (disabled_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    disabled_ = p;
  }
  return disabled_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::mutable_disabled() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.disabled)
  return _internal_mutable_disabled();
}
inline void StreamConfiguration::set_allocated_disabled(PROTOBUF_NAMESPACE_ID::BoolValue* disabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(disabled_);
  }
  if (disabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(disabled));
    if (message_arena != submessage_arena) {
      disabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, disabled, submessage_arena);
    }
    
  } else {
    
  }
  disabled_ = disabled;
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamConfiguration.disabled)
}

// .google.protobuf.BoolValue on_demand = 20 [json_name = "onDemand"];
inline bool StreamConfiguration::_internal_has_on_demand() const {
  return this != internal_default_instance() && on_demand_ != nullptr;
}
inline bool StreamConfiguration::has_on_demand() const {
  return _internal_has_on_demand();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& StreamConfiguration::_internal_on_demand() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = on_demand_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& StreamConfiguration::on_demand() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.on_demand)
  return _internal_on_demand();
}
inline void StreamConfiguration::unsafe_arena_set_allocated_on_demand(
    PROTOBUF_NAMESPACE_ID::BoolValue* on_demand) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(on_demand_);
  }
  on_demand_ = on_demand;
  if (on_demand) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.on_demand)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::release_on_demand() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = on_demand_;
  on_demand_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::unsafe_arena_release_on_demand() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.on_demand)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = on_demand_;
  on_demand_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::_internal_mutable_on_demand() {
  
  if (on_demand_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    on_demand_ = p;
  }
  return on_demand_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamConfiguration::mutable_on_demand() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.on_demand)
  return _internal_mutable_on_demand();
}
inline void StreamConfiguration::set_allocated_on_demand(PROTOBUF_NAMESPACE_ID::BoolValue* on_demand) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(on_demand_);
  }
  if (on_demand) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(on_demand));
    if (message_arena != submessage_arena) {
      on_demand = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, on_demand, submessage_arena);
    }
    
  } else {
    
  }
  on_demand_ = on_demand;
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamConfiguration.on_demand)
}

// .v1.model.StreamTransformConfiguration transform = 21 [json_name = "transform"];
inline bool StreamConfiguration::_internal_has_transform() const {
  return this != internal_default_instance() && transform_ != nullptr;
}
inline bool StreamConfiguration::has_transform() const {
  return _internal_has_transform();
}
inline void StreamConfiguration::clear_transform() {
  if (GetArenaForAllocation() == nullptr && transform_ != nullptr) {
    delete transform_;
  }
  transform_ = nullptr;
}
inline const ::v1::model::StreamTransformConfiguration& StreamConfiguration::_internal_transform() const {
  const ::v1::model::StreamTransformConfiguration* p = transform_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::StreamTransformConfiguration&>(
      ::v1::model::_StreamTransformConfiguration_default_instance_);
}
inline const ::v1::model::StreamTransformConfiguration& StreamConfiguration::transform() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.transform)
  return _internal_transform();
}
inline void StreamConfiguration::unsafe_arena_set_allocated_transform(
    ::v1::model::StreamTransformConfiguration* transform) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transform_);
  }
  transform_ = transform;
  if (transform) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamConfiguration.transform)
}
inline ::v1::model::StreamTransformConfiguration* StreamConfiguration::release_transform() {
  
  ::v1::model::StreamTransformConfiguration* temp = transform_;
  transform_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::StreamTransformConfiguration* StreamConfiguration::unsafe_arena_release_transform() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.transform)
  
  ::v1::model::StreamTransformConfiguration* temp = transform_;
  transform_ = nullptr;
  return temp;
}
inline ::v1::model::StreamTransformConfiguration* StreamConfiguration::_internal_mutable_transform() {
  
  if (transform_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::StreamTransformConfiguration>(GetArenaForAllocation());
    transform_ = p;
  }
  return transform_;
}
inline ::v1::model::StreamTransformConfiguration* StreamConfiguration::mutable_transform() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.transform)
  return _internal_mutable_transform();
}
inline void StreamConfiguration::set_allocated_transform(::v1::model::StreamTransformConfiguration* transform) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transform_;
  }
  if (transform) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::StreamTransformConfiguration>::GetOwningArena(transform);
    if (message_arena != submessage_arena) {
      transform = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transform, submessage_arena);
    }
    
  } else {
    
  }
  transform_ = transform;
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamConfiguration.transform)
}

// string quality = 22 [json_name = "quality"];
inline void StreamConfiguration::clear_quality() {
  quality_.ClearToEmpty();
}
inline const std::string& StreamConfiguration::quality() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamConfiguration.quality)
  return _internal_quality();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamConfiguration::set_quality(ArgT0&& arg0, ArgT... args) {
 
 quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.StreamConfiguration.quality)
}
inline std::string* StreamConfiguration::mutable_quality() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamConfiguration.quality)
  return _internal_mutable_quality();
}
inline const std::string& StreamConfiguration::_internal_quality() const {
  return quality_.Get();
}
inline void StreamConfiguration::_internal_set_quality(const std::string& value) {
  
  quality_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StreamConfiguration::_internal_mutable_quality() {
  
  return quality_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StreamConfiguration::release_quality() {
  // @@protoc_insertion_point(field_release:v1.model.StreamConfiguration.quality)
  return quality_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StreamConfiguration::set_allocated_quality(std::string* quality) {
  if (quality != nullptr) {
    
  } else {
    
  }
  quality_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quality,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamConfiguration.quality)
}

inline bool StreamConfiguration::has_configuration() const {
  return configuration_case() != CONFIGURATION_NOT_SET;
}
inline void StreamConfiguration::clear_has_configuration() {
  _oneof_case_[0] = CONFIGURATION_NOT_SET;
}
inline StreamConfiguration::ConfigurationCase StreamConfiguration::configuration_case() const {
  return StreamConfiguration::ConfigurationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamTransformConfiguration

// .google.protobuf.BoolValue video_encoding_enabled = 1 [json_name = "videoEncodingEnabled"];
inline bool StreamTransformConfiguration::_internal_has_video_encoding_enabled() const {
  return this != internal_default_instance() && video_encoding_enabled_ != nullptr;
}
inline bool StreamTransformConfiguration::has_video_encoding_enabled() const {
  return _internal_has_video_encoding_enabled();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& StreamTransformConfiguration::_internal_video_encoding_enabled() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = video_encoding_enabled_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& StreamTransformConfiguration::video_encoding_enabled() const {
  // @@protoc_insertion_point(field_get:v1.model.StreamTransformConfiguration.video_encoding_enabled)
  return _internal_video_encoding_enabled();
}
inline void StreamTransformConfiguration::unsafe_arena_set_allocated_video_encoding_enabled(
    PROTOBUF_NAMESPACE_ID::BoolValue* video_encoding_enabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_encoding_enabled_);
  }
  video_encoding_enabled_ = video_encoding_enabled;
  if (video_encoding_enabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.StreamTransformConfiguration.video_encoding_enabled)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamTransformConfiguration::release_video_encoding_enabled() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = video_encoding_enabled_;
  video_encoding_enabled_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamTransformConfiguration::unsafe_arena_release_video_encoding_enabled() {
  // @@protoc_insertion_point(field_release:v1.model.StreamTransformConfiguration.video_encoding_enabled)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = video_encoding_enabled_;
  video_encoding_enabled_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamTransformConfiguration::_internal_mutable_video_encoding_enabled() {
  
  if (video_encoding_enabled_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    video_encoding_enabled_ = p;
  }
  return video_encoding_enabled_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* StreamTransformConfiguration::mutable_video_encoding_enabled() {
  // @@protoc_insertion_point(field_mutable:v1.model.StreamTransformConfiguration.video_encoding_enabled)
  return _internal_mutable_video_encoding_enabled();
}
inline void StreamTransformConfiguration::set_allocated_video_encoding_enabled(PROTOBUF_NAMESPACE_ID::BoolValue* video_encoding_enabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_encoding_enabled_);
  }
  if (video_encoding_enabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_encoding_enabled));
    if (message_arena != submessage_arena) {
      video_encoding_enabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_encoding_enabled, submessage_arena);
    }
    
  } else {
    
  }
  video_encoding_enabled_ = video_encoding_enabled;
  // @@protoc_insertion_point(field_set_allocated:v1.model.StreamTransformConfiguration.video_encoding_enabled)
}

// -------------------------------------------------------------------

// BlobData

// string data = 1 [json_name = "data"];
inline void BlobData::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& BlobData::data() const {
  // @@protoc_insertion_point(field_get:v1.model.BlobData.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlobData::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.BlobData.data)
}
inline std::string* BlobData::mutable_data() {
  // @@protoc_insertion_point(field_mutable:v1.model.BlobData.data)
  return _internal_mutable_data();
}
inline const std::string& BlobData::_internal_data() const {
  return data_.Get();
}
inline void BlobData::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlobData::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlobData::release_data() {
  // @@protoc_insertion_point(field_release:v1.model.BlobData.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlobData::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.BlobData.data)
}

// -------------------------------------------------------------------

// Diagnostics

// .google.protobuf.BoolValue report_logs = 1 [json_name = "reportLogs"];
inline bool Diagnostics::_internal_has_report_logs() const {
  return this != internal_default_instance() && report_logs_ != nullptr;
}
inline bool Diagnostics::has_report_logs() const {
  return _internal_has_report_logs();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& Diagnostics::_internal_report_logs() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = report_logs_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& Diagnostics::report_logs() const {
  // @@protoc_insertion_point(field_get:v1.model.Diagnostics.report_logs)
  return _internal_report_logs();
}
inline void Diagnostics::unsafe_arena_set_allocated_report_logs(
    PROTOBUF_NAMESPACE_ID::BoolValue* report_logs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_logs_);
  }
  report_logs_ = report_logs;
  if (report_logs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Diagnostics.report_logs)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::release_report_logs() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = report_logs_;
  report_logs_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::unsafe_arena_release_report_logs() {
  // @@protoc_insertion_point(field_release:v1.model.Diagnostics.report_logs)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = report_logs_;
  report_logs_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::_internal_mutable_report_logs() {
  
  if (report_logs_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    report_logs_ = p;
  }
  return report_logs_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::mutable_report_logs() {
  // @@protoc_insertion_point(field_mutable:v1.model.Diagnostics.report_logs)
  return _internal_mutable_report_logs();
}
inline void Diagnostics::set_allocated_report_logs(PROTOBUF_NAMESPACE_ID::BoolValue* report_logs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_logs_);
  }
  if (report_logs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_logs));
    if (message_arena != submessage_arena) {
      report_logs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report_logs, submessage_arena);
    }
    
  } else {
    
  }
  report_logs_ = report_logs;
  // @@protoc_insertion_point(field_set_allocated:v1.model.Diagnostics.report_logs)
}

// .google.protobuf.BoolValue report_metrics = 2 [json_name = "reportMetrics"];
inline bool Diagnostics::_internal_has_report_metrics() const {
  return this != internal_default_instance() && report_metrics_ != nullptr;
}
inline bool Diagnostics::has_report_metrics() const {
  return _internal_has_report_metrics();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& Diagnostics::_internal_report_metrics() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = report_metrics_;
  return p != nullptr ? *p : reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue&>(
      PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& Diagnostics::report_metrics() const {
  // @@protoc_insertion_point(field_get:v1.model.Diagnostics.report_metrics)
  return _internal_report_metrics();
}
inline void Diagnostics::unsafe_arena_set_allocated_report_metrics(
    PROTOBUF_NAMESPACE_ID::BoolValue* report_metrics) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_metrics_);
  }
  report_metrics_ = report_metrics;
  if (report_metrics) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Diagnostics.report_metrics)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::release_report_metrics() {
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = report_metrics_;
  report_metrics_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::unsafe_arena_release_report_metrics() {
  // @@protoc_insertion_point(field_release:v1.model.Diagnostics.report_metrics)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = report_metrics_;
  report_metrics_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::_internal_mutable_report_metrics() {
  
  if (report_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    report_metrics_ = p;
  }
  return report_metrics_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* Diagnostics::mutable_report_metrics() {
  // @@protoc_insertion_point(field_mutable:v1.model.Diagnostics.report_metrics)
  return _internal_mutable_report_metrics();
}
inline void Diagnostics::set_allocated_report_metrics(PROTOBUF_NAMESPACE_ID::BoolValue* report_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_metrics_);
  }
  if (report_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(report_metrics));
    if (message_arena != submessage_arena) {
      report_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, report_metrics, submessage_arena);
    }
    
  } else {
    
  }
  report_metrics_ = report_metrics;
  // @@protoc_insertion_point(field_set_allocated:v1.model.Diagnostics.report_metrics)
}

// -------------------------------------------------------------------

// Custom

// -------------------------------------------------------------------

// Hardware

// string hw_descriptor = 1 [json_name = "hwDescriptor"];
inline void Hardware::clear_hw_descriptor() {
  hw_descriptor_.ClearToEmpty();
}
inline const std::string& Hardware::hw_descriptor() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.hw_descriptor)
  return _internal_hw_descriptor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hardware::set_hw_descriptor(ArgT0&& arg0, ArgT... args) {
 
 hw_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Hardware.hw_descriptor)
}
inline std::string* Hardware::mutable_hw_descriptor() {
  // @@protoc_insertion_point(field_mutable:v1.model.Hardware.hw_descriptor)
  return _internal_mutable_hw_descriptor();
}
inline const std::string& Hardware::_internal_hw_descriptor() const {
  return hw_descriptor_.Get();
}
inline void Hardware::_internal_set_hw_descriptor(const std::string& value) {
  
  hw_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hardware::_internal_mutable_hw_descriptor() {
  
  return hw_descriptor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hardware::release_hw_descriptor() {
  // @@protoc_insertion_point(field_release:v1.model.Hardware.hw_descriptor)
  return hw_descriptor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hardware::set_allocated_hw_descriptor(std::string* hw_descriptor) {
  if (hw_descriptor != nullptr) {
    
  } else {
    
  }
  hw_descriptor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hw_descriptor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Hardware.hw_descriptor)
}

// string audio_hw_descriptor = 3 [json_name = "audioHwDescriptor"];
inline void Hardware::clear_audio_hw_descriptor() {
  audio_hw_descriptor_.ClearToEmpty();
}
inline const std::string& Hardware::audio_hw_descriptor() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.audio_hw_descriptor)
  return _internal_audio_hw_descriptor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hardware::set_audio_hw_descriptor(ArgT0&& arg0, ArgT... args) {
 
 audio_hw_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Hardware.audio_hw_descriptor)
}
inline std::string* Hardware::mutable_audio_hw_descriptor() {
  // @@protoc_insertion_point(field_mutable:v1.model.Hardware.audio_hw_descriptor)
  return _internal_mutable_audio_hw_descriptor();
}
inline const std::string& Hardware::_internal_audio_hw_descriptor() const {
  return audio_hw_descriptor_.Get();
}
inline void Hardware::_internal_set_audio_hw_descriptor(const std::string& value) {
  
  audio_hw_descriptor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hardware::_internal_mutable_audio_hw_descriptor() {
  
  return audio_hw_descriptor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hardware::release_audio_hw_descriptor() {
  // @@protoc_insertion_point(field_release:v1.model.Hardware.audio_hw_descriptor)
  return audio_hw_descriptor_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hardware::set_allocated_audio_hw_descriptor(std::string* audio_hw_descriptor) {
  if (audio_hw_descriptor != nullptr) {
    
  } else {
    
  }
  audio_hw_descriptor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), audio_hw_descriptor,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Hardware.audio_hw_descriptor)
}

// string hardware_type = 4 [json_name = "hardwareType"];
inline void Hardware::clear_hardware_type() {
  hardware_type_.ClearToEmpty();
}
inline const std::string& Hardware::hardware_type() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.hardware_type)
  return _internal_hardware_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hardware::set_hardware_type(ArgT0&& arg0, ArgT... args) {
 
 hardware_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Hardware.hardware_type)
}
inline std::string* Hardware::mutable_hardware_type() {
  // @@protoc_insertion_point(field_mutable:v1.model.Hardware.hardware_type)
  return _internal_mutable_hardware_type();
}
inline const std::string& Hardware::_internal_hardware_type() const {
  return hardware_type_.Get();
}
inline void Hardware::_internal_set_hardware_type(const std::string& value) {
  
  hardware_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hardware::_internal_mutable_hardware_type() {
  
  return hardware_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hardware::release_hardware_type() {
  // @@protoc_insertion_point(field_release:v1.model.Hardware.hardware_type)
  return hardware_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hardware::set_allocated_hardware_type(std::string* hardware_type) {
  if (hardware_type != nullptr) {
    
  } else {
    
  }
  hardware_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hardware_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Hardware.hardware_type)
}

// bool rtsp_encoding_needed = 5 [json_name = "rtspEncodingNeeded"];
inline void Hardware::clear_rtsp_encoding_needed() {
  rtsp_encoding_needed_ = false;
}
inline bool Hardware::_internal_rtsp_encoding_needed() const {
  return rtsp_encoding_needed_;
}
inline bool Hardware::rtsp_encoding_needed() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.rtsp_encoding_needed)
  return _internal_rtsp_encoding_needed();
}
inline void Hardware::_internal_set_rtsp_encoding_needed(bool value) {
  
  rtsp_encoding_needed_ = value;
}
inline void Hardware::set_rtsp_encoding_needed(bool value) {
  _internal_set_rtsp_encoding_needed(value);
  // @@protoc_insertion_point(field_set:v1.model.Hardware.rtsp_encoding_needed)
}

// bool is_onvif = 6 [json_name = "isOnvif"];
inline void Hardware::clear_is_onvif() {
  is_onvif_ = false;
}
inline bool Hardware::_internal_is_onvif() const {
  return is_onvif_;
}
inline bool Hardware::is_onvif() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.is_onvif)
  return _internal_is_onvif();
}
inline void Hardware::_internal_set_is_onvif(bool value) {
  
  is_onvif_ = value;
}
inline void Hardware::set_is_onvif(bool value) {
  _internal_set_is_onvif(value);
  // @@protoc_insertion_point(field_set:v1.model.Hardware.is_onvif)
}

// string ip_cam_username = 7 [json_name = "ipCamUsername"];
inline void Hardware::clear_ip_cam_username() {
  ip_cam_username_.ClearToEmpty();
}
inline const std::string& Hardware::ip_cam_username() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.ip_cam_username)
  return _internal_ip_cam_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hardware::set_ip_cam_username(ArgT0&& arg0, ArgT... args) {
 
 ip_cam_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Hardware.ip_cam_username)
}
inline std::string* Hardware::mutable_ip_cam_username() {
  // @@protoc_insertion_point(field_mutable:v1.model.Hardware.ip_cam_username)
  return _internal_mutable_ip_cam_username();
}
inline const std::string& Hardware::_internal_ip_cam_username() const {
  return ip_cam_username_.Get();
}
inline void Hardware::_internal_set_ip_cam_username(const std::string& value) {
  
  ip_cam_username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hardware::_internal_mutable_ip_cam_username() {
  
  return ip_cam_username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hardware::release_ip_cam_username() {
  // @@protoc_insertion_point(field_release:v1.model.Hardware.ip_cam_username)
  return ip_cam_username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hardware::set_allocated_ip_cam_username(std::string* ip_cam_username) {
  if (ip_cam_username != nullptr) {
    
  } else {
    
  }
  ip_cam_username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_cam_username,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Hardware.ip_cam_username)
}

// string ip_cam_password = 8 [json_name = "ipCamPassword"];
inline void Hardware::clear_ip_cam_password() {
  ip_cam_password_.ClearToEmpty();
}
inline const std::string& Hardware::ip_cam_password() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.ip_cam_password)
  return _internal_ip_cam_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hardware::set_ip_cam_password(ArgT0&& arg0, ArgT... args) {
 
 ip_cam_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Hardware.ip_cam_password)
}
inline std::string* Hardware::mutable_ip_cam_password() {
  // @@protoc_insertion_point(field_mutable:v1.model.Hardware.ip_cam_password)
  return _internal_mutable_ip_cam_password();
}
inline const std::string& Hardware::_internal_ip_cam_password() const {
  return ip_cam_password_.Get();
}
inline void Hardware::_internal_set_ip_cam_password(const std::string& value) {
  
  ip_cam_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Hardware::_internal_mutable_ip_cam_password() {
  
  return ip_cam_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Hardware::release_ip_cam_password() {
  // @@protoc_insertion_point(field_release:v1.model.Hardware.ip_cam_password)
  return ip_cam_password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Hardware::set_allocated_ip_cam_password(std::string* ip_cam_password) {
  if (ip_cam_password != nullptr) {
    
  } else {
    
  }
  ip_cam_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip_cam_password,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Hardware.ip_cam_password)
}

// bool overlay_clock = 9 [json_name = "overlayClock"];
inline void Hardware::clear_overlay_clock() {
  overlay_clock_ = false;
}
inline bool Hardware::_internal_overlay_clock() const {
  return overlay_clock_;
}
inline bool Hardware::overlay_clock() const {
  // @@protoc_insertion_point(field_get:v1.model.Hardware.overlay_clock)
  return _internal_overlay_clock();
}
inline void Hardware::_internal_set_overlay_clock(bool value) {
  
  overlay_clock_ = value;
}
inline void Hardware::set_overlay_clock(bool value) {
  _internal_set_overlay_clock(value);
  // @@protoc_insertion_point(field_set:v1.model.Hardware.overlay_clock)
}

// -------------------------------------------------------------------

// DirectoryWatch

// string directory = 1 [json_name = "directory"];
inline void DirectoryWatch::clear_directory() {
  directory_.ClearToEmpty();
}
inline const std::string& DirectoryWatch::directory() const {
  // @@protoc_insertion_point(field_get:v1.model.DirectoryWatch.directory)
  return _internal_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectoryWatch::set_directory(ArgT0&& arg0, ArgT... args) {
 
 directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.DirectoryWatch.directory)
}
inline std::string* DirectoryWatch::mutable_directory() {
  // @@protoc_insertion_point(field_mutable:v1.model.DirectoryWatch.directory)
  return _internal_mutable_directory();
}
inline const std::string& DirectoryWatch::_internal_directory() const {
  return directory_.Get();
}
inline void DirectoryWatch::_internal_set_directory(const std::string& value) {
  
  directory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectoryWatch::_internal_mutable_directory() {
  
  return directory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectoryWatch::release_directory() {
  // @@protoc_insertion_point(field_release:v1.model.DirectoryWatch.directory)
  return directory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectoryWatch::set_allocated_directory(std::string* directory) {
  if (directory != nullptr) {
    
  } else {
    
  }
  directory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), directory,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.DirectoryWatch.directory)
}

// string extension = 2 [json_name = "extension"];
inline void DirectoryWatch::clear_extension() {
  extension_.ClearToEmpty();
}
inline const std::string& DirectoryWatch::extension() const {
  // @@protoc_insertion_point(field_get:v1.model.DirectoryWatch.extension)
  return _internal_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DirectoryWatch::set_extension(ArgT0&& arg0, ArgT... args) {
 
 extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.DirectoryWatch.extension)
}
inline std::string* DirectoryWatch::mutable_extension() {
  // @@protoc_insertion_point(field_mutable:v1.model.DirectoryWatch.extension)
  return _internal_mutable_extension();
}
inline const std::string& DirectoryWatch::_internal_extension() const {
  return extension_.Get();
}
inline void DirectoryWatch::_internal_set_extension(const std::string& value) {
  
  extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DirectoryWatch::_internal_mutable_extension() {
  
  return extension_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DirectoryWatch::release_extension() {
  // @@protoc_insertion_point(field_release:v1.model.DirectoryWatch.extension)
  return extension_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DirectoryWatch::set_allocated_extension(std::string* extension) {
  if (extension != nullptr) {
    
  } else {
    
  }
  extension_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.DirectoryWatch.extension)
}

// .v1.model.FileType file_type = 3 [json_name = "fileType"];
inline void DirectoryWatch::clear_file_type() {
  file_type_ = 0;
}
inline ::v1::model::FileType DirectoryWatch::_internal_file_type() const {
  return static_cast< ::v1::model::FileType >(file_type_);
}
inline ::v1::model::FileType DirectoryWatch::file_type() const {
  // @@protoc_insertion_point(field_get:v1.model.DirectoryWatch.file_type)
  return _internal_file_type();
}
inline void DirectoryWatch::_internal_set_file_type(::v1::model::FileType value) {
  
  file_type_ = value;
}
inline void DirectoryWatch::set_file_type(::v1::model::FileType value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:v1.model.DirectoryWatch.file_type)
}

// bool remote_agent = 4 [json_name = "remoteAgent"];
inline void DirectoryWatch::clear_remote_agent() {
  remote_agent_ = false;
}
inline bool DirectoryWatch::_internal_remote_agent() const {
  return remote_agent_;
}
inline bool DirectoryWatch::remote_agent() const {
  // @@protoc_insertion_point(field_get:v1.model.DirectoryWatch.remote_agent)
  return _internal_remote_agent();
}
inline void DirectoryWatch::_internal_set_remote_agent(bool value) {
  
  remote_agent_ = value;
}
inline void DirectoryWatch::set_remote_agent(bool value) {
  _internal_set_remote_agent(value);
  // @@protoc_insertion_point(field_set:v1.model.DirectoryWatch.remote_agent)
}

// -------------------------------------------------------------------

// FileTail

// string filename = 1 [json_name = "filename"];
inline void FileTail::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& FileTail::filename() const {
  // @@protoc_insertion_point(field_get:v1.model.FileTail.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTail::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.FileTail.filename)
}
inline std::string* FileTail::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:v1.model.FileTail.filename)
  return _internal_mutable_filename();
}
inline const std::string& FileTail::_internal_filename() const {
  return filename_.Get();
}
inline void FileTail::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileTail::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileTail::release_filename() {
  // @@protoc_insertion_point(field_release:v1.model.FileTail.filename)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileTail::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.FileTail.filename)
}

// .v1.model.FileFormat file_format = 2 [json_name = "fileFormat"];
inline void FileTail::clear_file_format() {
  file_format_ = 0;
}
inline ::v1::model::FileFormat FileTail::_internal_file_format() const {
  return static_cast< ::v1::model::FileFormat >(file_format_);
}
inline ::v1::model::FileFormat FileTail::file_format() const {
  // @@protoc_insertion_point(field_get:v1.model.FileTail.file_format)
  return _internal_file_format();
}
inline void FileTail::_internal_set_file_format(::v1::model::FileFormat value) {
  
  file_format_ = value;
}
inline void FileTail::set_file_format(::v1::model::FileFormat value) {
  _internal_set_file_format(value);
  // @@protoc_insertion_point(field_set:v1.model.FileTail.file_format)
}

// string time_key = 3 [json_name = "timeKey"];
inline void FileTail::clear_time_key() {
  time_key_.ClearToEmpty();
}
inline const std::string& FileTail::time_key() const {
  // @@protoc_insertion_point(field_get:v1.model.FileTail.time_key)
  return _internal_time_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTail::set_time_key(ArgT0&& arg0, ArgT... args) {
 
 time_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.FileTail.time_key)
}
inline std::string* FileTail::mutable_time_key() {
  // @@protoc_insertion_point(field_mutable:v1.model.FileTail.time_key)
  return _internal_mutable_time_key();
}
inline const std::string& FileTail::_internal_time_key() const {
  return time_key_.Get();
}
inline void FileTail::_internal_set_time_key(const std::string& value) {
  
  time_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileTail::_internal_mutable_time_key() {
  
  return time_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileTail::release_time_key() {
  // @@protoc_insertion_point(field_release:v1.model.FileTail.time_key)
  return time_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileTail::set_allocated_time_key(std::string* time_key) {
  if (time_key != nullptr) {
    
  } else {
    
  }
  time_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.FileTail.time_key)
}

// string time_format = 4 [json_name = "timeFormat"];
inline void FileTail::clear_time_format() {
  time_format_.ClearToEmpty();
}
inline const std::string& FileTail::time_format() const {
  // @@protoc_insertion_point(field_get:v1.model.FileTail.time_format)
  return _internal_time_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTail::set_time_format(ArgT0&& arg0, ArgT... args) {
 
 time_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.FileTail.time_format)
}
inline std::string* FileTail::mutable_time_format() {
  // @@protoc_insertion_point(field_mutable:v1.model.FileTail.time_format)
  return _internal_mutable_time_format();
}
inline const std::string& FileTail::_internal_time_format() const {
  return time_format_.Get();
}
inline void FileTail::_internal_set_time_format(const std::string& value) {
  
  time_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileTail::_internal_mutable_time_format() {
  
  return time_format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileTail::release_time_format() {
  // @@protoc_insertion_point(field_release:v1.model.FileTail.time_format)
  return time_format_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileTail::set_allocated_time_format(std::string* time_format) {
  if (time_format != nullptr) {
    
  } else {
    
  }
  time_format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_format,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.FileTail.time_format)
}

// string regex = 5 [json_name = "regex"];
inline void FileTail::clear_regex() {
  regex_.ClearToEmpty();
}
inline const std::string& FileTail::regex() const {
  // @@protoc_insertion_point(field_get:v1.model.FileTail.regex)
  return _internal_regex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileTail::set_regex(ArgT0&& arg0, ArgT... args) {
 
 regex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.FileTail.regex)
}
inline std::string* FileTail::mutable_regex() {
  // @@protoc_insertion_point(field_mutable:v1.model.FileTail.regex)
  return _internal_mutable_regex();
}
inline const std::string& FileTail::_internal_regex() const {
  return regex_.Get();
}
inline void FileTail::_internal_set_regex(const std::string& value) {
  
  regex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileTail::_internal_mutable_regex() {
  
  return regex_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileTail::release_regex() {
  // @@protoc_insertion_point(field_release:v1.model.FileTail.regex)
  return regex_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileTail::set_allocated_regex(std::string* regex) {
  if (regex != nullptr) {
    
  } else {
    
  }
  regex_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), regex,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.FileTail.regex)
}

// -------------------------------------------------------------------

// RtcInfo

// repeated string rtc_ice_transport_policies = 1 [json_name = "rtcIceTransportPolicies"];
inline int RtcInfo::_internal_rtc_ice_transport_policies_size() const {
  return rtc_ice_transport_policies_.size();
}
inline int RtcInfo::rtc_ice_transport_policies_size() const {
  return _internal_rtc_ice_transport_policies_size();
}
inline void RtcInfo::clear_rtc_ice_transport_policies() {
  rtc_ice_transport_policies_.Clear();
}
inline std::string* RtcInfo::add_rtc_ice_transport_policies() {
  // @@protoc_insertion_point(field_add_mutable:v1.model.RtcInfo.rtc_ice_transport_policies)
  return _internal_add_rtc_ice_transport_policies();
}
inline const std::string& RtcInfo::_internal_rtc_ice_transport_policies(int index) const {
  return rtc_ice_transport_policies_.Get(index);
}
inline const std::string& RtcInfo::rtc_ice_transport_policies(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.RtcInfo.rtc_ice_transport_policies)
  return _internal_rtc_ice_transport_policies(index);
}
inline std::string* RtcInfo::mutable_rtc_ice_transport_policies(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.RtcInfo.rtc_ice_transport_policies)
  return rtc_ice_transport_policies_.Mutable(index);
}
inline void RtcInfo::set_rtc_ice_transport_policies(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:v1.model.RtcInfo.rtc_ice_transport_policies)
  rtc_ice_transport_policies_.Mutable(index)->assign(value);
}
inline void RtcInfo::set_rtc_ice_transport_policies(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:v1.model.RtcInfo.rtc_ice_transport_policies)
  rtc_ice_transport_policies_.Mutable(index)->assign(std::move(value));
}
inline void RtcInfo::set_rtc_ice_transport_policies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rtc_ice_transport_policies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.model.RtcInfo.rtc_ice_transport_policies)
}
inline void RtcInfo::set_rtc_ice_transport_policies(int index, const char* value, size_t size) {
  rtc_ice_transport_policies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.model.RtcInfo.rtc_ice_transport_policies)
}
inline std::string* RtcInfo::_internal_add_rtc_ice_transport_policies() {
  return rtc_ice_transport_policies_.Add();
}
inline void RtcInfo::add_rtc_ice_transport_policies(const std::string& value) {
  rtc_ice_transport_policies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.model.RtcInfo.rtc_ice_transport_policies)
}
inline void RtcInfo::add_rtc_ice_transport_policies(std::string&& value) {
  rtc_ice_transport_policies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.model.RtcInfo.rtc_ice_transport_policies)
}
inline void RtcInfo::add_rtc_ice_transport_policies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  rtc_ice_transport_policies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.model.RtcInfo.rtc_ice_transport_policies)
}
inline void RtcInfo::add_rtc_ice_transport_policies(const char* value, size_t size) {
  rtc_ice_transport_policies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.model.RtcInfo.rtc_ice_transport_policies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RtcInfo::rtc_ice_transport_policies() const {
  // @@protoc_insertion_point(field_list:v1.model.RtcInfo.rtc_ice_transport_policies)
  return rtc_ice_transport_policies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RtcInfo::mutable_rtc_ice_transport_policies() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.RtcInfo.rtc_ice_transport_policies)
  return &rtc_ice_transport_policies_;
}

// string rtc_ice_server_protocol = 2 [json_name = "rtcIceServerProtocol"];
inline void RtcInfo::clear_rtc_ice_server_protocol() {
  rtc_ice_server_protocol_.ClearToEmpty();
}
inline const std::string& RtcInfo::rtc_ice_server_protocol() const {
  // @@protoc_insertion_point(field_get:v1.model.RtcInfo.rtc_ice_server_protocol)
  return _internal_rtc_ice_server_protocol();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RtcInfo::set_rtc_ice_server_protocol(ArgT0&& arg0, ArgT... args) {
 
 rtc_ice_server_protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.RtcInfo.rtc_ice_server_protocol)
}
inline std::string* RtcInfo::mutable_rtc_ice_server_protocol() {
  // @@protoc_insertion_point(field_mutable:v1.model.RtcInfo.rtc_ice_server_protocol)
  return _internal_mutable_rtc_ice_server_protocol();
}
inline const std::string& RtcInfo::_internal_rtc_ice_server_protocol() const {
  return rtc_ice_server_protocol_.Get();
}
inline void RtcInfo::_internal_set_rtc_ice_server_protocol(const std::string& value) {
  
  rtc_ice_server_protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RtcInfo::_internal_mutable_rtc_ice_server_protocol() {
  
  return rtc_ice_server_protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RtcInfo::release_rtc_ice_server_protocol() {
  // @@protoc_insertion_point(field_release:v1.model.RtcInfo.rtc_ice_server_protocol)
  return rtc_ice_server_protocol_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RtcInfo::set_allocated_rtc_ice_server_protocol(std::string* rtc_ice_server_protocol) {
  if (rtc_ice_server_protocol != nullptr) {
    
  } else {
    
  }
  rtc_ice_server_protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rtc_ice_server_protocol,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.RtcInfo.rtc_ice_server_protocol)
}

// bool use_all_servers = 3 [json_name = "useAllServers"];
inline void RtcInfo::clear_use_all_servers() {
  use_all_servers_ = false;
}
inline bool RtcInfo::_internal_use_all_servers() const {
  return use_all_servers_;
}
inline bool RtcInfo::use_all_servers() const {
  // @@protoc_insertion_point(field_get:v1.model.RtcInfo.use_all_servers)
  return _internal_use_all_servers();
}
inline void RtcInfo::_internal_set_use_all_servers(bool value) {
  
  use_all_servers_ = value;
}
inline void RtcInfo::set_use_all_servers(bool value) {
  _internal_set_use_all_servers(value);
  // @@protoc_insertion_point(field_set:v1.model.RtcInfo.use_all_servers)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace v1

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::v1::model::TeleopMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::TeleopMode>() {
  return ::v1::model::TeleopMode_descriptor();
}
template <> struct is_proto_enum< ::v1::model::FileFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::FileFormat>() {
  return ::v1::model::FileFormat_descriptor();
}
template <> struct is_proto_enum< ::v1::model::FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::FileType>() {
  return ::v1::model::FileType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fconfig_2eproto
