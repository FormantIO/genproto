// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/model/v1/event.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fevent_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fevent_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmodel_2fv1_2fevent_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmodel_2fv1_2fevent_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmodel_2fv1_2fevent_2eproto;
namespace v1 {
namespace model {
class AgentEventConfiguration;
struct AgentEventConfigurationDefaultTypeInternal;
extern AgentEventConfigurationDefaultTypeInternal _AgentEventConfiguration_default_instance_;
class AgentEventTrigger;
struct AgentEventTriggerDefaultTypeInternal;
extern AgentEventTriggerDefaultTypeInternal _AgentEventTrigger_default_instance_;
class AutoresolveEventTriggerCondition;
struct AutoresolveEventTriggerConditionDefaultTypeInternal;
extern AutoresolveEventTriggerConditionDefaultTypeInternal _AutoresolveEventTriggerCondition_default_instance_;
class BatteryCondition;
struct BatteryConditionDefaultTypeInternal;
extern BatteryConditionDefaultTypeInternal _BatteryCondition_default_instance_;
class BatteryEventTriggerCondition;
struct BatteryEventTriggerConditionDefaultTypeInternal;
extern BatteryEventTriggerConditionDefaultTypeInternal _BatteryEventTriggerCondition_default_instance_;
class BitsetCondition;
struct BitsetConditionDefaultTypeInternal;
extern BitsetConditionDefaultTypeInternal _BitsetCondition_default_instance_;
class BitsetEventTriggerCondition;
struct BitsetEventTriggerConditionDefaultTypeInternal;
extern BitsetEventTriggerConditionDefaultTypeInternal _BitsetEventTriggerCondition_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Event_TagsEntry_DoNotUse;
struct Event_TagsEntry_DoNotUseDefaultTypeInternal;
extern Event_TagsEntry_DoNotUseDefaultTypeInternal _Event_TagsEntry_DoNotUse_default_instance_;
class JsonEventTriggerCondition;
struct JsonEventTriggerConditionDefaultTypeInternal;
extern JsonEventTriggerConditionDefaultTypeInternal _JsonEventTriggerCondition_default_instance_;
class NumericCondition;
struct NumericConditionDefaultTypeInternal;
extern NumericConditionDefaultTypeInternal _NumericCondition_default_instance_;
class NumericSetEventTriggerCondition;
struct NumericSetEventTriggerConditionDefaultTypeInternal;
extern NumericSetEventTriggerConditionDefaultTypeInternal _NumericSetEventTriggerCondition_default_instance_;
class PresenceEventTriggerCondition;
struct PresenceEventTriggerConditionDefaultTypeInternal;
extern PresenceEventTriggerConditionDefaultTypeInternal _PresenceEventTriggerCondition_default_instance_;
class RegexEventTriggerCondition;
struct RegexEventTriggerConditionDefaultTypeInternal;
extern RegexEventTriggerConditionDefaultTypeInternal _RegexEventTriggerCondition_default_instance_;
class StatefulTriggerConfiguration;
struct StatefulTriggerConfigurationDefaultTypeInternal;
extern StatefulTriggerConfigurationDefaultTypeInternal _StatefulTriggerConfiguration_default_instance_;
class ThresholdEventTriggerCondition;
struct ThresholdEventTriggerConditionDefaultTypeInternal;
extern ThresholdEventTriggerConditionDefaultTypeInternal _ThresholdEventTriggerCondition_default_instance_;
}  // namespace model
}  // namespace v1
PROTOBUF_NAMESPACE_OPEN
template<> ::v1::model::AgentEventConfiguration* Arena::CreateMaybeMessage<::v1::model::AgentEventConfiguration>(Arena*);
template<> ::v1::model::AgentEventTrigger* Arena::CreateMaybeMessage<::v1::model::AgentEventTrigger>(Arena*);
template<> ::v1::model::AutoresolveEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::AutoresolveEventTriggerCondition>(Arena*);
template<> ::v1::model::BatteryCondition* Arena::CreateMaybeMessage<::v1::model::BatteryCondition>(Arena*);
template<> ::v1::model::BatteryEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::BatteryEventTriggerCondition>(Arena*);
template<> ::v1::model::BitsetCondition* Arena::CreateMaybeMessage<::v1::model::BitsetCondition>(Arena*);
template<> ::v1::model::BitsetEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::BitsetEventTriggerCondition>(Arena*);
template<> ::v1::model::Condition* Arena::CreateMaybeMessage<::v1::model::Condition>(Arena*);
template<> ::v1::model::Event* Arena::CreateMaybeMessage<::v1::model::Event>(Arena*);
template<> ::v1::model::Event_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::Event_TagsEntry_DoNotUse>(Arena*);
template<> ::v1::model::JsonEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::JsonEventTriggerCondition>(Arena*);
template<> ::v1::model::NumericCondition* Arena::CreateMaybeMessage<::v1::model::NumericCondition>(Arena*);
template<> ::v1::model::NumericSetEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::NumericSetEventTriggerCondition>(Arena*);
template<> ::v1::model::PresenceEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::PresenceEventTriggerCondition>(Arena*);
template<> ::v1::model::RegexEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::RegexEventTriggerCondition>(Arena*);
template<> ::v1::model::StatefulTriggerConfiguration* Arena::CreateMaybeMessage<::v1::model::StatefulTriggerConfiguration>(Arena*);
template<> ::v1::model::ThresholdEventTriggerCondition* Arena::CreateMaybeMessage<::v1::model::ThresholdEventTriggerCondition>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v1 {
namespace model {

enum Severity : int {
  INFO = 0,
  WARNING = 1,
  ERROR = 2,
  CRITICAL = 3,
  Severity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Severity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Severity_IsValid(int value);
constexpr Severity Severity_MIN = INFO;
constexpr Severity Severity_MAX = CRITICAL;
constexpr int Severity_ARRAYSIZE = Severity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Severity_descriptor();
template<typename T>
inline const std::string& Severity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Severity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Severity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Severity_descriptor(), enum_t_value);
}
inline bool Severity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Severity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Severity>(
    Severity_descriptor(), name, value);
}
enum BatteryField : int {
  Charge = 0,
  Current = 1,
  Percentage = 2,
  Voltage = 3,
  BatteryField_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BatteryField_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BatteryField_IsValid(int value);
constexpr BatteryField BatteryField_MIN = Charge;
constexpr BatteryField BatteryField_MAX = Voltage;
constexpr int BatteryField_ARRAYSIZE = BatteryField_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BatteryField_descriptor();
template<typename T>
inline const std::string& BatteryField_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BatteryField>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BatteryField_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BatteryField_descriptor(), enum_t_value);
}
inline bool BatteryField_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BatteryField* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BatteryField>(
    BatteryField_descriptor(), name, value);
}
enum ThresholdOperator : int {
  LT = 0,
  LTE = 1,
  GT = 2,
  GTE = 3,
  EQ = 4,
  NEQ = 5,
  ThresholdOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ThresholdOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ThresholdOperator_IsValid(int value);
constexpr ThresholdOperator ThresholdOperator_MIN = LT;
constexpr ThresholdOperator ThresholdOperator_MAX = NEQ;
constexpr int ThresholdOperator_ARRAYSIZE = ThresholdOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThresholdOperator_descriptor();
template<typename T>
inline const std::string& ThresholdOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThresholdOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThresholdOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThresholdOperator_descriptor(), enum_t_value);
}
inline bool ThresholdOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ThresholdOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThresholdOperator>(
    ThresholdOperator_descriptor(), name, value);
}
enum ConditionOperator : int {
  ANY = 0,
  ALL = 1,
  ConditionOperator_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ConditionOperator_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ConditionOperator_IsValid(int value);
constexpr ConditionOperator ConditionOperator_MIN = ANY;
constexpr ConditionOperator ConditionOperator_MAX = ALL;
constexpr int ConditionOperator_ARRAYSIZE = ConditionOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConditionOperator_descriptor();
template<typename T>
inline const std::string& ConditionOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConditionOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConditionOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConditionOperator_descriptor(), enum_t_value);
}
inline bool ConditionOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConditionOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConditionOperator>(
    ConditionOperator_descriptor(), name, value);
}
// ===================================================================

class Event_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Event_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Event_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Event_TagsEntry_DoNotUse();
  explicit constexpr Event_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Event_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Event_TagsEntry_DoNotUse& other);
  static const Event_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Event_TagsEntry_DoNotUse*>(&_Event_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.Event.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.Event.TagsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return new Event();
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 6,
    kMessageFieldNumber = 2,
    kStreamNameFieldNumber = 3,
    kStreamTypeFieldNumber = 4,
    kIdFieldNumber = 10,
    kTypeFieldNumber = 11,
    kEventTriggerIdFieldNumber = 12,
    kTimestampFieldNumber = 1,
    kNotificationEnabledFieldNumber = 5,
    kSeverityFieldNumber = 9,
    kEndTimestampFieldNumber = 8,
  };
  // map<string, string> tags = 6 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string message = 2 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string stream_name = 3 [json_name = "streamName"];
  void clear_stream_name();
  const std::string& stream_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_name();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_stream_name();
  void set_allocated_stream_name(std::string* stream_name);
  private:
  const std::string& _internal_stream_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_name(const std::string& value);
  std::string* _internal_mutable_stream_name();
  public:

  // string stream_type = 4 [json_name = "streamType"];
  void clear_stream_type();
  const std::string& stream_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_type();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_stream_type();
  void set_allocated_stream_type(std::string* stream_type);
  private:
  const std::string& _internal_stream_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_type(const std::string& value);
  std::string* _internal_mutable_stream_type();
  public:

  // string id = 10 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string type = 11 [json_name = "type"];
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // string event_trigger_id = 12 [json_name = "eventTriggerId"];
  void clear_event_trigger_id();
  const std::string& event_trigger_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_trigger_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_trigger_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_event_trigger_id();
  void set_allocated_event_trigger_id(std::string* event_trigger_id);
  private:
  const std::string& _internal_event_trigger_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_trigger_id(const std::string& value);
  std::string* _internal_mutable_event_trigger_id();
  public:

  // int64 timestamp = 1 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool notification_enabled = 5 [json_name = "notificationEnabled"];
  void clear_notification_enabled();
  bool notification_enabled() const;
  void set_notification_enabled(bool value);
  private:
  bool _internal_notification_enabled() const;
  void _internal_set_notification_enabled(bool value);
  public:

  // .v1.model.Severity severity = 9 [json_name = "severity"];
  void clear_severity();
  ::v1::model::Severity severity() const;
  void set_severity(::v1::model::Severity value);
  private:
  ::v1::model::Severity _internal_severity() const;
  void _internal_set_severity(::v1::model::Severity value);
  public:

  // int64 end_timestamp = 8 [json_name = "endTimestamp"];
  void clear_end_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 end_timestamp() const;
  void set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end_timestamp() const;
  void _internal_set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Event_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_trigger_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  bool notification_enabled_;
  int severity_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class AgentEventConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AgentEventConfiguration) */ {
 public:
  inline AgentEventConfiguration() : AgentEventConfiguration(nullptr) {}
  ~AgentEventConfiguration() override;
  explicit constexpr AgentEventConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentEventConfiguration(const AgentEventConfiguration& from);
  AgentEventConfiguration(AgentEventConfiguration&& from) noexcept
    : AgentEventConfiguration() {
    *this = ::std::move(from);
  }

  inline AgentEventConfiguration& operator=(const AgentEventConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentEventConfiguration& operator=(AgentEventConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentEventConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentEventConfiguration* internal_default_instance() {
    return reinterpret_cast<const AgentEventConfiguration*>(
               &_AgentEventConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AgentEventConfiguration& a, AgentEventConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentEventConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentEventConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentEventConfiguration* New() const final {
    return new AgentEventConfiguration();
  }

  AgentEventConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentEventConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AgentEventConfiguration& from);
  void MergeFrom(const AgentEventConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentEventConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AgentEventConfiguration";
  }
  protected:
  explicit AgentEventConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventTriggersFieldNumber = 1,
    kStatefulEventTriggersFieldNumber = 3,
    kLastUpdatedFieldNumber = 2,
  };
  // repeated .v1.model.AgentEventTrigger event_triggers = 1 [json_name = "eventTriggers"];
  int event_triggers_size() const;
  private:
  int _internal_event_triggers_size() const;
  public:
  void clear_event_triggers();
  ::v1::model::AgentEventTrigger* mutable_event_triggers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >*
      mutable_event_triggers();
  private:
  const ::v1::model::AgentEventTrigger& _internal_event_triggers(int index) const;
  ::v1::model::AgentEventTrigger* _internal_add_event_triggers();
  public:
  const ::v1::model::AgentEventTrigger& event_triggers(int index) const;
  ::v1::model::AgentEventTrigger* add_event_triggers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >&
      event_triggers() const;

  // repeated .v1.model.AgentEventTrigger stateful_event_triggers = 3 [json_name = "statefulEventTriggers"];
  int stateful_event_triggers_size() const;
  private:
  int _internal_stateful_event_triggers_size() const;
  public:
  void clear_stateful_event_triggers();
  ::v1::model::AgentEventTrigger* mutable_stateful_event_triggers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >*
      mutable_stateful_event_triggers();
  private:
  const ::v1::model::AgentEventTrigger& _internal_stateful_event_triggers(int index) const;
  ::v1::model::AgentEventTrigger* _internal_add_stateful_event_triggers();
  public:
  const ::v1::model::AgentEventTrigger& stateful_event_triggers(int index) const;
  ::v1::model::AgentEventTrigger* add_stateful_event_triggers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >&
      stateful_event_triggers() const;

  // int64 last_updated = 2 [json_name = "lastUpdated"];
  void clear_last_updated();
  ::PROTOBUF_NAMESPACE_ID::int64 last_updated() const;
  void set_last_updated(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_last_updated() const;
  void _internal_set_last_updated(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.AgentEventConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger > event_triggers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger > stateful_event_triggers_;
  ::PROTOBUF_NAMESPACE_ID::int64 last_updated_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class AgentEventTrigger final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AgentEventTrigger) */ {
 public:
  inline AgentEventTrigger() : AgentEventTrigger(nullptr) {}
  ~AgentEventTrigger() override;
  explicit constexpr AgentEventTrigger(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AgentEventTrigger(const AgentEventTrigger& from);
  AgentEventTrigger(AgentEventTrigger&& from) noexcept
    : AgentEventTrigger() {
    *this = ::std::move(from);
  }

  inline AgentEventTrigger& operator=(const AgentEventTrigger& from) {
    CopyFrom(from);
    return *this;
  }
  inline AgentEventTrigger& operator=(AgentEventTrigger&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AgentEventTrigger& default_instance() {
    return *internal_default_instance();
  }
  static inline const AgentEventTrigger* internal_default_instance() {
    return reinterpret_cast<const AgentEventTrigger*>(
               &_AgentEventTrigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AgentEventTrigger& a, AgentEventTrigger& b) {
    a.Swap(&b);
  }
  inline void Swap(AgentEventTrigger* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AgentEventTrigger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AgentEventTrigger* New() const final {
    return new AgentEventTrigger();
  }

  AgentEventTrigger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AgentEventTrigger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AgentEventTrigger& from);
  void MergeFrom(const AgentEventTrigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AgentEventTrigger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AgentEventTrigger";
  }
  protected:
  explicit AgentEventTrigger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStreamFieldNumber = 2,
    kMessageFieldNumber = 8,
    kSeverityFieldNumber = 9,
    kMessageFormatFieldNumber = 11,
    kConditionFieldNumber = 4,
    kExitConditionFieldNumber = 5,
    kStatefulTriggerConfigurationFieldNumber = 7,
    kIntervalFieldNumber = 3,
    kIsStatefulTriggerFieldNumber = 6,
    kNotificationEnabledFieldNumber = 10,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string stream = 2 [json_name = "stream"];
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // string message = 8 [json_name = "message"];
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // string severity = 9 [json_name = "severity"];
  void clear_severity();
  const std::string& severity() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_severity(ArgT0&& arg0, ArgT... args);
  std::string* mutable_severity();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_severity();
  void set_allocated_severity(std::string* severity);
  private:
  const std::string& _internal_severity() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_severity(const std::string& value);
  std::string* _internal_mutable_severity();
  public:

  // string messageFormat = 11 [json_name = "messageFormat"];
  void clear_messageformat();
  const std::string& messageformat() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_messageformat(ArgT0&& arg0, ArgT... args);
  std::string* mutable_messageformat();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_messageformat();
  void set_allocated_messageformat(std::string* messageformat);
  private:
  const std::string& _internal_messageformat() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_messageformat(const std::string& value);
  std::string* _internal_mutable_messageformat();
  public:

  // .v1.model.Condition condition = 4 [json_name = "condition"];
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::v1::model::Condition& condition() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Condition* release_condition();
  ::v1::model::Condition* mutable_condition();
  void set_allocated_condition(::v1::model::Condition* condition);
  private:
  const ::v1::model::Condition& _internal_condition() const;
  ::v1::model::Condition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::v1::model::Condition* condition);
  ::v1::model::Condition* unsafe_arena_release_condition();

  // .v1.model.Condition exitCondition = 5 [json_name = "exitCondition"];
  bool has_exitcondition() const;
  private:
  bool _internal_has_exitcondition() const;
  public:
  void clear_exitcondition();
  const ::v1::model::Condition& exitcondition() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Condition* release_exitcondition();
  ::v1::model::Condition* mutable_exitcondition();
  void set_allocated_exitcondition(::v1::model::Condition* exitcondition);
  private:
  const ::v1::model::Condition& _internal_exitcondition() const;
  ::v1::model::Condition* _internal_mutable_exitcondition();
  public:
  void unsafe_arena_set_allocated_exitcondition(
      ::v1::model::Condition* exitcondition);
  ::v1::model::Condition* unsafe_arena_release_exitcondition();

  // .v1.model.StatefulTriggerConfiguration statefulTriggerConfiguration = 7 [json_name = "statefulTriggerConfiguration"];
  bool has_statefultriggerconfiguration() const;
  private:
  bool _internal_has_statefultriggerconfiguration() const;
  public:
  void clear_statefultriggerconfiguration();
  const ::v1::model::StatefulTriggerConfiguration& statefultriggerconfiguration() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::StatefulTriggerConfiguration* release_statefultriggerconfiguration();
  ::v1::model::StatefulTriggerConfiguration* mutable_statefultriggerconfiguration();
  void set_allocated_statefultriggerconfiguration(::v1::model::StatefulTriggerConfiguration* statefultriggerconfiguration);
  private:
  const ::v1::model::StatefulTriggerConfiguration& _internal_statefultriggerconfiguration() const;
  ::v1::model::StatefulTriggerConfiguration* _internal_mutable_statefultriggerconfiguration();
  public:
  void unsafe_arena_set_allocated_statefultriggerconfiguration(
      ::v1::model::StatefulTriggerConfiguration* statefultriggerconfiguration);
  ::v1::model::StatefulTriggerConfiguration* unsafe_arena_release_statefultriggerconfiguration();

  // int64 interval = 3 [json_name = "interval"];
  void clear_interval();
  ::PROTOBUF_NAMESPACE_ID::int64 interval() const;
  void set_interval(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_interval() const;
  void _internal_set_interval(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool isStatefulTrigger = 6 [json_name = "isStatefulTrigger"];
  void clear_isstatefultrigger();
  bool isstatefultrigger() const;
  void set_isstatefultrigger(bool value);
  private:
  bool _internal_isstatefultrigger() const;
  void _internal_set_isstatefultrigger(bool value);
  public:

  // bool notification_enabled = 10 [json_name = "notificationEnabled"];
  void clear_notification_enabled();
  bool notification_enabled() const;
  void set_notification_enabled(bool value);
  private:
  bool _internal_notification_enabled() const;
  void _internal_set_notification_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.AgentEventTrigger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr severity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messageformat_;
  ::v1::model::Condition* condition_;
  ::v1::model::Condition* exitcondition_;
  ::v1::model::StatefulTriggerConfiguration* statefultriggerconfiguration_;
  ::PROTOBUF_NAMESPACE_ID::int64 interval_;
  bool isstatefultrigger_;
  bool notification_enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  explicit constexpr Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  enum ConditionCase {
    kPresence = 2,
    kThreshold = 3,
    kRegex = 4,
    kBitset = 5,
    kBattery = 6,
    kNumeric = 7,
    kJson = 8,
    kAutoresolve = 9,
    CONDITION_NOT_SET = 0,
  };

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return new Condition();
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kPresenceFieldNumber = 2,
    kThresholdFieldNumber = 3,
    kRegexFieldNumber = 4,
    kBitsetFieldNumber = 5,
    kBatteryFieldNumber = 6,
    kNumericFieldNumber = 7,
    kJsonFieldNumber = 8,
    kAutoresolveFieldNumber = 9,
  };
  // string stream = 1 [json_name = "stream"];
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // .v1.model.PresenceEventTriggerCondition presence = 2 [json_name = "presence"];
  bool has_presence() const;
  private:
  bool _internal_has_presence() const;
  public:
  void clear_presence();
  const ::v1::model::PresenceEventTriggerCondition& presence() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::PresenceEventTriggerCondition* release_presence();
  ::v1::model::PresenceEventTriggerCondition* mutable_presence();
  void set_allocated_presence(::v1::model::PresenceEventTriggerCondition* presence);
  private:
  const ::v1::model::PresenceEventTriggerCondition& _internal_presence() const;
  ::v1::model::PresenceEventTriggerCondition* _internal_mutable_presence();
  public:
  void unsafe_arena_set_allocated_presence(
      ::v1::model::PresenceEventTriggerCondition* presence);
  ::v1::model::PresenceEventTriggerCondition* unsafe_arena_release_presence();

  // .v1.model.ThresholdEventTriggerCondition threshold = 3 [json_name = "threshold"];
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  const ::v1::model::ThresholdEventTriggerCondition& threshold() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ThresholdEventTriggerCondition* release_threshold();
  ::v1::model::ThresholdEventTriggerCondition* mutable_threshold();
  void set_allocated_threshold(::v1::model::ThresholdEventTriggerCondition* threshold);
  private:
  const ::v1::model::ThresholdEventTriggerCondition& _internal_threshold() const;
  ::v1::model::ThresholdEventTriggerCondition* _internal_mutable_threshold();
  public:
  void unsafe_arena_set_allocated_threshold(
      ::v1::model::ThresholdEventTriggerCondition* threshold);
  ::v1::model::ThresholdEventTriggerCondition* unsafe_arena_release_threshold();

  // .v1.model.RegexEventTriggerCondition regex = 4 [json_name = "regex"];
  bool has_regex() const;
  private:
  bool _internal_has_regex() const;
  public:
  void clear_regex();
  const ::v1::model::RegexEventTriggerCondition& regex() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::RegexEventTriggerCondition* release_regex();
  ::v1::model::RegexEventTriggerCondition* mutable_regex();
  void set_allocated_regex(::v1::model::RegexEventTriggerCondition* regex);
  private:
  const ::v1::model::RegexEventTriggerCondition& _internal_regex() const;
  ::v1::model::RegexEventTriggerCondition* _internal_mutable_regex();
  public:
  void unsafe_arena_set_allocated_regex(
      ::v1::model::RegexEventTriggerCondition* regex);
  ::v1::model::RegexEventTriggerCondition* unsafe_arena_release_regex();

  // .v1.model.BitsetEventTriggerCondition bitset = 5 [json_name = "bitset"];
  bool has_bitset() const;
  private:
  bool _internal_has_bitset() const;
  public:
  void clear_bitset();
  const ::v1::model::BitsetEventTriggerCondition& bitset() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::BitsetEventTriggerCondition* release_bitset();
  ::v1::model::BitsetEventTriggerCondition* mutable_bitset();
  void set_allocated_bitset(::v1::model::BitsetEventTriggerCondition* bitset);
  private:
  const ::v1::model::BitsetEventTriggerCondition& _internal_bitset() const;
  ::v1::model::BitsetEventTriggerCondition* _internal_mutable_bitset();
  public:
  void unsafe_arena_set_allocated_bitset(
      ::v1::model::BitsetEventTriggerCondition* bitset);
  ::v1::model::BitsetEventTriggerCondition* unsafe_arena_release_bitset();

  // .v1.model.BatteryEventTriggerCondition battery = 6 [json_name = "battery"];
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  const ::v1::model::BatteryEventTriggerCondition& battery() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::BatteryEventTriggerCondition* release_battery();
  ::v1::model::BatteryEventTriggerCondition* mutable_battery();
  void set_allocated_battery(::v1::model::BatteryEventTriggerCondition* battery);
  private:
  const ::v1::model::BatteryEventTriggerCondition& _internal_battery() const;
  ::v1::model::BatteryEventTriggerCondition* _internal_mutable_battery();
  public:
  void unsafe_arena_set_allocated_battery(
      ::v1::model::BatteryEventTriggerCondition* battery);
  ::v1::model::BatteryEventTriggerCondition* unsafe_arena_release_battery();

  // .v1.model.NumericSetEventTriggerCondition numeric = 7 [json_name = "numeric"];
  bool has_numeric() const;
  private:
  bool _internal_has_numeric() const;
  public:
  void clear_numeric();
  const ::v1::model::NumericSetEventTriggerCondition& numeric() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::NumericSetEventTriggerCondition* release_numeric();
  ::v1::model::NumericSetEventTriggerCondition* mutable_numeric();
  void set_allocated_numeric(::v1::model::NumericSetEventTriggerCondition* numeric);
  private:
  const ::v1::model::NumericSetEventTriggerCondition& _internal_numeric() const;
  ::v1::model::NumericSetEventTriggerCondition* _internal_mutable_numeric();
  public:
  void unsafe_arena_set_allocated_numeric(
      ::v1::model::NumericSetEventTriggerCondition* numeric);
  ::v1::model::NumericSetEventTriggerCondition* unsafe_arena_release_numeric();

  // .v1.model.JsonEventTriggerCondition json = 8 [json_name = "json"];
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const ::v1::model::JsonEventTriggerCondition& json() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::JsonEventTriggerCondition* release_json();
  ::v1::model::JsonEventTriggerCondition* mutable_json();
  void set_allocated_json(::v1::model::JsonEventTriggerCondition* json);
  private:
  const ::v1::model::JsonEventTriggerCondition& _internal_json() const;
  ::v1::model::JsonEventTriggerCondition* _internal_mutable_json();
  public:
  void unsafe_arena_set_allocated_json(
      ::v1::model::JsonEventTriggerCondition* json);
  ::v1::model::JsonEventTriggerCondition* unsafe_arena_release_json();

  // .v1.model.AutoresolveEventTriggerCondition autoresolve = 9 [json_name = "autoresolve"];
  bool has_autoresolve() const;
  private:
  bool _internal_has_autoresolve() const;
  public:
  void clear_autoresolve();
  const ::v1::model::AutoresolveEventTriggerCondition& autoresolve() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::AutoresolveEventTriggerCondition* release_autoresolve();
  ::v1::model::AutoresolveEventTriggerCondition* mutable_autoresolve();
  void set_allocated_autoresolve(::v1::model::AutoresolveEventTriggerCondition* autoresolve);
  private:
  const ::v1::model::AutoresolveEventTriggerCondition& _internal_autoresolve() const;
  ::v1::model::AutoresolveEventTriggerCondition* _internal_mutable_autoresolve();
  public:
  void unsafe_arena_set_allocated_autoresolve(
      ::v1::model::AutoresolveEventTriggerCondition* autoresolve);
  ::v1::model::AutoresolveEventTriggerCondition* unsafe_arena_release_autoresolve();

  void clear_condition();
  ConditionCase condition_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.Condition)
 private:
  class _Internal;
  void set_has_presence();
  void set_has_threshold();
  void set_has_regex();
  void set_has_bitset();
  void set_has_battery();
  void set_has_numeric();
  void set_has_json();
  void set_has_autoresolve();

  inline bool has_condition() const;
  inline void clear_has_condition();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
  union ConditionUnion {
    constexpr ConditionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::PresenceEventTriggerCondition* presence_;
    ::v1::model::ThresholdEventTriggerCondition* threshold_;
    ::v1::model::RegexEventTriggerCondition* regex_;
    ::v1::model::BitsetEventTriggerCondition* bitset_;
    ::v1::model::BatteryEventTriggerCondition* battery_;
    ::v1::model::NumericSetEventTriggerCondition* numeric_;
    ::v1::model::JsonEventTriggerCondition* json_;
    ::v1::model::AutoresolveEventTriggerCondition* autoresolve_;
  } condition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class PresenceEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.PresenceEventTriggerCondition) */ {
 public:
  inline PresenceEventTriggerCondition() : PresenceEventTriggerCondition(nullptr) {}
  ~PresenceEventTriggerCondition() override;
  explicit constexpr PresenceEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PresenceEventTriggerCondition(const PresenceEventTriggerCondition& from);
  PresenceEventTriggerCondition(PresenceEventTriggerCondition&& from) noexcept
    : PresenceEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline PresenceEventTriggerCondition& operator=(const PresenceEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PresenceEventTriggerCondition& operator=(PresenceEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PresenceEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PresenceEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const PresenceEventTriggerCondition*>(
               &_PresenceEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PresenceEventTriggerCondition& a, PresenceEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(PresenceEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PresenceEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PresenceEventTriggerCondition* New() const final {
    return new PresenceEventTriggerCondition();
  }

  PresenceEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PresenceEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PresenceEventTriggerCondition& from);
  void MergeFrom(const PresenceEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PresenceEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.PresenceEventTriggerCondition";
  }
  protected:
  explicit PresenceEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:v1.model.PresenceEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class AutoresolveEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.AutoresolveEventTriggerCondition) */ {
 public:
  inline AutoresolveEventTriggerCondition() : AutoresolveEventTriggerCondition(nullptr) {}
  ~AutoresolveEventTriggerCondition() override;
  explicit constexpr AutoresolveEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoresolveEventTriggerCondition(const AutoresolveEventTriggerCondition& from);
  AutoresolveEventTriggerCondition(AutoresolveEventTriggerCondition&& from) noexcept
    : AutoresolveEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline AutoresolveEventTriggerCondition& operator=(const AutoresolveEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoresolveEventTriggerCondition& operator=(AutoresolveEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoresolveEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AutoresolveEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const AutoresolveEventTriggerCondition*>(
               &_AutoresolveEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AutoresolveEventTriggerCondition& a, AutoresolveEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoresolveEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoresolveEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AutoresolveEventTriggerCondition* New() const final {
    return new AutoresolveEventTriggerCondition();
  }

  AutoresolveEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AutoresolveEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AutoresolveEventTriggerCondition& from);
  void MergeFrom(const AutoresolveEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoresolveEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.AutoresolveEventTriggerCondition";
  }
  protected:
  explicit AutoresolveEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:v1.model.AutoresolveEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class ThresholdEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.ThresholdEventTriggerCondition) */ {
 public:
  inline ThresholdEventTriggerCondition() : ThresholdEventTriggerCondition(nullptr) {}
  ~ThresholdEventTriggerCondition() override;
  explicit constexpr ThresholdEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ThresholdEventTriggerCondition(const ThresholdEventTriggerCondition& from);
  ThresholdEventTriggerCondition(ThresholdEventTriggerCondition&& from) noexcept
    : ThresholdEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline ThresholdEventTriggerCondition& operator=(const ThresholdEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThresholdEventTriggerCondition& operator=(ThresholdEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ThresholdEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ThresholdEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const ThresholdEventTriggerCondition*>(
               &_ThresholdEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ThresholdEventTriggerCondition& a, ThresholdEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ThresholdEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ThresholdEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThresholdEventTriggerCondition* New() const final {
    return new ThresholdEventTriggerCondition();
  }

  ThresholdEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThresholdEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThresholdEventTriggerCondition& from);
  void MergeFrom(const ThresholdEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThresholdEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.ThresholdEventTriggerCondition";
  }
  protected:
  explicit ThresholdEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kOperatorFieldNumber = 2,
  };
  // double value = 1 [json_name = "value"];
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // .v1.model.ThresholdOperator operator = 2 [json_name = "operator"];
  void clear_operator_();
  ::v1::model::ThresholdOperator operator_() const;
  void set_operator_(::v1::model::ThresholdOperator value);
  private:
  ::v1::model::ThresholdOperator _internal_operator_() const;
  void _internal_set_operator_(::v1::model::ThresholdOperator value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.ThresholdEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double value_;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class NumericCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.NumericCondition) */ {
 public:
  inline NumericCondition() : NumericCondition(nullptr) {}
  ~NumericCondition() override;
  explicit constexpr NumericCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NumericCondition(const NumericCondition& from);
  NumericCondition(NumericCondition&& from) noexcept
    : NumericCondition() {
    *this = ::std::move(from);
  }

  inline NumericCondition& operator=(const NumericCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericCondition& operator=(NumericCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumericCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumericCondition* internal_default_instance() {
    return reinterpret_cast<const NumericCondition*>(
               &_NumericCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(NumericCondition& a, NumericCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(NumericCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NumericCondition* New() const final {
    return new NumericCondition();
  }

  NumericCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NumericCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NumericCondition& from);
  void MergeFrom(const NumericCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumericCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.NumericCondition";
  }
  protected:
  explicit NumericCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
    kConditionFieldNumber = 2,
  };
  // string label = 1 [json_name = "label"];
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // .v1.model.ThresholdEventTriggerCondition condition = 2 [json_name = "condition"];
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::v1::model::ThresholdEventTriggerCondition& condition() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ThresholdEventTriggerCondition* release_condition();
  ::v1::model::ThresholdEventTriggerCondition* mutable_condition();
  void set_allocated_condition(::v1::model::ThresholdEventTriggerCondition* condition);
  private:
  const ::v1::model::ThresholdEventTriggerCondition& _internal_condition() const;
  ::v1::model::ThresholdEventTriggerCondition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::v1::model::ThresholdEventTriggerCondition* condition);
  ::v1::model::ThresholdEventTriggerCondition* unsafe_arena_release_condition();

  // @@protoc_insertion_point(class_scope:v1.model.NumericCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::v1::model::ThresholdEventTriggerCondition* condition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class NumericSetEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.NumericSetEventTriggerCondition) */ {
 public:
  inline NumericSetEventTriggerCondition() : NumericSetEventTriggerCondition(nullptr) {}
  ~NumericSetEventTriggerCondition() override;
  explicit constexpr NumericSetEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NumericSetEventTriggerCondition(const NumericSetEventTriggerCondition& from);
  NumericSetEventTriggerCondition(NumericSetEventTriggerCondition&& from) noexcept
    : NumericSetEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline NumericSetEventTriggerCondition& operator=(const NumericSetEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NumericSetEventTriggerCondition& operator=(NumericSetEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NumericSetEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NumericSetEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const NumericSetEventTriggerCondition*>(
               &_NumericSetEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NumericSetEventTriggerCondition& a, NumericSetEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(NumericSetEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NumericSetEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NumericSetEventTriggerCondition* New() const final {
    return new NumericSetEventTriggerCondition();
  }

  NumericSetEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NumericSetEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NumericSetEventTriggerCondition& from);
  void MergeFrom(const NumericSetEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NumericSetEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.NumericSetEventTriggerCondition";
  }
  protected:
  explicit NumericSetEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
    kOperatorFieldNumber = 2,
  };
  // repeated .v1.model.NumericCondition conditions = 1 [json_name = "conditions"];
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::v1::model::NumericCondition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::NumericCondition >*
      mutable_conditions();
  private:
  const ::v1::model::NumericCondition& _internal_conditions(int index) const;
  ::v1::model::NumericCondition* _internal_add_conditions();
  public:
  const ::v1::model::NumericCondition& conditions(int index) const;
  ::v1::model::NumericCondition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::NumericCondition >&
      conditions() const;

  // .v1.model.ConditionOperator operator = 2 [json_name = "operator"];
  void clear_operator_();
  ::v1::model::ConditionOperator operator_() const;
  void set_operator_(::v1::model::ConditionOperator value);
  private:
  ::v1::model::ConditionOperator _internal_operator_() const;
  void _internal_set_operator_(::v1::model::ConditionOperator value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.NumericSetEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::NumericCondition > conditions_;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class BatteryCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.BatteryCondition) */ {
 public:
  inline BatteryCondition() : BatteryCondition(nullptr) {}
  ~BatteryCondition() override;
  explicit constexpr BatteryCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryCondition(const BatteryCondition& from);
  BatteryCondition(BatteryCondition&& from) noexcept
    : BatteryCondition() {
    *this = ::std::move(from);
  }

  inline BatteryCondition& operator=(const BatteryCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryCondition& operator=(BatteryCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryCondition* internal_default_instance() {
    return reinterpret_cast<const BatteryCondition*>(
               &_BatteryCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(BatteryCondition& a, BatteryCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatteryCondition* New() const final {
    return new BatteryCondition();
  }

  BatteryCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatteryCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatteryCondition& from);
  void MergeFrom(const BatteryCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.BatteryCondition";
  }
  protected:
  explicit BatteryCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 2,
    kFieldFieldNumber = 1,
    kOperatorFieldNumber = 3,
  };
  // .v1.model.ThresholdEventTriggerCondition condition = 2 [json_name = "condition"];
  bool has_condition() const;
  private:
  bool _internal_has_condition() const;
  public:
  void clear_condition();
  const ::v1::model::ThresholdEventTriggerCondition& condition() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::ThresholdEventTriggerCondition* release_condition();
  ::v1::model::ThresholdEventTriggerCondition* mutable_condition();
  void set_allocated_condition(::v1::model::ThresholdEventTriggerCondition* condition);
  private:
  const ::v1::model::ThresholdEventTriggerCondition& _internal_condition() const;
  ::v1::model::ThresholdEventTriggerCondition* _internal_mutable_condition();
  public:
  void unsafe_arena_set_allocated_condition(
      ::v1::model::ThresholdEventTriggerCondition* condition);
  ::v1::model::ThresholdEventTriggerCondition* unsafe_arena_release_condition();

  // .v1.model.BatteryField field = 1 [json_name = "field"];
  void clear_field();
  ::v1::model::BatteryField field() const;
  void set_field(::v1::model::BatteryField value);
  private:
  ::v1::model::BatteryField _internal_field() const;
  void _internal_set_field(::v1::model::BatteryField value);
  public:

  // .v1.model.ConditionOperator operator = 3 [json_name = "operator"];
  void clear_operator_();
  ::v1::model::ConditionOperator operator_() const;
  void set_operator_(::v1::model::ConditionOperator value);
  private:
  ::v1::model::ConditionOperator _internal_operator_() const;
  void _internal_set_operator_(::v1::model::ConditionOperator value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.BatteryCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::v1::model::ThresholdEventTriggerCondition* condition_;
  int field_;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class BatteryEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.BatteryEventTriggerCondition) */ {
 public:
  inline BatteryEventTriggerCondition() : BatteryEventTriggerCondition(nullptr) {}
  ~BatteryEventTriggerCondition() override;
  explicit constexpr BatteryEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatteryEventTriggerCondition(const BatteryEventTriggerCondition& from);
  BatteryEventTriggerCondition(BatteryEventTriggerCondition&& from) noexcept
    : BatteryEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline BatteryEventTriggerCondition& operator=(const BatteryEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatteryEventTriggerCondition& operator=(BatteryEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatteryEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatteryEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const BatteryEventTriggerCondition*>(
               &_BatteryEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(BatteryEventTriggerCondition& a, BatteryEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(BatteryEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatteryEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatteryEventTriggerCondition* New() const final {
    return new BatteryEventTriggerCondition();
  }

  BatteryEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatteryEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BatteryEventTriggerCondition& from);
  void MergeFrom(const BatteryEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatteryEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.BatteryEventTriggerCondition";
  }
  protected:
  explicit BatteryEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
    kOperatorFieldNumber = 2,
  };
  // repeated .v1.model.BatteryCondition conditions = 1 [json_name = "conditions"];
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::v1::model::BatteryCondition* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BatteryCondition >*
      mutable_conditions();
  private:
  const ::v1::model::BatteryCondition& _internal_conditions(int index) const;
  ::v1::model::BatteryCondition* _internal_add_conditions();
  public:
  const ::v1::model::BatteryCondition& conditions(int index) const;
  ::v1::model::BatteryCondition* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BatteryCondition >&
      conditions() const;

  // .v1.model.ConditionOperator operator = 2 [json_name = "operator"];
  void clear_operator_();
  ::v1::model::ConditionOperator operator_() const;
  void set_operator_(::v1::model::ConditionOperator value);
  private:
  ::v1::model::ConditionOperator _internal_operator_() const;
  void _internal_set_operator_(::v1::model::ConditionOperator value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.BatteryEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BatteryCondition > conditions_;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class RegexEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.RegexEventTriggerCondition) */ {
 public:
  inline RegexEventTriggerCondition() : RegexEventTriggerCondition(nullptr) {}
  ~RegexEventTriggerCondition() override;
  explicit constexpr RegexEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegexEventTriggerCondition(const RegexEventTriggerCondition& from);
  RegexEventTriggerCondition(RegexEventTriggerCondition&& from) noexcept
    : RegexEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline RegexEventTriggerCondition& operator=(const RegexEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegexEventTriggerCondition& operator=(RegexEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegexEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegexEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const RegexEventTriggerCondition*>(
               &_RegexEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RegexEventTriggerCondition& a, RegexEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(RegexEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegexEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegexEventTriggerCondition* New() const final {
    return new RegexEventTriggerCondition();
  }

  RegexEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegexEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegexEventTriggerCondition& from);
  void MergeFrom(const RegexEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegexEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.RegexEventTriggerCondition";
  }
  protected:
  explicit RegexEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.RegexEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class BitsetEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.BitsetEventTriggerCondition) */ {
 public:
  inline BitsetEventTriggerCondition() : BitsetEventTriggerCondition(nullptr) {}
  ~BitsetEventTriggerCondition() override;
  explicit constexpr BitsetEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitsetEventTriggerCondition(const BitsetEventTriggerCondition& from);
  BitsetEventTriggerCondition(BitsetEventTriggerCondition&& from) noexcept
    : BitsetEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline BitsetEventTriggerCondition& operator=(const BitsetEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitsetEventTriggerCondition& operator=(BitsetEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitsetEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitsetEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const BitsetEventTriggerCondition*>(
               &_BitsetEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BitsetEventTriggerCondition& a, BitsetEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(BitsetEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitsetEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BitsetEventTriggerCondition* New() const final {
    return new BitsetEventTriggerCondition();
  }

  BitsetEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BitsetEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BitsetEventTriggerCondition& from);
  void MergeFrom(const BitsetEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitsetEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.BitsetEventTriggerCondition";
  }
  protected:
  explicit BitsetEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitConditionsFieldNumber = 1,
    kOperatorFieldNumber = 2,
  };
  // repeated .v1.model.BitsetCondition bit_conditions = 1 [json_name = "bitConditions"];
  int bit_conditions_size() const;
  private:
  int _internal_bit_conditions_size() const;
  public:
  void clear_bit_conditions();
  ::v1::model::BitsetCondition* mutable_bit_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BitsetCondition >*
      mutable_bit_conditions();
  private:
  const ::v1::model::BitsetCondition& _internal_bit_conditions(int index) const;
  ::v1::model::BitsetCondition* _internal_add_bit_conditions();
  public:
  const ::v1::model::BitsetCondition& bit_conditions(int index) const;
  ::v1::model::BitsetCondition* add_bit_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BitsetCondition >&
      bit_conditions() const;

  // .v1.model.ConditionOperator operator = 2 [json_name = "operator"];
  void clear_operator_();
  ::v1::model::ConditionOperator operator_() const;
  void set_operator_(::v1::model::ConditionOperator value);
  private:
  ::v1::model::ConditionOperator _internal_operator_() const;
  void _internal_set_operator_(::v1::model::ConditionOperator value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.BitsetEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BitsetCondition > bit_conditions_;
  int operator__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class BitsetCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.BitsetCondition) */ {
 public:
  inline BitsetCondition() : BitsetCondition(nullptr) {}
  ~BitsetCondition() override;
  explicit constexpr BitsetCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BitsetCondition(const BitsetCondition& from);
  BitsetCondition(BitsetCondition&& from) noexcept
    : BitsetCondition() {
    *this = ::std::move(from);
  }

  inline BitsetCondition& operator=(const BitsetCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline BitsetCondition& operator=(BitsetCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BitsetCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const BitsetCondition* internal_default_instance() {
    return reinterpret_cast<const BitsetCondition*>(
               &_BitsetCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BitsetCondition& a, BitsetCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(BitsetCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BitsetCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BitsetCondition* New() const final {
    return new BitsetCondition();
  }

  BitsetCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BitsetCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BitsetCondition& from);
  void MergeFrom(const BitsetCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BitsetCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.BitsetCondition";
  }
  protected:
  explicit BitsetCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kTrueFieldNumber = 2,
    kFalseFieldNumber = 3,
  };
  // string key = 1 [json_name = "key"];
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // bool true = 2 [json_name = "true"];
  void clear_true_();
  bool true_() const;
  void set_true_(bool value);
  private:
  bool _internal_true_() const;
  void _internal_set_true_(bool value);
  public:

  // bool false = 3 [json_name = "false"];
  void clear_false_();
  bool false_() const;
  void set_false_(bool value);
  private:
  bool _internal_false_() const;
  void _internal_set_false_(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.BitsetCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  bool true__;
  bool false__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class JsonEventTriggerCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.JsonEventTriggerCondition) */ {
 public:
  inline JsonEventTriggerCondition() : JsonEventTriggerCondition(nullptr) {}
  ~JsonEventTriggerCondition() override;
  explicit constexpr JsonEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  JsonEventTriggerCondition(const JsonEventTriggerCondition& from);
  JsonEventTriggerCondition(JsonEventTriggerCondition&& from) noexcept
    : JsonEventTriggerCondition() {
    *this = ::std::move(from);
  }

  inline JsonEventTriggerCondition& operator=(const JsonEventTriggerCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline JsonEventTriggerCondition& operator=(JsonEventTriggerCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const JsonEventTriggerCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const JsonEventTriggerCondition* internal_default_instance() {
    return reinterpret_cast<const JsonEventTriggerCondition*>(
               &_JsonEventTriggerCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(JsonEventTriggerCondition& a, JsonEventTriggerCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(JsonEventTriggerCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(JsonEventTriggerCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline JsonEventTriggerCondition* New() const final {
    return new JsonEventTriggerCondition();
  }

  JsonEventTriggerCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<JsonEventTriggerCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const JsonEventTriggerCondition& from);
  void MergeFrom(const JsonEventTriggerCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JsonEventTriggerCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.JsonEventTriggerCondition";
  }
  protected:
  explicit JsonEventTriggerCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJqQueryFieldNumber = 1,
  };
  // string jqQuery = 1 [json_name = "jqQuery"];
  void clear_jqquery();
  const std::string& jqquery() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_jqquery(ArgT0&& arg0, ArgT... args);
  std::string* mutable_jqquery();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_jqquery();
  void set_allocated_jqquery(std::string* jqquery);
  private:
  const std::string& _internal_jqquery() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_jqquery(const std::string& value);
  std::string* _internal_mutable_jqquery();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.JsonEventTriggerCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jqquery_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// -------------------------------------------------------------------

class StatefulTriggerConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.StatefulTriggerConfiguration) */ {
 public:
  inline StatefulTriggerConfiguration() : StatefulTriggerConfiguration(nullptr) {}
  ~StatefulTriggerConfiguration() override;
  explicit constexpr StatefulTriggerConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatefulTriggerConfiguration(const StatefulTriggerConfiguration& from);
  StatefulTriggerConfiguration(StatefulTriggerConfiguration&& from) noexcept
    : StatefulTriggerConfiguration() {
    *this = ::std::move(from);
  }

  inline StatefulTriggerConfiguration& operator=(const StatefulTriggerConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatefulTriggerConfiguration& operator=(StatefulTriggerConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatefulTriggerConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatefulTriggerConfiguration* internal_default_instance() {
    return reinterpret_cast<const StatefulTriggerConfiguration*>(
               &_StatefulTriggerConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StatefulTriggerConfiguration& a, StatefulTriggerConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(StatefulTriggerConfiguration* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatefulTriggerConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StatefulTriggerConfiguration* New() const final {
    return new StatefulTriggerConfiguration();
  }

  StatefulTriggerConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StatefulTriggerConfiguration>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StatefulTriggerConfiguration& from);
  void MergeFrom(const StatefulTriggerConfiguration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatefulTriggerConfiguration* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.StatefulTriggerConfiguration";
  }
  protected:
  explicit StatefulTriggerConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmitOnEnteringStateFieldNumber = 1,
    kEmitOnLeavingStateFieldNumber = 2,
  };
  // bool emitOnEnteringState = 1 [json_name = "emitOnEnteringState"];
  void clear_emitonenteringstate();
  bool emitonenteringstate() const;
  void set_emitonenteringstate(bool value);
  private:
  bool _internal_emitonenteringstate() const;
  void _internal_set_emitonenteringstate(bool value);
  public:

  // bool emitOnLeavingState = 2 [json_name = "emitOnLeavingState"];
  void clear_emitonleavingstate();
  bool emitonleavingstate() const;
  void set_emitonleavingstate(bool value);
  private:
  bool _internal_emitonleavingstate() const;
  void _internal_set_emitonleavingstate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.StatefulTriggerConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool emitonenteringstate_;
  bool emitonleavingstate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fevent_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Event

// int64 timestamp = 1 [json_name = "timestamp"];
inline void Event::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Event::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Event::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.timestamp)
  return _internal_timestamp();
}
inline void Event::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void Event::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.Event.timestamp)
}

// int64 end_timestamp = 8 [json_name = "endTimestamp"];
inline void Event::clear_end_timestamp() {
  end_timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Event::_internal_end_timestamp() const {
  return end_timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Event::end_timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.end_timestamp)
  return _internal_end_timestamp();
}
inline void Event::_internal_set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  end_timestamp_ = value;
}
inline void Event::set_end_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.Event.end_timestamp)
}

// string message = 2 [json_name = "message"];
inline void Event::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& Event::message() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Event.message)
}
inline std::string* Event::mutable_message() {
  // @@protoc_insertion_point(field_mutable:v1.model.Event.message)
  return _internal_mutable_message();
}
inline const std::string& Event::_internal_message() const {
  return message_.Get();
}
inline void Event::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_message() {
  // @@protoc_insertion_point(field_release:v1.model.Event.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Event.message)
}

// string stream_name = 3 [json_name = "streamName"];
inline void Event::clear_stream_name() {
  stream_name_.ClearToEmpty();
}
inline const std::string& Event::stream_name() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.stream_name)
  return _internal_stream_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_stream_name(ArgT0&& arg0, ArgT... args) {
 
 stream_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Event.stream_name)
}
inline std::string* Event::mutable_stream_name() {
  // @@protoc_insertion_point(field_mutable:v1.model.Event.stream_name)
  return _internal_mutable_stream_name();
}
inline const std::string& Event::_internal_stream_name() const {
  return stream_name_.Get();
}
inline void Event::_internal_set_stream_name(const std::string& value) {
  
  stream_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_stream_name() {
  
  return stream_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_stream_name() {
  // @@protoc_insertion_point(field_release:v1.model.Event.stream_name)
  return stream_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_stream_name(std::string* stream_name) {
  if (stream_name != nullptr) {
    
  } else {
    
  }
  stream_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Event.stream_name)
}

// string stream_type = 4 [json_name = "streamType"];
inline void Event::clear_stream_type() {
  stream_type_.ClearToEmpty();
}
inline const std::string& Event::stream_type() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.stream_type)
  return _internal_stream_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_stream_type(ArgT0&& arg0, ArgT... args) {
 
 stream_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Event.stream_type)
}
inline std::string* Event::mutable_stream_type() {
  // @@protoc_insertion_point(field_mutable:v1.model.Event.stream_type)
  return _internal_mutable_stream_type();
}
inline const std::string& Event::_internal_stream_type() const {
  return stream_type_.Get();
}
inline void Event::_internal_set_stream_type(const std::string& value) {
  
  stream_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_stream_type() {
  
  return stream_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_stream_type() {
  // @@protoc_insertion_point(field_release:v1.model.Event.stream_type)
  return stream_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_stream_type(std::string* stream_type) {
  if (stream_type != nullptr) {
    
  } else {
    
  }
  stream_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream_type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Event.stream_type)
}

// bool notification_enabled = 5 [json_name = "notificationEnabled"];
inline void Event::clear_notification_enabled() {
  notification_enabled_ = false;
}
inline bool Event::_internal_notification_enabled() const {
  return notification_enabled_;
}
inline bool Event::notification_enabled() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.notification_enabled)
  return _internal_notification_enabled();
}
inline void Event::_internal_set_notification_enabled(bool value) {
  
  notification_enabled_ = value;
}
inline void Event::set_notification_enabled(bool value) {
  _internal_set_notification_enabled(value);
  // @@protoc_insertion_point(field_set:v1.model.Event.notification_enabled)
}

// .v1.model.Severity severity = 9 [json_name = "severity"];
inline void Event::clear_severity() {
  severity_ = 0;
}
inline ::v1::model::Severity Event::_internal_severity() const {
  return static_cast< ::v1::model::Severity >(severity_);
}
inline ::v1::model::Severity Event::severity() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.severity)
  return _internal_severity();
}
inline void Event::_internal_set_severity(::v1::model::Severity value) {
  
  severity_ = value;
}
inline void Event::set_severity(::v1::model::Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:v1.model.Event.severity)
}

// string id = 10 [json_name = "id"];
inline void Event::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Event::id() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Event.id)
}
inline std::string* Event::mutable_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.Event.id)
  return _internal_mutable_id();
}
inline const std::string& Event::_internal_id() const {
  return id_.Get();
}
inline void Event::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_id() {
  // @@protoc_insertion_point(field_release:v1.model.Event.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Event.id)
}

// string type = 11 [json_name = "type"];
inline void Event::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Event.type)
}
inline std::string* Event::mutable_type() {
  // @@protoc_insertion_point(field_mutable:v1.model.Event.type)
  return _internal_mutable_type();
}
inline const std::string& Event::_internal_type() const {
  return type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:v1.model.Event.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Event.type)
}

// string event_trigger_id = 12 [json_name = "eventTriggerId"];
inline void Event::clear_event_trigger_id() {
  event_trigger_id_.ClearToEmpty();
}
inline const std::string& Event::event_trigger_id() const {
  // @@protoc_insertion_point(field_get:v1.model.Event.event_trigger_id)
  return _internal_event_trigger_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_event_trigger_id(ArgT0&& arg0, ArgT... args) {
 
 event_trigger_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Event.event_trigger_id)
}
inline std::string* Event::mutable_event_trigger_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.Event.event_trigger_id)
  return _internal_mutable_event_trigger_id();
}
inline const std::string& Event::_internal_event_trigger_id() const {
  return event_trigger_id_.Get();
}
inline void Event::_internal_set_event_trigger_id(const std::string& value) {
  
  event_trigger_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_event_trigger_id() {
  
  return event_trigger_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_event_trigger_id() {
  // @@protoc_insertion_point(field_release:v1.model.Event.event_trigger_id)
  return event_trigger_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_event_trigger_id(std::string* event_trigger_id) {
  if (event_trigger_id != nullptr) {
    
  } else {
    
  }
  event_trigger_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_trigger_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Event.event_trigger_id)
}

// map<string, string> tags = 6 [json_name = "tags"];
inline int Event::_internal_tags_size() const {
  return tags_.size();
}
inline int Event::tags_size() const {
  return _internal_tags_size();
}
inline void Event::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Event::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Event::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.Event.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Event::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Event::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.Event.tags)
  return _internal_mutable_tags();
}

// -------------------------------------------------------------------

// AgentEventConfiguration

// repeated .v1.model.AgentEventTrigger event_triggers = 1 [json_name = "eventTriggers"];
inline int AgentEventConfiguration::_internal_event_triggers_size() const {
  return event_triggers_.size();
}
inline int AgentEventConfiguration::event_triggers_size() const {
  return _internal_event_triggers_size();
}
inline void AgentEventConfiguration::clear_event_triggers() {
  event_triggers_.Clear();
}
inline ::v1::model::AgentEventTrigger* AgentEventConfiguration::mutable_event_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventConfiguration.event_triggers)
  return event_triggers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >*
AgentEventConfiguration::mutable_event_triggers() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.AgentEventConfiguration.event_triggers)
  return &event_triggers_;
}
inline const ::v1::model::AgentEventTrigger& AgentEventConfiguration::_internal_event_triggers(int index) const {
  return event_triggers_.Get(index);
}
inline const ::v1::model::AgentEventTrigger& AgentEventConfiguration::event_triggers(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventConfiguration.event_triggers)
  return _internal_event_triggers(index);
}
inline ::v1::model::AgentEventTrigger* AgentEventConfiguration::_internal_add_event_triggers() {
  return event_triggers_.Add();
}
inline ::v1::model::AgentEventTrigger* AgentEventConfiguration::add_event_triggers() {
  // @@protoc_insertion_point(field_add:v1.model.AgentEventConfiguration.event_triggers)
  return _internal_add_event_triggers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >&
AgentEventConfiguration::event_triggers() const {
  // @@protoc_insertion_point(field_list:v1.model.AgentEventConfiguration.event_triggers)
  return event_triggers_;
}

// repeated .v1.model.AgentEventTrigger stateful_event_triggers = 3 [json_name = "statefulEventTriggers"];
inline int AgentEventConfiguration::_internal_stateful_event_triggers_size() const {
  return stateful_event_triggers_.size();
}
inline int AgentEventConfiguration::stateful_event_triggers_size() const {
  return _internal_stateful_event_triggers_size();
}
inline void AgentEventConfiguration::clear_stateful_event_triggers() {
  stateful_event_triggers_.Clear();
}
inline ::v1::model::AgentEventTrigger* AgentEventConfiguration::mutable_stateful_event_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventConfiguration.stateful_event_triggers)
  return stateful_event_triggers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >*
AgentEventConfiguration::mutable_stateful_event_triggers() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.AgentEventConfiguration.stateful_event_triggers)
  return &stateful_event_triggers_;
}
inline const ::v1::model::AgentEventTrigger& AgentEventConfiguration::_internal_stateful_event_triggers(int index) const {
  return stateful_event_triggers_.Get(index);
}
inline const ::v1::model::AgentEventTrigger& AgentEventConfiguration::stateful_event_triggers(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventConfiguration.stateful_event_triggers)
  return _internal_stateful_event_triggers(index);
}
inline ::v1::model::AgentEventTrigger* AgentEventConfiguration::_internal_add_stateful_event_triggers() {
  return stateful_event_triggers_.Add();
}
inline ::v1::model::AgentEventTrigger* AgentEventConfiguration::add_stateful_event_triggers() {
  // @@protoc_insertion_point(field_add:v1.model.AgentEventConfiguration.stateful_event_triggers)
  return _internal_add_stateful_event_triggers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::AgentEventTrigger >&
AgentEventConfiguration::stateful_event_triggers() const {
  // @@protoc_insertion_point(field_list:v1.model.AgentEventConfiguration.stateful_event_triggers)
  return stateful_event_triggers_;
}

// int64 last_updated = 2 [json_name = "lastUpdated"];
inline void AgentEventConfiguration::clear_last_updated() {
  last_updated_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AgentEventConfiguration::_internal_last_updated() const {
  return last_updated_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AgentEventConfiguration::last_updated() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventConfiguration.last_updated)
  return _internal_last_updated();
}
inline void AgentEventConfiguration::_internal_set_last_updated(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  last_updated_ = value;
}
inline void AgentEventConfiguration::set_last_updated(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_last_updated(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentEventConfiguration.last_updated)
}

// -------------------------------------------------------------------

// AgentEventTrigger

// string id = 1 [json_name = "id"];
inline void AgentEventTrigger::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& AgentEventTrigger::id() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEventTrigger::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.id)
}
inline std::string* AgentEventTrigger::mutable_id() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.id)
  return _internal_mutable_id();
}
inline const std::string& AgentEventTrigger::_internal_id() const {
  return id_.Get();
}
inline void AgentEventTrigger::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::release_id() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentEventTrigger::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.id)
}

// string stream = 2 [json_name = "stream"];
inline void AgentEventTrigger::clear_stream() {
  stream_.ClearToEmpty();
}
inline const std::string& AgentEventTrigger::stream() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEventTrigger::set_stream(ArgT0&& arg0, ArgT... args) {
 
 stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.stream)
}
inline std::string* AgentEventTrigger::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.stream)
  return _internal_mutable_stream();
}
inline const std::string& AgentEventTrigger::_internal_stream() const {
  return stream_.Get();
}
inline void AgentEventTrigger::_internal_set_stream(const std::string& value) {
  
  stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::_internal_mutable_stream() {
  
  return stream_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::release_stream() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.stream)
  return stream_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentEventTrigger::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  stream_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.stream)
}

// int64 interval = 3 [json_name = "interval"];
inline void AgentEventTrigger::clear_interval() {
  interval_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AgentEventTrigger::_internal_interval() const {
  return interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AgentEventTrigger::interval() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.interval)
  return _internal_interval();
}
inline void AgentEventTrigger::_internal_set_interval(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  interval_ = value;
}
inline void AgentEventTrigger::set_interval(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.interval)
}

// .v1.model.Condition condition = 4 [json_name = "condition"];
inline bool AgentEventTrigger::_internal_has_condition() const {
  return this != internal_default_instance() && condition_ != nullptr;
}
inline bool AgentEventTrigger::has_condition() const {
  return _internal_has_condition();
}
inline void AgentEventTrigger::clear_condition() {
  if (GetArenaForAllocation() == nullptr && condition_ != nullptr) {
    delete condition_;
  }
  condition_ = nullptr;
}
inline const ::v1::model::Condition& AgentEventTrigger::_internal_condition() const {
  const ::v1::model::Condition* p = condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::Condition&>(
      ::v1::model::_Condition_default_instance_);
}
inline const ::v1::model::Condition& AgentEventTrigger::condition() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.condition)
  return _internal_condition();
}
inline void AgentEventTrigger::unsafe_arena_set_allocated_condition(
    ::v1::model::Condition* condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentEventTrigger.condition)
}
inline ::v1::model::Condition* AgentEventTrigger::release_condition() {
  
  ::v1::model::Condition* temp = condition_;
  condition_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::Condition* AgentEventTrigger::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.condition)
  
  ::v1::model::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::v1::model::Condition* AgentEventTrigger::_internal_mutable_condition() {
  
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::Condition>(GetArenaForAllocation());
    condition_ = p;
  }
  return condition_;
}
inline ::v1::model::Condition* AgentEventTrigger::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.condition)
  return _internal_mutable_condition();
}
inline void AgentEventTrigger::set_allocated_condition(::v1::model::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::Condition>::GetOwningArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.condition)
}

// .v1.model.Condition exitCondition = 5 [json_name = "exitCondition"];
inline bool AgentEventTrigger::_internal_has_exitcondition() const {
  return this != internal_default_instance() && exitcondition_ != nullptr;
}
inline bool AgentEventTrigger::has_exitcondition() const {
  return _internal_has_exitcondition();
}
inline void AgentEventTrigger::clear_exitcondition() {
  if (GetArenaForAllocation() == nullptr && exitcondition_ != nullptr) {
    delete exitcondition_;
  }
  exitcondition_ = nullptr;
}
inline const ::v1::model::Condition& AgentEventTrigger::_internal_exitcondition() const {
  const ::v1::model::Condition* p = exitcondition_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::Condition&>(
      ::v1::model::_Condition_default_instance_);
}
inline const ::v1::model::Condition& AgentEventTrigger::exitcondition() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.exitCondition)
  return _internal_exitcondition();
}
inline void AgentEventTrigger::unsafe_arena_set_allocated_exitcondition(
    ::v1::model::Condition* exitcondition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(exitcondition_);
  }
  exitcondition_ = exitcondition;
  if (exitcondition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentEventTrigger.exitCondition)
}
inline ::v1::model::Condition* AgentEventTrigger::release_exitcondition() {
  
  ::v1::model::Condition* temp = exitcondition_;
  exitcondition_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::Condition* AgentEventTrigger::unsafe_arena_release_exitcondition() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.exitCondition)
  
  ::v1::model::Condition* temp = exitcondition_;
  exitcondition_ = nullptr;
  return temp;
}
inline ::v1::model::Condition* AgentEventTrigger::_internal_mutable_exitcondition() {
  
  if (exitcondition_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::Condition>(GetArenaForAllocation());
    exitcondition_ = p;
  }
  return exitcondition_;
}
inline ::v1::model::Condition* AgentEventTrigger::mutable_exitcondition() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.exitCondition)
  return _internal_mutable_exitcondition();
}
inline void AgentEventTrigger::set_allocated_exitcondition(::v1::model::Condition* exitcondition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete exitcondition_;
  }
  if (exitcondition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::Condition>::GetOwningArena(exitcondition);
    if (message_arena != submessage_arena) {
      exitcondition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exitcondition, submessage_arena);
    }
    
  } else {
    
  }
  exitcondition_ = exitcondition;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.exitCondition)
}

// bool isStatefulTrigger = 6 [json_name = "isStatefulTrigger"];
inline void AgentEventTrigger::clear_isstatefultrigger() {
  isstatefultrigger_ = false;
}
inline bool AgentEventTrigger::_internal_isstatefultrigger() const {
  return isstatefultrigger_;
}
inline bool AgentEventTrigger::isstatefultrigger() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.isStatefulTrigger)
  return _internal_isstatefultrigger();
}
inline void AgentEventTrigger::_internal_set_isstatefultrigger(bool value) {
  
  isstatefultrigger_ = value;
}
inline void AgentEventTrigger::set_isstatefultrigger(bool value) {
  _internal_set_isstatefultrigger(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.isStatefulTrigger)
}

// .v1.model.StatefulTriggerConfiguration statefulTriggerConfiguration = 7 [json_name = "statefulTriggerConfiguration"];
inline bool AgentEventTrigger::_internal_has_statefultriggerconfiguration() const {
  return this != internal_default_instance() && statefultriggerconfiguration_ != nullptr;
}
inline bool AgentEventTrigger::has_statefultriggerconfiguration() const {
  return _internal_has_statefultriggerconfiguration();
}
inline void AgentEventTrigger::clear_statefultriggerconfiguration() {
  if (GetArenaForAllocation() == nullptr && statefultriggerconfiguration_ != nullptr) {
    delete statefultriggerconfiguration_;
  }
  statefultriggerconfiguration_ = nullptr;
}
inline const ::v1::model::StatefulTriggerConfiguration& AgentEventTrigger::_internal_statefultriggerconfiguration() const {
  const ::v1::model::StatefulTriggerConfiguration* p = statefultriggerconfiguration_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::StatefulTriggerConfiguration&>(
      ::v1::model::_StatefulTriggerConfiguration_default_instance_);
}
inline const ::v1::model::StatefulTriggerConfiguration& AgentEventTrigger::statefultriggerconfiguration() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.statefulTriggerConfiguration)
  return _internal_statefultriggerconfiguration();
}
inline void AgentEventTrigger::unsafe_arena_set_allocated_statefultriggerconfiguration(
    ::v1::model::StatefulTriggerConfiguration* statefultriggerconfiguration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statefultriggerconfiguration_);
  }
  statefultriggerconfiguration_ = statefultriggerconfiguration;
  if (statefultriggerconfiguration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.AgentEventTrigger.statefulTriggerConfiguration)
}
inline ::v1::model::StatefulTriggerConfiguration* AgentEventTrigger::release_statefultriggerconfiguration() {
  
  ::v1::model::StatefulTriggerConfiguration* temp = statefultriggerconfiguration_;
  statefultriggerconfiguration_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::StatefulTriggerConfiguration* AgentEventTrigger::unsafe_arena_release_statefultriggerconfiguration() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.statefulTriggerConfiguration)
  
  ::v1::model::StatefulTriggerConfiguration* temp = statefultriggerconfiguration_;
  statefultriggerconfiguration_ = nullptr;
  return temp;
}
inline ::v1::model::StatefulTriggerConfiguration* AgentEventTrigger::_internal_mutable_statefultriggerconfiguration() {
  
  if (statefultriggerconfiguration_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::StatefulTriggerConfiguration>(GetArenaForAllocation());
    statefultriggerconfiguration_ = p;
  }
  return statefultriggerconfiguration_;
}
inline ::v1::model::StatefulTriggerConfiguration* AgentEventTrigger::mutable_statefultriggerconfiguration() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.statefulTriggerConfiguration)
  return _internal_mutable_statefultriggerconfiguration();
}
inline void AgentEventTrigger::set_allocated_statefultriggerconfiguration(::v1::model::StatefulTriggerConfiguration* statefultriggerconfiguration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete statefultriggerconfiguration_;
  }
  if (statefultriggerconfiguration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::StatefulTriggerConfiguration>::GetOwningArena(statefultriggerconfiguration);
    if (message_arena != submessage_arena) {
      statefultriggerconfiguration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statefultriggerconfiguration, submessage_arena);
    }
    
  } else {
    
  }
  statefultriggerconfiguration_ = statefultriggerconfiguration;
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.statefulTriggerConfiguration)
}

// string message = 8 [json_name = "message"];
inline void AgentEventTrigger::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& AgentEventTrigger::message() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEventTrigger::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.message)
}
inline std::string* AgentEventTrigger::mutable_message() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.message)
  return _internal_mutable_message();
}
inline const std::string& AgentEventTrigger::_internal_message() const {
  return message_.Get();
}
inline void AgentEventTrigger::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::release_message() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentEventTrigger::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.message)
}

// string messageFormat = 11 [json_name = "messageFormat"];
inline void AgentEventTrigger::clear_messageformat() {
  messageformat_.ClearToEmpty();
}
inline const std::string& AgentEventTrigger::messageformat() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.messageFormat)
  return _internal_messageformat();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEventTrigger::set_messageformat(ArgT0&& arg0, ArgT... args) {
 
 messageformat_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.messageFormat)
}
inline std::string* AgentEventTrigger::mutable_messageformat() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.messageFormat)
  return _internal_mutable_messageformat();
}
inline const std::string& AgentEventTrigger::_internal_messageformat() const {
  return messageformat_.Get();
}
inline void AgentEventTrigger::_internal_set_messageformat(const std::string& value) {
  
  messageformat_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::_internal_mutable_messageformat() {
  
  return messageformat_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::release_messageformat() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.messageFormat)
  return messageformat_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentEventTrigger::set_allocated_messageformat(std::string* messageformat) {
  if (messageformat != nullptr) {
    
  } else {
    
  }
  messageformat_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), messageformat,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.messageFormat)
}

// string severity = 9 [json_name = "severity"];
inline void AgentEventTrigger::clear_severity() {
  severity_.ClearToEmpty();
}
inline const std::string& AgentEventTrigger::severity() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.severity)
  return _internal_severity();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AgentEventTrigger::set_severity(ArgT0&& arg0, ArgT... args) {
 
 severity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.severity)
}
inline std::string* AgentEventTrigger::mutable_severity() {
  // @@protoc_insertion_point(field_mutable:v1.model.AgentEventTrigger.severity)
  return _internal_mutable_severity();
}
inline const std::string& AgentEventTrigger::_internal_severity() const {
  return severity_.Get();
}
inline void AgentEventTrigger::_internal_set_severity(const std::string& value) {
  
  severity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::_internal_mutable_severity() {
  
  return severity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AgentEventTrigger::release_severity() {
  // @@protoc_insertion_point(field_release:v1.model.AgentEventTrigger.severity)
  return severity_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AgentEventTrigger::set_allocated_severity(std::string* severity) {
  if (severity != nullptr) {
    
  } else {
    
  }
  severity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), severity,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.AgentEventTrigger.severity)
}

// bool notification_enabled = 10 [json_name = "notificationEnabled"];
inline void AgentEventTrigger::clear_notification_enabled() {
  notification_enabled_ = false;
}
inline bool AgentEventTrigger::_internal_notification_enabled() const {
  return notification_enabled_;
}
inline bool AgentEventTrigger::notification_enabled() const {
  // @@protoc_insertion_point(field_get:v1.model.AgentEventTrigger.notification_enabled)
  return _internal_notification_enabled();
}
inline void AgentEventTrigger::_internal_set_notification_enabled(bool value) {
  
  notification_enabled_ = value;
}
inline void AgentEventTrigger::set_notification_enabled(bool value) {
  _internal_set_notification_enabled(value);
  // @@protoc_insertion_point(field_set:v1.model.AgentEventTrigger.notification_enabled)
}

// -------------------------------------------------------------------

// Condition

// string stream = 1 [json_name = "stream"];
inline void Condition::clear_stream() {
  stream_.ClearToEmpty();
}
inline const std::string& Condition::stream() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Condition::set_stream(ArgT0&& arg0, ArgT... args) {
 
 stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Condition.stream)
}
inline std::string* Condition::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.stream)
  return _internal_mutable_stream();
}
inline const std::string& Condition::_internal_stream() const {
  return stream_.Get();
}
inline void Condition::_internal_set_stream(const std::string& value) {
  
  stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Condition::_internal_mutable_stream() {
  
  return stream_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Condition::release_stream() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.stream)
  return stream_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Condition::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  stream_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Condition.stream)
}

// .v1.model.PresenceEventTriggerCondition presence = 2 [json_name = "presence"];
inline bool Condition::_internal_has_presence() const {
  return condition_case() == kPresence;
}
inline bool Condition::has_presence() const {
  return _internal_has_presence();
}
inline void Condition::set_has_presence() {
  _oneof_case_[0] = kPresence;
}
inline void Condition::clear_presence() {
  if (_internal_has_presence()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.presence_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::PresenceEventTriggerCondition* Condition::release_presence() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.presence)
  if (_internal_has_presence()) {
    clear_has_condition();
      ::v1::model::PresenceEventTriggerCondition* temp = condition_.presence_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.presence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::PresenceEventTriggerCondition& Condition::_internal_presence() const {
  return _internal_has_presence()
      ? *condition_.presence_
      : reinterpret_cast< ::v1::model::PresenceEventTriggerCondition&>(::v1::model::_PresenceEventTriggerCondition_default_instance_);
}
inline const ::v1::model::PresenceEventTriggerCondition& Condition::presence() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.presence)
  return _internal_presence();
}
inline ::v1::model::PresenceEventTriggerCondition* Condition::unsafe_arena_release_presence() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.presence)
  if (_internal_has_presence()) {
    clear_has_condition();
    ::v1::model::PresenceEventTriggerCondition* temp = condition_.presence_;
    condition_.presence_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_presence(::v1::model::PresenceEventTriggerCondition* presence) {
  clear_condition();
  if (presence) {
    set_has_presence();
    condition_.presence_ = presence;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.presence)
}
inline ::v1::model::PresenceEventTriggerCondition* Condition::_internal_mutable_presence() {
  if (!_internal_has_presence()) {
    clear_condition();
    set_has_presence();
    condition_.presence_ = CreateMaybeMessage< ::v1::model::PresenceEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.presence_;
}
inline ::v1::model::PresenceEventTriggerCondition* Condition::mutable_presence() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.presence)
  return _internal_mutable_presence();
}

// .v1.model.ThresholdEventTriggerCondition threshold = 3 [json_name = "threshold"];
inline bool Condition::_internal_has_threshold() const {
  return condition_case() == kThreshold;
}
inline bool Condition::has_threshold() const {
  return _internal_has_threshold();
}
inline void Condition::set_has_threshold() {
  _oneof_case_[0] = kThreshold;
}
inline void Condition::clear_threshold() {
  if (_internal_has_threshold()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.threshold_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::ThresholdEventTriggerCondition* Condition::release_threshold() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.threshold)
  if (_internal_has_threshold()) {
    clear_has_condition();
      ::v1::model::ThresholdEventTriggerCondition* temp = condition_.threshold_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.threshold_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::ThresholdEventTriggerCondition& Condition::_internal_threshold() const {
  return _internal_has_threshold()
      ? *condition_.threshold_
      : reinterpret_cast< ::v1::model::ThresholdEventTriggerCondition&>(::v1::model::_ThresholdEventTriggerCondition_default_instance_);
}
inline const ::v1::model::ThresholdEventTriggerCondition& Condition::threshold() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.threshold)
  return _internal_threshold();
}
inline ::v1::model::ThresholdEventTriggerCondition* Condition::unsafe_arena_release_threshold() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.threshold)
  if (_internal_has_threshold()) {
    clear_has_condition();
    ::v1::model::ThresholdEventTriggerCondition* temp = condition_.threshold_;
    condition_.threshold_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_threshold(::v1::model::ThresholdEventTriggerCondition* threshold) {
  clear_condition();
  if (threshold) {
    set_has_threshold();
    condition_.threshold_ = threshold;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.threshold)
}
inline ::v1::model::ThresholdEventTriggerCondition* Condition::_internal_mutable_threshold() {
  if (!_internal_has_threshold()) {
    clear_condition();
    set_has_threshold();
    condition_.threshold_ = CreateMaybeMessage< ::v1::model::ThresholdEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.threshold_;
}
inline ::v1::model::ThresholdEventTriggerCondition* Condition::mutable_threshold() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.threshold)
  return _internal_mutable_threshold();
}

// .v1.model.RegexEventTriggerCondition regex = 4 [json_name = "regex"];
inline bool Condition::_internal_has_regex() const {
  return condition_case() == kRegex;
}
inline bool Condition::has_regex() const {
  return _internal_has_regex();
}
inline void Condition::set_has_regex() {
  _oneof_case_[0] = kRegex;
}
inline void Condition::clear_regex() {
  if (_internal_has_regex()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.regex_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::RegexEventTriggerCondition* Condition::release_regex() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.regex)
  if (_internal_has_regex()) {
    clear_has_condition();
      ::v1::model::RegexEventTriggerCondition* temp = condition_.regex_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.regex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::RegexEventTriggerCondition& Condition::_internal_regex() const {
  return _internal_has_regex()
      ? *condition_.regex_
      : reinterpret_cast< ::v1::model::RegexEventTriggerCondition&>(::v1::model::_RegexEventTriggerCondition_default_instance_);
}
inline const ::v1::model::RegexEventTriggerCondition& Condition::regex() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.regex)
  return _internal_regex();
}
inline ::v1::model::RegexEventTriggerCondition* Condition::unsafe_arena_release_regex() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.regex)
  if (_internal_has_regex()) {
    clear_has_condition();
    ::v1::model::RegexEventTriggerCondition* temp = condition_.regex_;
    condition_.regex_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_regex(::v1::model::RegexEventTriggerCondition* regex) {
  clear_condition();
  if (regex) {
    set_has_regex();
    condition_.regex_ = regex;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.regex)
}
inline ::v1::model::RegexEventTriggerCondition* Condition::_internal_mutable_regex() {
  if (!_internal_has_regex()) {
    clear_condition();
    set_has_regex();
    condition_.regex_ = CreateMaybeMessage< ::v1::model::RegexEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.regex_;
}
inline ::v1::model::RegexEventTriggerCondition* Condition::mutable_regex() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.regex)
  return _internal_mutable_regex();
}

// .v1.model.BitsetEventTriggerCondition bitset = 5 [json_name = "bitset"];
inline bool Condition::_internal_has_bitset() const {
  return condition_case() == kBitset;
}
inline bool Condition::has_bitset() const {
  return _internal_has_bitset();
}
inline void Condition::set_has_bitset() {
  _oneof_case_[0] = kBitset;
}
inline void Condition::clear_bitset() {
  if (_internal_has_bitset()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.bitset_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::BitsetEventTriggerCondition* Condition::release_bitset() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.bitset)
  if (_internal_has_bitset()) {
    clear_has_condition();
      ::v1::model::BitsetEventTriggerCondition* temp = condition_.bitset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::BitsetEventTriggerCondition& Condition::_internal_bitset() const {
  return _internal_has_bitset()
      ? *condition_.bitset_
      : reinterpret_cast< ::v1::model::BitsetEventTriggerCondition&>(::v1::model::_BitsetEventTriggerCondition_default_instance_);
}
inline const ::v1::model::BitsetEventTriggerCondition& Condition::bitset() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.bitset)
  return _internal_bitset();
}
inline ::v1::model::BitsetEventTriggerCondition* Condition::unsafe_arena_release_bitset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.bitset)
  if (_internal_has_bitset()) {
    clear_has_condition();
    ::v1::model::BitsetEventTriggerCondition* temp = condition_.bitset_;
    condition_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_bitset(::v1::model::BitsetEventTriggerCondition* bitset) {
  clear_condition();
  if (bitset) {
    set_has_bitset();
    condition_.bitset_ = bitset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.bitset)
}
inline ::v1::model::BitsetEventTriggerCondition* Condition::_internal_mutable_bitset() {
  if (!_internal_has_bitset()) {
    clear_condition();
    set_has_bitset();
    condition_.bitset_ = CreateMaybeMessage< ::v1::model::BitsetEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.bitset_;
}
inline ::v1::model::BitsetEventTriggerCondition* Condition::mutable_bitset() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.bitset)
  return _internal_mutable_bitset();
}

// .v1.model.BatteryEventTriggerCondition battery = 6 [json_name = "battery"];
inline bool Condition::_internal_has_battery() const {
  return condition_case() == kBattery;
}
inline bool Condition::has_battery() const {
  return _internal_has_battery();
}
inline void Condition::set_has_battery() {
  _oneof_case_[0] = kBattery;
}
inline void Condition::clear_battery() {
  if (_internal_has_battery()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.battery_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::BatteryEventTriggerCondition* Condition::release_battery() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.battery)
  if (_internal_has_battery()) {
    clear_has_condition();
      ::v1::model::BatteryEventTriggerCondition* temp = condition_.battery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::BatteryEventTriggerCondition& Condition::_internal_battery() const {
  return _internal_has_battery()
      ? *condition_.battery_
      : reinterpret_cast< ::v1::model::BatteryEventTriggerCondition&>(::v1::model::_BatteryEventTriggerCondition_default_instance_);
}
inline const ::v1::model::BatteryEventTriggerCondition& Condition::battery() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.battery)
  return _internal_battery();
}
inline ::v1::model::BatteryEventTriggerCondition* Condition::unsafe_arena_release_battery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.battery)
  if (_internal_has_battery()) {
    clear_has_condition();
    ::v1::model::BatteryEventTriggerCondition* temp = condition_.battery_;
    condition_.battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_battery(::v1::model::BatteryEventTriggerCondition* battery) {
  clear_condition();
  if (battery) {
    set_has_battery();
    condition_.battery_ = battery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.battery)
}
inline ::v1::model::BatteryEventTriggerCondition* Condition::_internal_mutable_battery() {
  if (!_internal_has_battery()) {
    clear_condition();
    set_has_battery();
    condition_.battery_ = CreateMaybeMessage< ::v1::model::BatteryEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.battery_;
}
inline ::v1::model::BatteryEventTriggerCondition* Condition::mutable_battery() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.battery)
  return _internal_mutable_battery();
}

// .v1.model.NumericSetEventTriggerCondition numeric = 7 [json_name = "numeric"];
inline bool Condition::_internal_has_numeric() const {
  return condition_case() == kNumeric;
}
inline bool Condition::has_numeric() const {
  return _internal_has_numeric();
}
inline void Condition::set_has_numeric() {
  _oneof_case_[0] = kNumeric;
}
inline void Condition::clear_numeric() {
  if (_internal_has_numeric()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.numeric_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::NumericSetEventTriggerCondition* Condition::release_numeric() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.numeric)
  if (_internal_has_numeric()) {
    clear_has_condition();
      ::v1::model::NumericSetEventTriggerCondition* temp = condition_.numeric_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::NumericSetEventTriggerCondition& Condition::_internal_numeric() const {
  return _internal_has_numeric()
      ? *condition_.numeric_
      : reinterpret_cast< ::v1::model::NumericSetEventTriggerCondition&>(::v1::model::_NumericSetEventTriggerCondition_default_instance_);
}
inline const ::v1::model::NumericSetEventTriggerCondition& Condition::numeric() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.numeric)
  return _internal_numeric();
}
inline ::v1::model::NumericSetEventTriggerCondition* Condition::unsafe_arena_release_numeric() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.numeric)
  if (_internal_has_numeric()) {
    clear_has_condition();
    ::v1::model::NumericSetEventTriggerCondition* temp = condition_.numeric_;
    condition_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_numeric(::v1::model::NumericSetEventTriggerCondition* numeric) {
  clear_condition();
  if (numeric) {
    set_has_numeric();
    condition_.numeric_ = numeric;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.numeric)
}
inline ::v1::model::NumericSetEventTriggerCondition* Condition::_internal_mutable_numeric() {
  if (!_internal_has_numeric()) {
    clear_condition();
    set_has_numeric();
    condition_.numeric_ = CreateMaybeMessage< ::v1::model::NumericSetEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.numeric_;
}
inline ::v1::model::NumericSetEventTriggerCondition* Condition::mutable_numeric() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.numeric)
  return _internal_mutable_numeric();
}

// .v1.model.JsonEventTriggerCondition json = 8 [json_name = "json"];
inline bool Condition::_internal_has_json() const {
  return condition_case() == kJson;
}
inline bool Condition::has_json() const {
  return _internal_has_json();
}
inline void Condition::set_has_json() {
  _oneof_case_[0] = kJson;
}
inline void Condition::clear_json() {
  if (_internal_has_json()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.json_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::JsonEventTriggerCondition* Condition::release_json() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.json)
  if (_internal_has_json()) {
    clear_has_condition();
      ::v1::model::JsonEventTriggerCondition* temp = condition_.json_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::JsonEventTriggerCondition& Condition::_internal_json() const {
  return _internal_has_json()
      ? *condition_.json_
      : reinterpret_cast< ::v1::model::JsonEventTriggerCondition&>(::v1::model::_JsonEventTriggerCondition_default_instance_);
}
inline const ::v1::model::JsonEventTriggerCondition& Condition::json() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.json)
  return _internal_json();
}
inline ::v1::model::JsonEventTriggerCondition* Condition::unsafe_arena_release_json() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.json)
  if (_internal_has_json()) {
    clear_has_condition();
    ::v1::model::JsonEventTriggerCondition* temp = condition_.json_;
    condition_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_json(::v1::model::JsonEventTriggerCondition* json) {
  clear_condition();
  if (json) {
    set_has_json();
    condition_.json_ = json;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.json)
}
inline ::v1::model::JsonEventTriggerCondition* Condition::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_condition();
    set_has_json();
    condition_.json_ = CreateMaybeMessage< ::v1::model::JsonEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.json_;
}
inline ::v1::model::JsonEventTriggerCondition* Condition::mutable_json() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.json)
  return _internal_mutable_json();
}

// .v1.model.AutoresolveEventTriggerCondition autoresolve = 9 [json_name = "autoresolve"];
inline bool Condition::_internal_has_autoresolve() const {
  return condition_case() == kAutoresolve;
}
inline bool Condition::has_autoresolve() const {
  return _internal_has_autoresolve();
}
inline void Condition::set_has_autoresolve() {
  _oneof_case_[0] = kAutoresolve;
}
inline void Condition::clear_autoresolve() {
  if (_internal_has_autoresolve()) {
    if (GetArenaForAllocation() == nullptr) {
      delete condition_.autoresolve_;
    }
    clear_has_condition();
  }
}
inline ::v1::model::AutoresolveEventTriggerCondition* Condition::release_autoresolve() {
  // @@protoc_insertion_point(field_release:v1.model.Condition.autoresolve)
  if (_internal_has_autoresolve()) {
    clear_has_condition();
      ::v1::model::AutoresolveEventTriggerCondition* temp = condition_.autoresolve_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    condition_.autoresolve_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::AutoresolveEventTriggerCondition& Condition::_internal_autoresolve() const {
  return _internal_has_autoresolve()
      ? *condition_.autoresolve_
      : reinterpret_cast< ::v1::model::AutoresolveEventTriggerCondition&>(::v1::model::_AutoresolveEventTriggerCondition_default_instance_);
}
inline const ::v1::model::AutoresolveEventTriggerCondition& Condition::autoresolve() const {
  // @@protoc_insertion_point(field_get:v1.model.Condition.autoresolve)
  return _internal_autoresolve();
}
inline ::v1::model::AutoresolveEventTriggerCondition* Condition::unsafe_arena_release_autoresolve() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Condition.autoresolve)
  if (_internal_has_autoresolve()) {
    clear_has_condition();
    ::v1::model::AutoresolveEventTriggerCondition* temp = condition_.autoresolve_;
    condition_.autoresolve_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_autoresolve(::v1::model::AutoresolveEventTriggerCondition* autoresolve) {
  clear_condition();
  if (autoresolve) {
    set_has_autoresolve();
    condition_.autoresolve_ = autoresolve;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Condition.autoresolve)
}
inline ::v1::model::AutoresolveEventTriggerCondition* Condition::_internal_mutable_autoresolve() {
  if (!_internal_has_autoresolve()) {
    clear_condition();
    set_has_autoresolve();
    condition_.autoresolve_ = CreateMaybeMessage< ::v1::model::AutoresolveEventTriggerCondition >(GetArenaForAllocation());
  }
  return condition_.autoresolve_;
}
inline ::v1::model::AutoresolveEventTriggerCondition* Condition::mutable_autoresolve() {
  // @@protoc_insertion_point(field_mutable:v1.model.Condition.autoresolve)
  return _internal_mutable_autoresolve();
}

inline bool Condition::has_condition() const {
  return condition_case() != CONDITION_NOT_SET;
}
inline void Condition::clear_has_condition() {
  _oneof_case_[0] = CONDITION_NOT_SET;
}
inline Condition::ConditionCase Condition::condition_case() const {
  return Condition::ConditionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PresenceEventTriggerCondition

// -------------------------------------------------------------------

// AutoresolveEventTriggerCondition

// -------------------------------------------------------------------

// ThresholdEventTriggerCondition

// double value = 1 [json_name = "value"];
inline void ThresholdEventTriggerCondition::clear_value() {
  value_ = 0;
}
inline double ThresholdEventTriggerCondition::_internal_value() const {
  return value_;
}
inline double ThresholdEventTriggerCondition::value() const {
  // @@protoc_insertion_point(field_get:v1.model.ThresholdEventTriggerCondition.value)
  return _internal_value();
}
inline void ThresholdEventTriggerCondition::_internal_set_value(double value) {
  
  value_ = value;
}
inline void ThresholdEventTriggerCondition::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:v1.model.ThresholdEventTriggerCondition.value)
}

// .v1.model.ThresholdOperator operator = 2 [json_name = "operator"];
inline void ThresholdEventTriggerCondition::clear_operator_() {
  operator__ = 0;
}
inline ::v1::model::ThresholdOperator ThresholdEventTriggerCondition::_internal_operator_() const {
  return static_cast< ::v1::model::ThresholdOperator >(operator__);
}
inline ::v1::model::ThresholdOperator ThresholdEventTriggerCondition::operator_() const {
  // @@protoc_insertion_point(field_get:v1.model.ThresholdEventTriggerCondition.operator)
  return _internal_operator_();
}
inline void ThresholdEventTriggerCondition::_internal_set_operator_(::v1::model::ThresholdOperator value) {
  
  operator__ = value;
}
inline void ThresholdEventTriggerCondition::set_operator_(::v1::model::ThresholdOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:v1.model.ThresholdEventTriggerCondition.operator)
}

// -------------------------------------------------------------------

// NumericCondition

// string label = 1 [json_name = "label"];
inline void NumericCondition::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& NumericCondition::label() const {
  // @@protoc_insertion_point(field_get:v1.model.NumericCondition.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NumericCondition::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.NumericCondition.label)
}
inline std::string* NumericCondition::mutable_label() {
  // @@protoc_insertion_point(field_mutable:v1.model.NumericCondition.label)
  return _internal_mutable_label();
}
inline const std::string& NumericCondition::_internal_label() const {
  return label_.Get();
}
inline void NumericCondition::_internal_set_label(const std::string& value) {
  
  label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* NumericCondition::_internal_mutable_label() {
  
  return label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* NumericCondition::release_label() {
  // @@protoc_insertion_point(field_release:v1.model.NumericCondition.label)
  return label_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void NumericCondition::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), label,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.NumericCondition.label)
}

// .v1.model.ThresholdEventTriggerCondition condition = 2 [json_name = "condition"];
inline bool NumericCondition::_internal_has_condition() const {
  return this != internal_default_instance() && condition_ != nullptr;
}
inline bool NumericCondition::has_condition() const {
  return _internal_has_condition();
}
inline void NumericCondition::clear_condition() {
  if (GetArenaForAllocation() == nullptr && condition_ != nullptr) {
    delete condition_;
  }
  condition_ = nullptr;
}
inline const ::v1::model::ThresholdEventTriggerCondition& NumericCondition::_internal_condition() const {
  const ::v1::model::ThresholdEventTriggerCondition* p = condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::ThresholdEventTriggerCondition&>(
      ::v1::model::_ThresholdEventTriggerCondition_default_instance_);
}
inline const ::v1::model::ThresholdEventTriggerCondition& NumericCondition::condition() const {
  // @@protoc_insertion_point(field_get:v1.model.NumericCondition.condition)
  return _internal_condition();
}
inline void NumericCondition::unsafe_arena_set_allocated_condition(
    ::v1::model::ThresholdEventTriggerCondition* condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.NumericCondition.condition)
}
inline ::v1::model::ThresholdEventTriggerCondition* NumericCondition::release_condition() {
  
  ::v1::model::ThresholdEventTriggerCondition* temp = condition_;
  condition_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::ThresholdEventTriggerCondition* NumericCondition::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:v1.model.NumericCondition.condition)
  
  ::v1::model::ThresholdEventTriggerCondition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::v1::model::ThresholdEventTriggerCondition* NumericCondition::_internal_mutable_condition() {
  
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::ThresholdEventTriggerCondition>(GetArenaForAllocation());
    condition_ = p;
  }
  return condition_;
}
inline ::v1::model::ThresholdEventTriggerCondition* NumericCondition::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:v1.model.NumericCondition.condition)
  return _internal_mutable_condition();
}
inline void NumericCondition::set_allocated_condition(::v1::model::ThresholdEventTriggerCondition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::ThresholdEventTriggerCondition>::GetOwningArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:v1.model.NumericCondition.condition)
}

// -------------------------------------------------------------------

// NumericSetEventTriggerCondition

// repeated .v1.model.NumericCondition conditions = 1 [json_name = "conditions"];
inline int NumericSetEventTriggerCondition::_internal_conditions_size() const {
  return conditions_.size();
}
inline int NumericSetEventTriggerCondition::conditions_size() const {
  return _internal_conditions_size();
}
inline void NumericSetEventTriggerCondition::clear_conditions() {
  conditions_.Clear();
}
inline ::v1::model::NumericCondition* NumericSetEventTriggerCondition::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.NumericSetEventTriggerCondition.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::NumericCondition >*
NumericSetEventTriggerCondition::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.NumericSetEventTriggerCondition.conditions)
  return &conditions_;
}
inline const ::v1::model::NumericCondition& NumericSetEventTriggerCondition::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::v1::model::NumericCondition& NumericSetEventTriggerCondition::conditions(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.NumericSetEventTriggerCondition.conditions)
  return _internal_conditions(index);
}
inline ::v1::model::NumericCondition* NumericSetEventTriggerCondition::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::v1::model::NumericCondition* NumericSetEventTriggerCondition::add_conditions() {
  // @@protoc_insertion_point(field_add:v1.model.NumericSetEventTriggerCondition.conditions)
  return _internal_add_conditions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::NumericCondition >&
NumericSetEventTriggerCondition::conditions() const {
  // @@protoc_insertion_point(field_list:v1.model.NumericSetEventTriggerCondition.conditions)
  return conditions_;
}

// .v1.model.ConditionOperator operator = 2 [json_name = "operator"];
inline void NumericSetEventTriggerCondition::clear_operator_() {
  operator__ = 0;
}
inline ::v1::model::ConditionOperator NumericSetEventTriggerCondition::_internal_operator_() const {
  return static_cast< ::v1::model::ConditionOperator >(operator__);
}
inline ::v1::model::ConditionOperator NumericSetEventTriggerCondition::operator_() const {
  // @@protoc_insertion_point(field_get:v1.model.NumericSetEventTriggerCondition.operator)
  return _internal_operator_();
}
inline void NumericSetEventTriggerCondition::_internal_set_operator_(::v1::model::ConditionOperator value) {
  
  operator__ = value;
}
inline void NumericSetEventTriggerCondition::set_operator_(::v1::model::ConditionOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:v1.model.NumericSetEventTriggerCondition.operator)
}

// -------------------------------------------------------------------

// BatteryCondition

// .v1.model.BatteryField field = 1 [json_name = "field"];
inline void BatteryCondition::clear_field() {
  field_ = 0;
}
inline ::v1::model::BatteryField BatteryCondition::_internal_field() const {
  return static_cast< ::v1::model::BatteryField >(field_);
}
inline ::v1::model::BatteryField BatteryCondition::field() const {
  // @@protoc_insertion_point(field_get:v1.model.BatteryCondition.field)
  return _internal_field();
}
inline void BatteryCondition::_internal_set_field(::v1::model::BatteryField value) {
  
  field_ = value;
}
inline void BatteryCondition::set_field(::v1::model::BatteryField value) {
  _internal_set_field(value);
  // @@protoc_insertion_point(field_set:v1.model.BatteryCondition.field)
}

// .v1.model.ThresholdEventTriggerCondition condition = 2 [json_name = "condition"];
inline bool BatteryCondition::_internal_has_condition() const {
  return this != internal_default_instance() && condition_ != nullptr;
}
inline bool BatteryCondition::has_condition() const {
  return _internal_has_condition();
}
inline void BatteryCondition::clear_condition() {
  if (GetArenaForAllocation() == nullptr && condition_ != nullptr) {
    delete condition_;
  }
  condition_ = nullptr;
}
inline const ::v1::model::ThresholdEventTriggerCondition& BatteryCondition::_internal_condition() const {
  const ::v1::model::ThresholdEventTriggerCondition* p = condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::ThresholdEventTriggerCondition&>(
      ::v1::model::_ThresholdEventTriggerCondition_default_instance_);
}
inline const ::v1::model::ThresholdEventTriggerCondition& BatteryCondition::condition() const {
  // @@protoc_insertion_point(field_get:v1.model.BatteryCondition.condition)
  return _internal_condition();
}
inline void BatteryCondition::unsafe_arena_set_allocated_condition(
    ::v1::model::ThresholdEventTriggerCondition* condition) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(condition_);
  }
  condition_ = condition;
  if (condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.BatteryCondition.condition)
}
inline ::v1::model::ThresholdEventTriggerCondition* BatteryCondition::release_condition() {
  
  ::v1::model::ThresholdEventTriggerCondition* temp = condition_;
  condition_ = nullptr;
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::v1::model::ThresholdEventTriggerCondition* BatteryCondition::unsafe_arena_release_condition() {
  // @@protoc_insertion_point(field_release:v1.model.BatteryCondition.condition)
  
  ::v1::model::ThresholdEventTriggerCondition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::v1::model::ThresholdEventTriggerCondition* BatteryCondition::_internal_mutable_condition() {
  
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::ThresholdEventTriggerCondition>(GetArenaForAllocation());
    condition_ = p;
  }
  return condition_;
}
inline ::v1::model::ThresholdEventTriggerCondition* BatteryCondition::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:v1.model.BatteryCondition.condition)
  return _internal_mutable_condition();
}
inline void BatteryCondition::set_allocated_condition(::v1::model::ThresholdEventTriggerCondition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::v1::model::ThresholdEventTriggerCondition>::GetOwningArena(condition);
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    
  } else {
    
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:v1.model.BatteryCondition.condition)
}

// .v1.model.ConditionOperator operator = 3 [json_name = "operator"];
inline void BatteryCondition::clear_operator_() {
  operator__ = 0;
}
inline ::v1::model::ConditionOperator BatteryCondition::_internal_operator_() const {
  return static_cast< ::v1::model::ConditionOperator >(operator__);
}
inline ::v1::model::ConditionOperator BatteryCondition::operator_() const {
  // @@protoc_insertion_point(field_get:v1.model.BatteryCondition.operator)
  return _internal_operator_();
}
inline void BatteryCondition::_internal_set_operator_(::v1::model::ConditionOperator value) {
  
  operator__ = value;
}
inline void BatteryCondition::set_operator_(::v1::model::ConditionOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:v1.model.BatteryCondition.operator)
}

// -------------------------------------------------------------------

// BatteryEventTriggerCondition

// repeated .v1.model.BatteryCondition conditions = 1 [json_name = "conditions"];
inline int BatteryEventTriggerCondition::_internal_conditions_size() const {
  return conditions_.size();
}
inline int BatteryEventTriggerCondition::conditions_size() const {
  return _internal_conditions_size();
}
inline void BatteryEventTriggerCondition::clear_conditions() {
  conditions_.Clear();
}
inline ::v1::model::BatteryCondition* BatteryEventTriggerCondition::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.BatteryEventTriggerCondition.conditions)
  return conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BatteryCondition >*
BatteryEventTriggerCondition::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.BatteryEventTriggerCondition.conditions)
  return &conditions_;
}
inline const ::v1::model::BatteryCondition& BatteryEventTriggerCondition::_internal_conditions(int index) const {
  return conditions_.Get(index);
}
inline const ::v1::model::BatteryCondition& BatteryEventTriggerCondition::conditions(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.BatteryEventTriggerCondition.conditions)
  return _internal_conditions(index);
}
inline ::v1::model::BatteryCondition* BatteryEventTriggerCondition::_internal_add_conditions() {
  return conditions_.Add();
}
inline ::v1::model::BatteryCondition* BatteryEventTriggerCondition::add_conditions() {
  // @@protoc_insertion_point(field_add:v1.model.BatteryEventTriggerCondition.conditions)
  return _internal_add_conditions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BatteryCondition >&
BatteryEventTriggerCondition::conditions() const {
  // @@protoc_insertion_point(field_list:v1.model.BatteryEventTriggerCondition.conditions)
  return conditions_;
}

// .v1.model.ConditionOperator operator = 2 [json_name = "operator"];
inline void BatteryEventTriggerCondition::clear_operator_() {
  operator__ = 0;
}
inline ::v1::model::ConditionOperator BatteryEventTriggerCondition::_internal_operator_() const {
  return static_cast< ::v1::model::ConditionOperator >(operator__);
}
inline ::v1::model::ConditionOperator BatteryEventTriggerCondition::operator_() const {
  // @@protoc_insertion_point(field_get:v1.model.BatteryEventTriggerCondition.operator)
  return _internal_operator_();
}
inline void BatteryEventTriggerCondition::_internal_set_operator_(::v1::model::ConditionOperator value) {
  
  operator__ = value;
}
inline void BatteryEventTriggerCondition::set_operator_(::v1::model::ConditionOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:v1.model.BatteryEventTriggerCondition.operator)
}

// -------------------------------------------------------------------

// RegexEventTriggerCondition

// string value = 1 [json_name = "value"];
inline void RegexEventTriggerCondition::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& RegexEventTriggerCondition::value() const {
  // @@protoc_insertion_point(field_get:v1.model.RegexEventTriggerCondition.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegexEventTriggerCondition::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.RegexEventTriggerCondition.value)
}
inline std::string* RegexEventTriggerCondition::mutable_value() {
  // @@protoc_insertion_point(field_mutable:v1.model.RegexEventTriggerCondition.value)
  return _internal_mutable_value();
}
inline const std::string& RegexEventTriggerCondition::_internal_value() const {
  return value_.Get();
}
inline void RegexEventTriggerCondition::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegexEventTriggerCondition::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegexEventTriggerCondition::release_value() {
  // @@protoc_insertion_point(field_release:v1.model.RegexEventTriggerCondition.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegexEventTriggerCondition::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.RegexEventTriggerCondition.value)
}

// -------------------------------------------------------------------

// BitsetEventTriggerCondition

// repeated .v1.model.BitsetCondition bit_conditions = 1 [json_name = "bitConditions"];
inline int BitsetEventTriggerCondition::_internal_bit_conditions_size() const {
  return bit_conditions_.size();
}
inline int BitsetEventTriggerCondition::bit_conditions_size() const {
  return _internal_bit_conditions_size();
}
inline void BitsetEventTriggerCondition::clear_bit_conditions() {
  bit_conditions_.Clear();
}
inline ::v1::model::BitsetCondition* BitsetEventTriggerCondition::mutable_bit_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.BitsetEventTriggerCondition.bit_conditions)
  return bit_conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BitsetCondition >*
BitsetEventTriggerCondition::mutable_bit_conditions() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.BitsetEventTriggerCondition.bit_conditions)
  return &bit_conditions_;
}
inline const ::v1::model::BitsetCondition& BitsetEventTriggerCondition::_internal_bit_conditions(int index) const {
  return bit_conditions_.Get(index);
}
inline const ::v1::model::BitsetCondition& BitsetEventTriggerCondition::bit_conditions(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.BitsetEventTriggerCondition.bit_conditions)
  return _internal_bit_conditions(index);
}
inline ::v1::model::BitsetCondition* BitsetEventTriggerCondition::_internal_add_bit_conditions() {
  return bit_conditions_.Add();
}
inline ::v1::model::BitsetCondition* BitsetEventTriggerCondition::add_bit_conditions() {
  // @@protoc_insertion_point(field_add:v1.model.BitsetEventTriggerCondition.bit_conditions)
  return _internal_add_bit_conditions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::BitsetCondition >&
BitsetEventTriggerCondition::bit_conditions() const {
  // @@protoc_insertion_point(field_list:v1.model.BitsetEventTriggerCondition.bit_conditions)
  return bit_conditions_;
}

// .v1.model.ConditionOperator operator = 2 [json_name = "operator"];
inline void BitsetEventTriggerCondition::clear_operator_() {
  operator__ = 0;
}
inline ::v1::model::ConditionOperator BitsetEventTriggerCondition::_internal_operator_() const {
  return static_cast< ::v1::model::ConditionOperator >(operator__);
}
inline ::v1::model::ConditionOperator BitsetEventTriggerCondition::operator_() const {
  // @@protoc_insertion_point(field_get:v1.model.BitsetEventTriggerCondition.operator)
  return _internal_operator_();
}
inline void BitsetEventTriggerCondition::_internal_set_operator_(::v1::model::ConditionOperator value) {
  
  operator__ = value;
}
inline void BitsetEventTriggerCondition::set_operator_(::v1::model::ConditionOperator value) {
  _internal_set_operator_(value);
  // @@protoc_insertion_point(field_set:v1.model.BitsetEventTriggerCondition.operator)
}

// -------------------------------------------------------------------

// BitsetCondition

// string key = 1 [json_name = "key"];
inline void BitsetCondition::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& BitsetCondition::key() const {
  // @@protoc_insertion_point(field_get:v1.model.BitsetCondition.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BitsetCondition::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.BitsetCondition.key)
}
inline std::string* BitsetCondition::mutable_key() {
  // @@protoc_insertion_point(field_mutable:v1.model.BitsetCondition.key)
  return _internal_mutable_key();
}
inline const std::string& BitsetCondition::_internal_key() const {
  return key_.Get();
}
inline void BitsetCondition::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BitsetCondition::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BitsetCondition::release_key() {
  // @@protoc_insertion_point(field_release:v1.model.BitsetCondition.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BitsetCondition::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.BitsetCondition.key)
}

// bool true = 2 [json_name = "true"];
inline void BitsetCondition::clear_true_() {
  true__ = false;
}
inline bool BitsetCondition::_internal_true_() const {
  return true__;
}
inline bool BitsetCondition::true_() const {
  // @@protoc_insertion_point(field_get:v1.model.BitsetCondition.true)
  return _internal_true_();
}
inline void BitsetCondition::_internal_set_true_(bool value) {
  
  true__ = value;
}
inline void BitsetCondition::set_true_(bool value) {
  _internal_set_true_(value);
  // @@protoc_insertion_point(field_set:v1.model.BitsetCondition.true)
}

// bool false = 3 [json_name = "false"];
inline void BitsetCondition::clear_false_() {
  false__ = false;
}
inline bool BitsetCondition::_internal_false_() const {
  return false__;
}
inline bool BitsetCondition::false_() const {
  // @@protoc_insertion_point(field_get:v1.model.BitsetCondition.false)
  return _internal_false_();
}
inline void BitsetCondition::_internal_set_false_(bool value) {
  
  false__ = value;
}
inline void BitsetCondition::set_false_(bool value) {
  _internal_set_false_(value);
  // @@protoc_insertion_point(field_set:v1.model.BitsetCondition.false)
}

// -------------------------------------------------------------------

// JsonEventTriggerCondition

// string jqQuery = 1 [json_name = "jqQuery"];
inline void JsonEventTriggerCondition::clear_jqquery() {
  jqquery_.ClearToEmpty();
}
inline const std::string& JsonEventTriggerCondition::jqquery() const {
  // @@protoc_insertion_point(field_get:v1.model.JsonEventTriggerCondition.jqQuery)
  return _internal_jqquery();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void JsonEventTriggerCondition::set_jqquery(ArgT0&& arg0, ArgT... args) {
 
 jqquery_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.JsonEventTriggerCondition.jqQuery)
}
inline std::string* JsonEventTriggerCondition::mutable_jqquery() {
  // @@protoc_insertion_point(field_mutable:v1.model.JsonEventTriggerCondition.jqQuery)
  return _internal_mutable_jqquery();
}
inline const std::string& JsonEventTriggerCondition::_internal_jqquery() const {
  return jqquery_.Get();
}
inline void JsonEventTriggerCondition::_internal_set_jqquery(const std::string& value) {
  
  jqquery_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* JsonEventTriggerCondition::_internal_mutable_jqquery() {
  
  return jqquery_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* JsonEventTriggerCondition::release_jqquery() {
  // @@protoc_insertion_point(field_release:v1.model.JsonEventTriggerCondition.jqQuery)
  return jqquery_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void JsonEventTriggerCondition::set_allocated_jqquery(std::string* jqquery) {
  if (jqquery != nullptr) {
    
  } else {
    
  }
  jqquery_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), jqquery,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.JsonEventTriggerCondition.jqQuery)
}

// -------------------------------------------------------------------

// StatefulTriggerConfiguration

// bool emitOnEnteringState = 1 [json_name = "emitOnEnteringState"];
inline void StatefulTriggerConfiguration::clear_emitonenteringstate() {
  emitonenteringstate_ = false;
}
inline bool StatefulTriggerConfiguration::_internal_emitonenteringstate() const {
  return emitonenteringstate_;
}
inline bool StatefulTriggerConfiguration::emitonenteringstate() const {
  // @@protoc_insertion_point(field_get:v1.model.StatefulTriggerConfiguration.emitOnEnteringState)
  return _internal_emitonenteringstate();
}
inline void StatefulTriggerConfiguration::_internal_set_emitonenteringstate(bool value) {
  
  emitonenteringstate_ = value;
}
inline void StatefulTriggerConfiguration::set_emitonenteringstate(bool value) {
  _internal_set_emitonenteringstate(value);
  // @@protoc_insertion_point(field_set:v1.model.StatefulTriggerConfiguration.emitOnEnteringState)
}

// bool emitOnLeavingState = 2 [json_name = "emitOnLeavingState"];
inline void StatefulTriggerConfiguration::clear_emitonleavingstate() {
  emitonleavingstate_ = false;
}
inline bool StatefulTriggerConfiguration::_internal_emitonleavingstate() const {
  return emitonleavingstate_;
}
inline bool StatefulTriggerConfiguration::emitonleavingstate() const {
  // @@protoc_insertion_point(field_get:v1.model.StatefulTriggerConfiguration.emitOnLeavingState)
  return _internal_emitonleavingstate();
}
inline void StatefulTriggerConfiguration::_internal_set_emitonleavingstate(bool value) {
  
  emitonleavingstate_ = value;
}
inline void StatefulTriggerConfiguration::set_emitonleavingstate(bool value) {
  _internal_set_emitonleavingstate(value);
  // @@protoc_insertion_point(field_set:v1.model.StatefulTriggerConfiguration.emitOnLeavingState)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace v1

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::v1::model::Severity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::Severity>() {
  return ::v1::model::Severity_descriptor();
}
template <> struct is_proto_enum< ::v1::model::BatteryField> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::BatteryField>() {
  return ::v1::model::BatteryField_descriptor();
}
template <> struct is_proto_enum< ::v1::model::ThresholdOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::ThresholdOperator>() {
  return ::v1::model::ThresholdOperator_descriptor();
}
template <> struct is_proto_enum< ::v1::model::ConditionOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::v1::model::ConditionOperator>() {
  return ::v1::model::ConditionOperator_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fevent_2eproto
