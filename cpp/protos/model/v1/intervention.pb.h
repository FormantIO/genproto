// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/model/v1/intervention.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fintervention_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fintervention_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/model/v1/media.pb.h"
#include "protos/model/v1/event.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmodel_2fv1_2fintervention_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmodel_2fv1_2fintervention_2eproto;
namespace v1 {
namespace model {
class InterventionRequest;
struct InterventionRequestDefaultTypeInternal;
extern InterventionRequestDefaultTypeInternal _InterventionRequest_default_instance_;
class InterventionRequest_TagsEntry_DoNotUse;
struct InterventionRequest_TagsEntry_DoNotUseDefaultTypeInternal;
extern InterventionRequest_TagsEntry_DoNotUseDefaultTypeInternal _InterventionRequest_TagsEntry_DoNotUse_default_instance_;
class InterventionResponse;
struct InterventionResponseDefaultTypeInternal;
extern InterventionResponseDefaultTypeInternal _InterventionResponse_default_instance_;
class Label;
struct LabelDefaultTypeInternal;
extern LabelDefaultTypeInternal _Label_default_instance_;
class LabeledPolygon;
struct LabeledPolygonDefaultTypeInternal;
extern LabeledPolygonDefaultTypeInternal _LabeledPolygon_default_instance_;
class LabelingRequest;
struct LabelingRequestDefaultTypeInternal;
extern LabelingRequestDefaultTypeInternal _LabelingRequest_default_instance_;
class LabelingResponse;
struct LabelingResponseDefaultTypeInternal;
extern LabelingResponseDefaultTypeInternal _LabelingResponse_default_instance_;
class SelectionRequest;
struct SelectionRequestDefaultTypeInternal;
extern SelectionRequestDefaultTypeInternal _SelectionRequest_default_instance_;
class SelectionResponse;
struct SelectionResponseDefaultTypeInternal;
extern SelectionResponseDefaultTypeInternal _SelectionResponse_default_instance_;
class TeleopRequest;
struct TeleopRequestDefaultTypeInternal;
extern TeleopRequestDefaultTypeInternal _TeleopRequest_default_instance_;
class TeleopResponse;
struct TeleopResponseDefaultTypeInternal;
extern TeleopResponseDefaultTypeInternal _TeleopResponse_default_instance_;
class Vertex;
struct VertexDefaultTypeInternal;
extern VertexDefaultTypeInternal _Vertex_default_instance_;
}  // namespace model
}  // namespace v1
PROTOBUF_NAMESPACE_OPEN
template<> ::v1::model::InterventionRequest* Arena::CreateMaybeMessage<::v1::model::InterventionRequest>(Arena*);
template<> ::v1::model::InterventionRequest_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::InterventionRequest_TagsEntry_DoNotUse>(Arena*);
template<> ::v1::model::InterventionResponse* Arena::CreateMaybeMessage<::v1::model::InterventionResponse>(Arena*);
template<> ::v1::model::Label* Arena::CreateMaybeMessage<::v1::model::Label>(Arena*);
template<> ::v1::model::LabeledPolygon* Arena::CreateMaybeMessage<::v1::model::LabeledPolygon>(Arena*);
template<> ::v1::model::LabelingRequest* Arena::CreateMaybeMessage<::v1::model::LabelingRequest>(Arena*);
template<> ::v1::model::LabelingResponse* Arena::CreateMaybeMessage<::v1::model::LabelingResponse>(Arena*);
template<> ::v1::model::SelectionRequest* Arena::CreateMaybeMessage<::v1::model::SelectionRequest>(Arena*);
template<> ::v1::model::SelectionResponse* Arena::CreateMaybeMessage<::v1::model::SelectionResponse>(Arena*);
template<> ::v1::model::TeleopRequest* Arena::CreateMaybeMessage<::v1::model::TeleopRequest>(Arena*);
template<> ::v1::model::TeleopResponse* Arena::CreateMaybeMessage<::v1::model::TeleopResponse>(Arena*);
template<> ::v1::model::Vertex* Arena::CreateMaybeMessage<::v1::model::Vertex>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v1 {
namespace model {

// ===================================================================

class InterventionRequest_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InterventionRequest_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<InterventionRequest_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  InterventionRequest_TagsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR InterventionRequest_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit InterventionRequest_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const InterventionRequest_TagsEntry_DoNotUse& other);
  static const InterventionRequest_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const InterventionRequest_TagsEntry_DoNotUse*>(&_InterventionRequest_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.InterventionRequest.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.InterventionRequest.TagsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};

// -------------------------------------------------------------------

class InterventionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.InterventionRequest) */ {
 public:
  inline InterventionRequest() : InterventionRequest(nullptr) {}
  ~InterventionRequest() override;
  explicit PROTOBUF_CONSTEXPR InterventionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterventionRequest(const InterventionRequest& from);
  InterventionRequest(InterventionRequest&& from) noexcept
    : InterventionRequest() {
    *this = ::std::move(from);
  }

  inline InterventionRequest& operator=(const InterventionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterventionRequest& operator=(InterventionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterventionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kSelectionRequest = 4,
    kLabelingRequest = 5,
    kTeleopRequest = 8,
    DATA_NOT_SET = 0,
  };

  static inline const InterventionRequest* internal_default_instance() {
    return reinterpret_cast<const InterventionRequest*>(
               &_InterventionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(InterventionRequest& a, InterventionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InterventionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterventionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterventionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterventionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterventionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InterventionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterventionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.InterventionRequest";
  }
  protected:
  explicit InterventionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 6,
    kResponsesFieldNumber = 7,
    kIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kSeverityFieldNumber = 3,
    kSelectionRequestFieldNumber = 4,
    kLabelingRequestFieldNumber = 5,
    kTeleopRequestFieldNumber = 8,
  };
  // map<string, string> tags = 6 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // repeated .v1.model.InterventionResponse responses = 7 [json_name = "responses"];
  int responses_size() const;
  private:
  int _internal_responses_size() const;
  public:
  void clear_responses();
  ::v1::model::InterventionResponse* mutable_responses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::InterventionResponse >*
      mutable_responses();
  private:
  const ::v1::model::InterventionResponse& _internal_responses(int index) const;
  ::v1::model::InterventionResponse* _internal_add_responses();
  public:
  const ::v1::model::InterventionResponse& responses(int index) const;
  ::v1::model::InterventionResponse* add_responses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::InterventionResponse >&
      responses() const;

  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .v1.model.Severity severity = 3 [json_name = "severity"];
  void clear_severity();
  ::v1::model::Severity severity() const;
  void set_severity(::v1::model::Severity value);
  private:
  ::v1::model::Severity _internal_severity() const;
  void _internal_set_severity(::v1::model::Severity value);
  public:

  // .v1.model.SelectionRequest selection_request = 4 [json_name = "selectionRequest"];
  bool has_selection_request() const;
  private:
  bool _internal_has_selection_request() const;
  public:
  void clear_selection_request();
  const ::v1::model::SelectionRequest& selection_request() const;
  PROTOBUF_NODISCARD ::v1::model::SelectionRequest* release_selection_request();
  ::v1::model::SelectionRequest* mutable_selection_request();
  void set_allocated_selection_request(::v1::model::SelectionRequest* selection_request);
  private:
  const ::v1::model::SelectionRequest& _internal_selection_request() const;
  ::v1::model::SelectionRequest* _internal_mutable_selection_request();
  public:
  void unsafe_arena_set_allocated_selection_request(
      ::v1::model::SelectionRequest* selection_request);
  ::v1::model::SelectionRequest* unsafe_arena_release_selection_request();

  // .v1.model.LabelingRequest labeling_request = 5 [json_name = "labelingRequest"];
  bool has_labeling_request() const;
  private:
  bool _internal_has_labeling_request() const;
  public:
  void clear_labeling_request();
  const ::v1::model::LabelingRequest& labeling_request() const;
  PROTOBUF_NODISCARD ::v1::model::LabelingRequest* release_labeling_request();
  ::v1::model::LabelingRequest* mutable_labeling_request();
  void set_allocated_labeling_request(::v1::model::LabelingRequest* labeling_request);
  private:
  const ::v1::model::LabelingRequest& _internal_labeling_request() const;
  ::v1::model::LabelingRequest* _internal_mutable_labeling_request();
  public:
  void unsafe_arena_set_allocated_labeling_request(
      ::v1::model::LabelingRequest* labeling_request);
  ::v1::model::LabelingRequest* unsafe_arena_release_labeling_request();

  // .v1.model.TeleopRequest teleop_request = 8 [json_name = "teleopRequest"];
  bool has_teleop_request() const;
  private:
  bool _internal_has_teleop_request() const;
  public:
  void clear_teleop_request();
  const ::v1::model::TeleopRequest& teleop_request() const;
  PROTOBUF_NODISCARD ::v1::model::TeleopRequest* release_teleop_request();
  ::v1::model::TeleopRequest* mutable_teleop_request();
  void set_allocated_teleop_request(::v1::model::TeleopRequest* teleop_request);
  private:
  const ::v1::model::TeleopRequest& _internal_teleop_request() const;
  ::v1::model::TeleopRequest* _internal_mutable_teleop_request();
  public:
  void unsafe_arena_set_allocated_teleop_request(
      ::v1::model::TeleopRequest* teleop_request);
  ::v1::model::TeleopRequest* unsafe_arena_release_teleop_request();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.InterventionRequest)
 private:
  class _Internal;
  void set_has_selection_request();
  void set_has_labeling_request();
  void set_has_teleop_request();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      InterventionRequest_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::InterventionResponse > responses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  int64_t timestamp_;
  int severity_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::SelectionRequest* selection_request_;
    ::v1::model::LabelingRequest* labeling_request_;
    ::v1::model::TeleopRequest* teleop_request_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class InterventionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.InterventionResponse) */ {
 public:
  inline InterventionResponse() : InterventionResponse(nullptr) {}
  ~InterventionResponse() override;
  explicit PROTOBUF_CONSTEXPR InterventionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InterventionResponse(const InterventionResponse& from);
  InterventionResponse(InterventionResponse&& from) noexcept
    : InterventionResponse() {
    *this = ::std::move(from);
  }

  inline InterventionResponse& operator=(const InterventionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InterventionResponse& operator=(InterventionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InterventionResponse& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kSelectionResponse = 4,
    kLabelingResponse = 5,
    kTeleopResponse = 6,
    DATA_NOT_SET = 0,
  };

  static inline const InterventionResponse* internal_default_instance() {
    return reinterpret_cast<const InterventionResponse*>(
               &_InterventionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InterventionResponse& a, InterventionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InterventionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InterventionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InterventionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InterventionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InterventionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InterventionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InterventionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.InterventionResponse";
  }
  protected:
  explicit InterventionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kTimestampFieldNumber = 3,
    kSelectionResponseFieldNumber = 4,
    kLabelingResponseFieldNumber = 5,
    kTeleopResponseFieldNumber = 6,
  };
  // string id = 1 [json_name = "id"];
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string request_id = 2 [json_name = "requestId"];
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // int64 timestamp = 3 [json_name = "timestamp"];
  void clear_timestamp();
  int64_t timestamp() const;
  void set_timestamp(int64_t value);
  private:
  int64_t _internal_timestamp() const;
  void _internal_set_timestamp(int64_t value);
  public:

  // .v1.model.SelectionResponse selection_response = 4 [json_name = "selectionResponse"];
  bool has_selection_response() const;
  private:
  bool _internal_has_selection_response() const;
  public:
  void clear_selection_response();
  const ::v1::model::SelectionResponse& selection_response() const;
  PROTOBUF_NODISCARD ::v1::model::SelectionResponse* release_selection_response();
  ::v1::model::SelectionResponse* mutable_selection_response();
  void set_allocated_selection_response(::v1::model::SelectionResponse* selection_response);
  private:
  const ::v1::model::SelectionResponse& _internal_selection_response() const;
  ::v1::model::SelectionResponse* _internal_mutable_selection_response();
  public:
  void unsafe_arena_set_allocated_selection_response(
      ::v1::model::SelectionResponse* selection_response);
  ::v1::model::SelectionResponse* unsafe_arena_release_selection_response();

  // .v1.model.LabelingResponse labeling_response = 5 [json_name = "labelingResponse"];
  bool has_labeling_response() const;
  private:
  bool _internal_has_labeling_response() const;
  public:
  void clear_labeling_response();
  const ::v1::model::LabelingResponse& labeling_response() const;
  PROTOBUF_NODISCARD ::v1::model::LabelingResponse* release_labeling_response();
  ::v1::model::LabelingResponse* mutable_labeling_response();
  void set_allocated_labeling_response(::v1::model::LabelingResponse* labeling_response);
  private:
  const ::v1::model::LabelingResponse& _internal_labeling_response() const;
  ::v1::model::LabelingResponse* _internal_mutable_labeling_response();
  public:
  void unsafe_arena_set_allocated_labeling_response(
      ::v1::model::LabelingResponse* labeling_response);
  ::v1::model::LabelingResponse* unsafe_arena_release_labeling_response();

  // .v1.model.TeleopResponse teleop_response = 6 [json_name = "teleopResponse"];
  bool has_teleop_response() const;
  private:
  bool _internal_has_teleop_response() const;
  public:
  void clear_teleop_response();
  const ::v1::model::TeleopResponse& teleop_response() const;
  PROTOBUF_NODISCARD ::v1::model::TeleopResponse* release_teleop_response();
  ::v1::model::TeleopResponse* mutable_teleop_response();
  void set_allocated_teleop_response(::v1::model::TeleopResponse* teleop_response);
  private:
  const ::v1::model::TeleopResponse& _internal_teleop_response() const;
  ::v1::model::TeleopResponse* _internal_mutable_teleop_response();
  public:
  void unsafe_arena_set_allocated_teleop_response(
      ::v1::model::TeleopResponse* teleop_response);
  ::v1::model::TeleopResponse* unsafe_arena_release_teleop_response();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.InterventionResponse)
 private:
  class _Internal;
  void set_has_selection_response();
  void set_has_labeling_response();
  void set_has_teleop_response();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  int64_t timestamp_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::SelectionResponse* selection_response_;
    ::v1::model::LabelingResponse* labeling_response_;
    ::v1::model::TeleopResponse* teleop_response_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class Label final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Label) */ {
 public:
  inline Label() : Label(nullptr) {}
  ~Label() override;
  explicit PROTOBUF_CONSTEXPR Label(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Label(const Label& from);
  Label(Label&& from) noexcept
    : Label() {
    *this = ::std::move(from);
  }

  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }
  inline Label& operator=(Label&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Label& default_instance() {
    return *internal_default_instance();
  }
  static inline const Label* internal_default_instance() {
    return reinterpret_cast<const Label*>(
               &_Label_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Label& a, Label& b) {
    a.Swap(&b);
  }
  inline void Swap(Label* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Label* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Label* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Label>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Label& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Label& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Label* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Label";
  }
  protected:
  explicit Label(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
  };
  // string value = 1 [json_name = "value"];
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // string display_name = 2 [json_name = "displayName"];
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.Label)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class LabeledPolygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.LabeledPolygon) */ {
 public:
  inline LabeledPolygon() : LabeledPolygon(nullptr) {}
  ~LabeledPolygon() override;
  explicit PROTOBUF_CONSTEXPR LabeledPolygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabeledPolygon(const LabeledPolygon& from);
  LabeledPolygon(LabeledPolygon&& from) noexcept
    : LabeledPolygon() {
    *this = ::std::move(from);
  }

  inline LabeledPolygon& operator=(const LabeledPolygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabeledPolygon& operator=(LabeledPolygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabeledPolygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabeledPolygon* internal_default_instance() {
    return reinterpret_cast<const LabeledPolygon*>(
               &_LabeledPolygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LabeledPolygon& a, LabeledPolygon& b) {
    a.Swap(&b);
  }
  inline void Swap(LabeledPolygon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabeledPolygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabeledPolygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabeledPolygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabeledPolygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LabeledPolygon& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabeledPolygon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.LabeledPolygon";
  }
  protected:
  explicit LabeledPolygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kLabelsFieldNumber = 2,
  };
  // repeated .v1.model.Vertex vertices = 1 [json_name = "vertices"];
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::v1::model::Vertex* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Vertex >*
      mutable_vertices();
  private:
  const ::v1::model::Vertex& _internal_vertices(int index) const;
  ::v1::model::Vertex* _internal_add_vertices();
  public:
  const ::v1::model::Vertex& vertices(int index) const;
  ::v1::model::Vertex* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Vertex >&
      vertices() const;

  // repeated string labels = 2 [json_name = "labels"];
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  const std::string& labels(int index) const;
  std::string* mutable_labels(int index);
  void set_labels(int index, const std::string& value);
  void set_labels(int index, std::string&& value);
  void set_labels(int index, const char* value);
  void set_labels(int index, const char* value, size_t size);
  std::string* add_labels();
  void add_labels(const std::string& value);
  void add_labels(std::string&& value);
  void add_labels(const char* value);
  void add_labels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& labels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_labels();
  private:
  const std::string& _internal_labels(int index) const;
  std::string* _internal_add_labels();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.LabeledPolygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Vertex > vertices_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> labels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class Vertex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Vertex) */ {
 public:
  inline Vertex() : Vertex(nullptr) {}
  ~Vertex() override;
  explicit PROTOBUF_CONSTEXPR Vertex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vertex(const Vertex& from);
  Vertex(Vertex&& from) noexcept
    : Vertex() {
    *this = ::std::move(from);
  }

  inline Vertex& operator=(const Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vertex& operator=(Vertex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vertex& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vertex* internal_default_instance() {
    return reinterpret_cast<const Vertex*>(
               &_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Vertex& a, Vertex& b) {
    a.Swap(&b);
  }
  inline void Swap(Vertex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vertex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vertex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vertex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vertex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Vertex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vertex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Vertex";
  }
  protected:
  explicit Vertex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1 [json_name = "x"];
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2 [json_name = "y"];
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.Vertex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class LabelingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.LabelingRequest) */ {
 public:
  inline LabelingRequest() : LabelingRequest(nullptr) {}
  ~LabelingRequest() override;
  explicit PROTOBUF_CONSTEXPR LabelingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelingRequest(const LabelingRequest& from);
  LabelingRequest(LabelingRequest&& from) noexcept
    : LabelingRequest() {
    *this = ::std::move(from);
  }

  inline LabelingRequest& operator=(const LabelingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelingRequest& operator=(LabelingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelingRequest* internal_default_instance() {
    return reinterpret_cast<const LabelingRequest*>(
               &_LabelingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LabelingRequest& a, LabelingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LabelingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.LabelingRequest";
  }
  protected:
  explicit LabelingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 4,
    kHintFieldNumber = 5,
    kTitleFieldNumber = 1,
    kInstructionFieldNumber = 2,
    kImageFieldNumber = 3,
  };
  // repeated .v1.model.Label labels = 4 [json_name = "labels"];
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  ::v1::model::Label* mutable_labels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Label >*
      mutable_labels();
  private:
  const ::v1::model::Label& _internal_labels(int index) const;
  ::v1::model::Label* _internal_add_labels();
  public:
  const ::v1::model::Label& labels(int index) const;
  ::v1::model::Label* add_labels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Label >&
      labels() const;

  // repeated .v1.model.LabeledPolygon hint = 5 [json_name = "hint"];
  int hint_size() const;
  private:
  int _internal_hint_size() const;
  public:
  void clear_hint();
  ::v1::model::LabeledPolygon* mutable_hint(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >*
      mutable_hint();
  private:
  const ::v1::model::LabeledPolygon& _internal_hint(int index) const;
  ::v1::model::LabeledPolygon* _internal_add_hint();
  public:
  const ::v1::model::LabeledPolygon& hint(int index) const;
  ::v1::model::LabeledPolygon* add_hint();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >&
      hint() const;

  // string title = 1 [json_name = "title"];
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string instruction = 2 [json_name = "instruction"];
  void clear_instruction();
  const std::string& instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instruction();
  PROTOBUF_NODISCARD std::string* release_instruction();
  void set_allocated_instruction(std::string* instruction);
  private:
  const std::string& _internal_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction(const std::string& value);
  std::string* _internal_mutable_instruction();
  public:

  // .v1.model.Image image = 3 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::v1::model::Image& image() const;
  PROTOBUF_NODISCARD ::v1::model::Image* release_image();
  ::v1::model::Image* mutable_image();
  void set_allocated_image(::v1::model::Image* image);
  private:
  const ::v1::model::Image& _internal_image() const;
  ::v1::model::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::v1::model::Image* image);
  ::v1::model::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:v1.model.LabelingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Label > labels_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon > hint_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instruction_;
  ::v1::model::Image* image_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class LabelingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.LabelingResponse) */ {
 public:
  inline LabelingResponse() : LabelingResponse(nullptr) {}
  ~LabelingResponse() override;
  explicit PROTOBUF_CONSTEXPR LabelingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LabelingResponse(const LabelingResponse& from);
  LabelingResponse(LabelingResponse&& from) noexcept
    : LabelingResponse() {
    *this = ::std::move(from);
  }

  inline LabelingResponse& operator=(const LabelingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LabelingResponse& operator=(LabelingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LabelingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LabelingResponse* internal_default_instance() {
    return reinterpret_cast<const LabelingResponse*>(
               &_LabelingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LabelingResponse& a, LabelingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LabelingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LabelingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LabelingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LabelingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LabelingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LabelingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.LabelingResponse";
  }
  protected:
  explicit LabelingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .v1.model.LabeledPolygon value = 1 [json_name = "value"];
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::v1::model::LabeledPolygon* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >*
      mutable_value();
  private:
  const ::v1::model::LabeledPolygon& _internal_value(int index) const;
  ::v1::model::LabeledPolygon* _internal_add_value();
  public:
  const ::v1::model::LabeledPolygon& value(int index) const;
  ::v1::model::LabeledPolygon* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >&
      value() const;

  // @@protoc_insertion_point(class_scope:v1.model.LabelingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class SelectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.SelectionRequest) */ {
 public:
  inline SelectionRequest() : SelectionRequest(nullptr) {}
  ~SelectionRequest() override;
  explicit PROTOBUF_CONSTEXPR SelectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionRequest(const SelectionRequest& from);
  SelectionRequest(SelectionRequest&& from) noexcept
    : SelectionRequest() {
    *this = ::std::move(from);
  }

  inline SelectionRequest& operator=(const SelectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionRequest& operator=(SelectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kImage = 2,
    DATA_NOT_SET = 0,
  };

  static inline const SelectionRequest* internal_default_instance() {
    return reinterpret_cast<const SelectionRequest*>(
               &_SelectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SelectionRequest& a, SelectionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.SelectionRequest";
  }
  protected:
  explicit SelectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 4,
    kTitleFieldNumber = 1,
    kInstructionFieldNumber = 3,
    kHintFieldNumber = 5,
    kImageFieldNumber = 2,
  };
  // repeated string options = 4 [json_name = "options"];
  int options_size() const;
  private:
  int _internal_options_size() const;
  public:
  void clear_options();
  const std::string& options(int index) const;
  std::string* mutable_options(int index);
  void set_options(int index, const std::string& value);
  void set_options(int index, std::string&& value);
  void set_options(int index, const char* value);
  void set_options(int index, const char* value, size_t size);
  std::string* add_options();
  void add_options(const std::string& value);
  void add_options(std::string&& value);
  void add_options(const char* value);
  void add_options(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& options() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_options();
  private:
  const std::string& _internal_options(int index) const;
  std::string* _internal_add_options();
  public:

  // string title = 1 [json_name = "title"];
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string instruction = 3 [json_name = "instruction"];
  void clear_instruction();
  const std::string& instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instruction();
  PROTOBUF_NODISCARD std::string* release_instruction();
  void set_allocated_instruction(std::string* instruction);
  private:
  const std::string& _internal_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction(const std::string& value);
  std::string* _internal_mutable_instruction();
  public:

  // uint32 hint = 5 [json_name = "hint"];
  void clear_hint();
  uint32_t hint() const;
  void set_hint(uint32_t value);
  private:
  uint32_t _internal_hint() const;
  void _internal_set_hint(uint32_t value);
  public:

  // .v1.model.Image image = 2 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::v1::model::Image& image() const;
  PROTOBUF_NODISCARD ::v1::model::Image* release_image();
  ::v1::model::Image* mutable_image();
  void set_allocated_image(::v1::model::Image* image);
  private:
  const ::v1::model::Image& _internal_image() const;
  ::v1::model::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::v1::model::Image* image);
  ::v1::model::Image* unsafe_arena_release_image();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.SelectionRequest)
 private:
  class _Internal;
  void set_has_image();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> options_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instruction_;
  uint32_t hint_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::Image* image_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class SelectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.SelectionResponse) */ {
 public:
  inline SelectionResponse() : SelectionResponse(nullptr) {}
  ~SelectionResponse() override;
  explicit PROTOBUF_CONSTEXPR SelectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectionResponse(const SelectionResponse& from);
  SelectionResponse(SelectionResponse&& from) noexcept
    : SelectionResponse() {
    *this = ::std::move(from);
  }

  inline SelectionResponse& operator=(const SelectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectionResponse& operator=(SelectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectionResponse* internal_default_instance() {
    return reinterpret_cast<const SelectionResponse*>(
               &_SelectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SelectionResponse& a, SelectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.SelectionResponse";
  }
  protected:
  explicit SelectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 value = 1 [json_name = "value"];
  void clear_value();
  uint32_t value() const;
  void set_value(uint32_t value);
  private:
  uint32_t _internal_value() const;
  void _internal_set_value(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:v1.model.SelectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class TeleopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TeleopRequest) */ {
 public:
  inline TeleopRequest() : TeleopRequest(nullptr) {}
  ~TeleopRequest() override;
  explicit PROTOBUF_CONSTEXPR TeleopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeleopRequest(const TeleopRequest& from);
  TeleopRequest(TeleopRequest&& from) noexcept
    : TeleopRequest() {
    *this = ::std::move(from);
  }

  inline TeleopRequest& operator=(const TeleopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeleopRequest& operator=(TeleopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeleopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeleopRequest* internal_default_instance() {
    return reinterpret_cast<const TeleopRequest*>(
               &_TeleopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TeleopRequest& a, TeleopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TeleopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeleopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeleopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeleopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeleopRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TeleopRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeleopRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TeleopRequest";
  }
  protected:
  explicit TeleopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstructionFieldNumber = 1,
  };
  // string instruction = 1 [json_name = "instruction"];
  void clear_instruction();
  const std::string& instruction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_instruction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_instruction();
  PROTOBUF_NODISCARD std::string* release_instruction();
  void set_allocated_instruction(std::string* instruction);
  private:
  const std::string& _internal_instruction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_instruction(const std::string& value);
  std::string* _internal_mutable_instruction();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.TeleopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instruction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// -------------------------------------------------------------------

class TeleopResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.TeleopResponse) */ {
 public:
  inline TeleopResponse() : TeleopResponse(nullptr) {}
  ~TeleopResponse() override;
  explicit PROTOBUF_CONSTEXPR TeleopResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TeleopResponse(const TeleopResponse& from);
  TeleopResponse(TeleopResponse&& from) noexcept
    : TeleopResponse() {
    *this = ::std::move(from);
  }

  inline TeleopResponse& operator=(const TeleopResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TeleopResponse& operator=(TeleopResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TeleopResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TeleopResponse* internal_default_instance() {
    return reinterpret_cast<const TeleopResponse*>(
               &_TeleopResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TeleopResponse& a, TeleopResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TeleopResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TeleopResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TeleopResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TeleopResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TeleopResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TeleopResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TeleopResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.TeleopResponse";
  }
  protected:
  explicit TeleopResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
    kNotesFieldNumber = 2,
  };
  // string state = 1 [json_name = "state"];
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string notes = 2 [json_name = "notes"];
  void clear_notes();
  const std::string& notes() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notes(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notes();
  PROTOBUF_NODISCARD std::string* release_notes();
  void set_allocated_notes(std::string* notes);
  private:
  const std::string& _internal_notes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notes(const std::string& value);
  std::string* _internal_mutable_notes();
  public:

  // @@protoc_insertion_point(class_scope:v1.model.TeleopResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_protos_2fmodel_2fv1_2fintervention_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// InterventionRequest

// string id = 1 [json_name = "id"];
inline void InterventionRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& InterventionRequest::id() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InterventionRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.InterventionRequest.id)
}
inline std::string* InterventionRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionRequest.id)
  return _s;
}
inline const std::string& InterventionRequest::_internal_id() const {
  return id_.Get();
}
inline void InterventionRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* InterventionRequest::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* InterventionRequest::release_id() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionRequest.id)
  return id_.Release();
}
inline void InterventionRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.InterventionRequest.id)
}

// int64 timestamp = 2 [json_name = "timestamp"];
inline void InterventionRequest::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t InterventionRequest::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t InterventionRequest::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.timestamp)
  return _internal_timestamp();
}
inline void InterventionRequest::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void InterventionRequest::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.InterventionRequest.timestamp)
}

// .v1.model.Severity severity = 3 [json_name = "severity"];
inline void InterventionRequest::clear_severity() {
  severity_ = 0;
}
inline ::v1::model::Severity InterventionRequest::_internal_severity() const {
  return static_cast< ::v1::model::Severity >(severity_);
}
inline ::v1::model::Severity InterventionRequest::severity() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.severity)
  return _internal_severity();
}
inline void InterventionRequest::_internal_set_severity(::v1::model::Severity value) {
  
  severity_ = value;
}
inline void InterventionRequest::set_severity(::v1::model::Severity value) {
  _internal_set_severity(value);
  // @@protoc_insertion_point(field_set:v1.model.InterventionRequest.severity)
}

// .v1.model.SelectionRequest selection_request = 4 [json_name = "selectionRequest"];
inline bool InterventionRequest::_internal_has_selection_request() const {
  return data_case() == kSelectionRequest;
}
inline bool InterventionRequest::has_selection_request() const {
  return _internal_has_selection_request();
}
inline void InterventionRequest::set_has_selection_request() {
  _oneof_case_[0] = kSelectionRequest;
}
inline void InterventionRequest::clear_selection_request() {
  if (_internal_has_selection_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.selection_request_;
    }
    clear_has_data();
  }
}
inline ::v1::model::SelectionRequest* InterventionRequest::release_selection_request() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionRequest.selection_request)
  if (_internal_has_selection_request()) {
    clear_has_data();
    ::v1::model::SelectionRequest* temp = data_.selection_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.selection_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::SelectionRequest& InterventionRequest::_internal_selection_request() const {
  return _internal_has_selection_request()
      ? *data_.selection_request_
      : reinterpret_cast< ::v1::model::SelectionRequest&>(::v1::model::_SelectionRequest_default_instance_);
}
inline const ::v1::model::SelectionRequest& InterventionRequest::selection_request() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.selection_request)
  return _internal_selection_request();
}
inline ::v1::model::SelectionRequest* InterventionRequest::unsafe_arena_release_selection_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.InterventionRequest.selection_request)
  if (_internal_has_selection_request()) {
    clear_has_data();
    ::v1::model::SelectionRequest* temp = data_.selection_request_;
    data_.selection_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterventionRequest::unsafe_arena_set_allocated_selection_request(::v1::model::SelectionRequest* selection_request) {
  clear_data();
  if (selection_request) {
    set_has_selection_request();
    data_.selection_request_ = selection_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.InterventionRequest.selection_request)
}
inline ::v1::model::SelectionRequest* InterventionRequest::_internal_mutable_selection_request() {
  if (!_internal_has_selection_request()) {
    clear_data();
    set_has_selection_request();
    data_.selection_request_ = CreateMaybeMessage< ::v1::model::SelectionRequest >(GetArenaForAllocation());
  }
  return data_.selection_request_;
}
inline ::v1::model::SelectionRequest* InterventionRequest::mutable_selection_request() {
  ::v1::model::SelectionRequest* _msg = _internal_mutable_selection_request();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionRequest.selection_request)
  return _msg;
}

// .v1.model.LabelingRequest labeling_request = 5 [json_name = "labelingRequest"];
inline bool InterventionRequest::_internal_has_labeling_request() const {
  return data_case() == kLabelingRequest;
}
inline bool InterventionRequest::has_labeling_request() const {
  return _internal_has_labeling_request();
}
inline void InterventionRequest::set_has_labeling_request() {
  _oneof_case_[0] = kLabelingRequest;
}
inline void InterventionRequest::clear_labeling_request() {
  if (_internal_has_labeling_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.labeling_request_;
    }
    clear_has_data();
  }
}
inline ::v1::model::LabelingRequest* InterventionRequest::release_labeling_request() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionRequest.labeling_request)
  if (_internal_has_labeling_request()) {
    clear_has_data();
    ::v1::model::LabelingRequest* temp = data_.labeling_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.labeling_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::LabelingRequest& InterventionRequest::_internal_labeling_request() const {
  return _internal_has_labeling_request()
      ? *data_.labeling_request_
      : reinterpret_cast< ::v1::model::LabelingRequest&>(::v1::model::_LabelingRequest_default_instance_);
}
inline const ::v1::model::LabelingRequest& InterventionRequest::labeling_request() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.labeling_request)
  return _internal_labeling_request();
}
inline ::v1::model::LabelingRequest* InterventionRequest::unsafe_arena_release_labeling_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.InterventionRequest.labeling_request)
  if (_internal_has_labeling_request()) {
    clear_has_data();
    ::v1::model::LabelingRequest* temp = data_.labeling_request_;
    data_.labeling_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterventionRequest::unsafe_arena_set_allocated_labeling_request(::v1::model::LabelingRequest* labeling_request) {
  clear_data();
  if (labeling_request) {
    set_has_labeling_request();
    data_.labeling_request_ = labeling_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.InterventionRequest.labeling_request)
}
inline ::v1::model::LabelingRequest* InterventionRequest::_internal_mutable_labeling_request() {
  if (!_internal_has_labeling_request()) {
    clear_data();
    set_has_labeling_request();
    data_.labeling_request_ = CreateMaybeMessage< ::v1::model::LabelingRequest >(GetArenaForAllocation());
  }
  return data_.labeling_request_;
}
inline ::v1::model::LabelingRequest* InterventionRequest::mutable_labeling_request() {
  ::v1::model::LabelingRequest* _msg = _internal_mutable_labeling_request();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionRequest.labeling_request)
  return _msg;
}

// .v1.model.TeleopRequest teleop_request = 8 [json_name = "teleopRequest"];
inline bool InterventionRequest::_internal_has_teleop_request() const {
  return data_case() == kTeleopRequest;
}
inline bool InterventionRequest::has_teleop_request() const {
  return _internal_has_teleop_request();
}
inline void InterventionRequest::set_has_teleop_request() {
  _oneof_case_[0] = kTeleopRequest;
}
inline void InterventionRequest::clear_teleop_request() {
  if (_internal_has_teleop_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.teleop_request_;
    }
    clear_has_data();
  }
}
inline ::v1::model::TeleopRequest* InterventionRequest::release_teleop_request() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionRequest.teleop_request)
  if (_internal_has_teleop_request()) {
    clear_has_data();
    ::v1::model::TeleopRequest* temp = data_.teleop_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.teleop_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::TeleopRequest& InterventionRequest::_internal_teleop_request() const {
  return _internal_has_teleop_request()
      ? *data_.teleop_request_
      : reinterpret_cast< ::v1::model::TeleopRequest&>(::v1::model::_TeleopRequest_default_instance_);
}
inline const ::v1::model::TeleopRequest& InterventionRequest::teleop_request() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.teleop_request)
  return _internal_teleop_request();
}
inline ::v1::model::TeleopRequest* InterventionRequest::unsafe_arena_release_teleop_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.InterventionRequest.teleop_request)
  if (_internal_has_teleop_request()) {
    clear_has_data();
    ::v1::model::TeleopRequest* temp = data_.teleop_request_;
    data_.teleop_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterventionRequest::unsafe_arena_set_allocated_teleop_request(::v1::model::TeleopRequest* teleop_request) {
  clear_data();
  if (teleop_request) {
    set_has_teleop_request();
    data_.teleop_request_ = teleop_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.InterventionRequest.teleop_request)
}
inline ::v1::model::TeleopRequest* InterventionRequest::_internal_mutable_teleop_request() {
  if (!_internal_has_teleop_request()) {
    clear_data();
    set_has_teleop_request();
    data_.teleop_request_ = CreateMaybeMessage< ::v1::model::TeleopRequest >(GetArenaForAllocation());
  }
  return data_.teleop_request_;
}
inline ::v1::model::TeleopRequest* InterventionRequest::mutable_teleop_request() {
  ::v1::model::TeleopRequest* _msg = _internal_mutable_teleop_request();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionRequest.teleop_request)
  return _msg;
}

// map<string, string> tags = 6 [json_name = "tags"];
inline int InterventionRequest::_internal_tags_size() const {
  return tags_.size();
}
inline int InterventionRequest::tags_size() const {
  return _internal_tags_size();
}
inline void InterventionRequest::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InterventionRequest::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
InterventionRequest::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.InterventionRequest.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InterventionRequest::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
InterventionRequest::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.InterventionRequest.tags)
  return _internal_mutable_tags();
}

// repeated .v1.model.InterventionResponse responses = 7 [json_name = "responses"];
inline int InterventionRequest::_internal_responses_size() const {
  return responses_.size();
}
inline int InterventionRequest::responses_size() const {
  return _internal_responses_size();
}
inline void InterventionRequest::clear_responses() {
  responses_.Clear();
}
inline ::v1::model::InterventionResponse* InterventionRequest::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionRequest.responses)
  return responses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::InterventionResponse >*
InterventionRequest::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.InterventionRequest.responses)
  return &responses_;
}
inline const ::v1::model::InterventionResponse& InterventionRequest::_internal_responses(int index) const {
  return responses_.Get(index);
}
inline const ::v1::model::InterventionResponse& InterventionRequest::responses(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionRequest.responses)
  return _internal_responses(index);
}
inline ::v1::model::InterventionResponse* InterventionRequest::_internal_add_responses() {
  return responses_.Add();
}
inline ::v1::model::InterventionResponse* InterventionRequest::add_responses() {
  ::v1::model::InterventionResponse* _add = _internal_add_responses();
  // @@protoc_insertion_point(field_add:v1.model.InterventionRequest.responses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::InterventionResponse >&
InterventionRequest::responses() const {
  // @@protoc_insertion_point(field_list:v1.model.InterventionRequest.responses)
  return responses_;
}

inline bool InterventionRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void InterventionRequest::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline InterventionRequest::DataCase InterventionRequest::data_case() const {
  return InterventionRequest::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InterventionResponse

// string id = 1 [json_name = "id"];
inline void InterventionResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& InterventionResponse::id() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InterventionResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.InterventionResponse.id)
}
inline std::string* InterventionResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionResponse.id)
  return _s;
}
inline const std::string& InterventionResponse::_internal_id() const {
  return id_.Get();
}
inline void InterventionResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* InterventionResponse::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* InterventionResponse::release_id() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionResponse.id)
  return id_.Release();
}
inline void InterventionResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.InterventionResponse.id)
}

// string request_id = 2 [json_name = "requestId"];
inline void InterventionResponse::clear_request_id() {
  request_id_.ClearToEmpty();
}
inline const std::string& InterventionResponse::request_id() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionResponse.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InterventionResponse::set_request_id(ArgT0&& arg0, ArgT... args) {
 
 request_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.InterventionResponse.request_id)
}
inline std::string* InterventionResponse::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionResponse.request_id)
  return _s;
}
inline const std::string& InterventionResponse::_internal_request_id() const {
  return request_id_.Get();
}
inline void InterventionResponse::_internal_set_request_id(const std::string& value) {
  
  request_id_.Set(value, GetArenaForAllocation());
}
inline std::string* InterventionResponse::_internal_mutable_request_id() {
  
  return request_id_.Mutable(GetArenaForAllocation());
}
inline std::string* InterventionResponse::release_request_id() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionResponse.request_id)
  return request_id_.Release();
}
inline void InterventionResponse::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    
  } else {
    
  }
  request_id_.SetAllocated(request_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault()) {
    request_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.InterventionResponse.request_id)
}

// int64 timestamp = 3 [json_name = "timestamp"];
inline void InterventionResponse::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline int64_t InterventionResponse::_internal_timestamp() const {
  return timestamp_;
}
inline int64_t InterventionResponse::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionResponse.timestamp)
  return _internal_timestamp();
}
inline void InterventionResponse::_internal_set_timestamp(int64_t value) {
  
  timestamp_ = value;
}
inline void InterventionResponse::set_timestamp(int64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.InterventionResponse.timestamp)
}

// .v1.model.SelectionResponse selection_response = 4 [json_name = "selectionResponse"];
inline bool InterventionResponse::_internal_has_selection_response() const {
  return data_case() == kSelectionResponse;
}
inline bool InterventionResponse::has_selection_response() const {
  return _internal_has_selection_response();
}
inline void InterventionResponse::set_has_selection_response() {
  _oneof_case_[0] = kSelectionResponse;
}
inline void InterventionResponse::clear_selection_response() {
  if (_internal_has_selection_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.selection_response_;
    }
    clear_has_data();
  }
}
inline ::v1::model::SelectionResponse* InterventionResponse::release_selection_response() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionResponse.selection_response)
  if (_internal_has_selection_response()) {
    clear_has_data();
    ::v1::model::SelectionResponse* temp = data_.selection_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.selection_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::SelectionResponse& InterventionResponse::_internal_selection_response() const {
  return _internal_has_selection_response()
      ? *data_.selection_response_
      : reinterpret_cast< ::v1::model::SelectionResponse&>(::v1::model::_SelectionResponse_default_instance_);
}
inline const ::v1::model::SelectionResponse& InterventionResponse::selection_response() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionResponse.selection_response)
  return _internal_selection_response();
}
inline ::v1::model::SelectionResponse* InterventionResponse::unsafe_arena_release_selection_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.InterventionResponse.selection_response)
  if (_internal_has_selection_response()) {
    clear_has_data();
    ::v1::model::SelectionResponse* temp = data_.selection_response_;
    data_.selection_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterventionResponse::unsafe_arena_set_allocated_selection_response(::v1::model::SelectionResponse* selection_response) {
  clear_data();
  if (selection_response) {
    set_has_selection_response();
    data_.selection_response_ = selection_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.InterventionResponse.selection_response)
}
inline ::v1::model::SelectionResponse* InterventionResponse::_internal_mutable_selection_response() {
  if (!_internal_has_selection_response()) {
    clear_data();
    set_has_selection_response();
    data_.selection_response_ = CreateMaybeMessage< ::v1::model::SelectionResponse >(GetArenaForAllocation());
  }
  return data_.selection_response_;
}
inline ::v1::model::SelectionResponse* InterventionResponse::mutable_selection_response() {
  ::v1::model::SelectionResponse* _msg = _internal_mutable_selection_response();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionResponse.selection_response)
  return _msg;
}

// .v1.model.LabelingResponse labeling_response = 5 [json_name = "labelingResponse"];
inline bool InterventionResponse::_internal_has_labeling_response() const {
  return data_case() == kLabelingResponse;
}
inline bool InterventionResponse::has_labeling_response() const {
  return _internal_has_labeling_response();
}
inline void InterventionResponse::set_has_labeling_response() {
  _oneof_case_[0] = kLabelingResponse;
}
inline void InterventionResponse::clear_labeling_response() {
  if (_internal_has_labeling_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.labeling_response_;
    }
    clear_has_data();
  }
}
inline ::v1::model::LabelingResponse* InterventionResponse::release_labeling_response() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionResponse.labeling_response)
  if (_internal_has_labeling_response()) {
    clear_has_data();
    ::v1::model::LabelingResponse* temp = data_.labeling_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.labeling_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::LabelingResponse& InterventionResponse::_internal_labeling_response() const {
  return _internal_has_labeling_response()
      ? *data_.labeling_response_
      : reinterpret_cast< ::v1::model::LabelingResponse&>(::v1::model::_LabelingResponse_default_instance_);
}
inline const ::v1::model::LabelingResponse& InterventionResponse::labeling_response() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionResponse.labeling_response)
  return _internal_labeling_response();
}
inline ::v1::model::LabelingResponse* InterventionResponse::unsafe_arena_release_labeling_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.InterventionResponse.labeling_response)
  if (_internal_has_labeling_response()) {
    clear_has_data();
    ::v1::model::LabelingResponse* temp = data_.labeling_response_;
    data_.labeling_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterventionResponse::unsafe_arena_set_allocated_labeling_response(::v1::model::LabelingResponse* labeling_response) {
  clear_data();
  if (labeling_response) {
    set_has_labeling_response();
    data_.labeling_response_ = labeling_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.InterventionResponse.labeling_response)
}
inline ::v1::model::LabelingResponse* InterventionResponse::_internal_mutable_labeling_response() {
  if (!_internal_has_labeling_response()) {
    clear_data();
    set_has_labeling_response();
    data_.labeling_response_ = CreateMaybeMessage< ::v1::model::LabelingResponse >(GetArenaForAllocation());
  }
  return data_.labeling_response_;
}
inline ::v1::model::LabelingResponse* InterventionResponse::mutable_labeling_response() {
  ::v1::model::LabelingResponse* _msg = _internal_mutable_labeling_response();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionResponse.labeling_response)
  return _msg;
}

// .v1.model.TeleopResponse teleop_response = 6 [json_name = "teleopResponse"];
inline bool InterventionResponse::_internal_has_teleop_response() const {
  return data_case() == kTeleopResponse;
}
inline bool InterventionResponse::has_teleop_response() const {
  return _internal_has_teleop_response();
}
inline void InterventionResponse::set_has_teleop_response() {
  _oneof_case_[0] = kTeleopResponse;
}
inline void InterventionResponse::clear_teleop_response() {
  if (_internal_has_teleop_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.teleop_response_;
    }
    clear_has_data();
  }
}
inline ::v1::model::TeleopResponse* InterventionResponse::release_teleop_response() {
  // @@protoc_insertion_point(field_release:v1.model.InterventionResponse.teleop_response)
  if (_internal_has_teleop_response()) {
    clear_has_data();
    ::v1::model::TeleopResponse* temp = data_.teleop_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.teleop_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::TeleopResponse& InterventionResponse::_internal_teleop_response() const {
  return _internal_has_teleop_response()
      ? *data_.teleop_response_
      : reinterpret_cast< ::v1::model::TeleopResponse&>(::v1::model::_TeleopResponse_default_instance_);
}
inline const ::v1::model::TeleopResponse& InterventionResponse::teleop_response() const {
  // @@protoc_insertion_point(field_get:v1.model.InterventionResponse.teleop_response)
  return _internal_teleop_response();
}
inline ::v1::model::TeleopResponse* InterventionResponse::unsafe_arena_release_teleop_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.InterventionResponse.teleop_response)
  if (_internal_has_teleop_response()) {
    clear_has_data();
    ::v1::model::TeleopResponse* temp = data_.teleop_response_;
    data_.teleop_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InterventionResponse::unsafe_arena_set_allocated_teleop_response(::v1::model::TeleopResponse* teleop_response) {
  clear_data();
  if (teleop_response) {
    set_has_teleop_response();
    data_.teleop_response_ = teleop_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.InterventionResponse.teleop_response)
}
inline ::v1::model::TeleopResponse* InterventionResponse::_internal_mutable_teleop_response() {
  if (!_internal_has_teleop_response()) {
    clear_data();
    set_has_teleop_response();
    data_.teleop_response_ = CreateMaybeMessage< ::v1::model::TeleopResponse >(GetArenaForAllocation());
  }
  return data_.teleop_response_;
}
inline ::v1::model::TeleopResponse* InterventionResponse::mutable_teleop_response() {
  ::v1::model::TeleopResponse* _msg = _internal_mutable_teleop_response();
  // @@protoc_insertion_point(field_mutable:v1.model.InterventionResponse.teleop_response)
  return _msg;
}

inline bool InterventionResponse::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void InterventionResponse::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline InterventionResponse::DataCase InterventionResponse::data_case() const {
  return InterventionResponse::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Label

// string value = 1 [json_name = "value"];
inline void Label::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& Label::value() const {
  // @@protoc_insertion_point(field_get:v1.model.Label.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Label::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Label.value)
}
inline std::string* Label::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:v1.model.Label.value)
  return _s;
}
inline const std::string& Label::_internal_value() const {
  return value_.Get();
}
inline void Label::_internal_set_value(const std::string& value) {
  
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* Label::_internal_mutable_value() {
  
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* Label::release_value() {
  // @@protoc_insertion_point(field_release:v1.model.Label.value)
  return value_.Release();
}
inline void Label::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.Label.value)
}

// string display_name = 2 [json_name = "displayName"];
inline void Label::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& Label::display_name() const {
  // @@protoc_insertion_point(field_get:v1.model.Label.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Label::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Label.display_name)
}
inline std::string* Label::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:v1.model.Label.display_name)
  return _s;
}
inline const std::string& Label::_internal_display_name() const {
  return display_name_.Get();
}
inline void Label::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Label::_internal_mutable_display_name() {
  
  return display_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Label::release_display_name() {
  // @@protoc_insertion_point(field_release:v1.model.Label.display_name)
  return display_name_.Release();
}
inline void Label::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(display_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault()) {
    display_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.Label.display_name)
}

// -------------------------------------------------------------------

// LabeledPolygon

// repeated .v1.model.Vertex vertices = 1 [json_name = "vertices"];
inline int LabeledPolygon::_internal_vertices_size() const {
  return vertices_.size();
}
inline int LabeledPolygon::vertices_size() const {
  return _internal_vertices_size();
}
inline void LabeledPolygon::clear_vertices() {
  vertices_.Clear();
}
inline ::v1::model::Vertex* LabeledPolygon::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.LabeledPolygon.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Vertex >*
LabeledPolygon::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.LabeledPolygon.vertices)
  return &vertices_;
}
inline const ::v1::model::Vertex& LabeledPolygon::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::v1::model::Vertex& LabeledPolygon::vertices(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.LabeledPolygon.vertices)
  return _internal_vertices(index);
}
inline ::v1::model::Vertex* LabeledPolygon::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::v1::model::Vertex* LabeledPolygon::add_vertices() {
  ::v1::model::Vertex* _add = _internal_add_vertices();
  // @@protoc_insertion_point(field_add:v1.model.LabeledPolygon.vertices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Vertex >&
LabeledPolygon::vertices() const {
  // @@protoc_insertion_point(field_list:v1.model.LabeledPolygon.vertices)
  return vertices_;
}

// repeated string labels = 2 [json_name = "labels"];
inline int LabeledPolygon::_internal_labels_size() const {
  return labels_.size();
}
inline int LabeledPolygon::labels_size() const {
  return _internal_labels_size();
}
inline void LabeledPolygon::clear_labels() {
  labels_.Clear();
}
inline std::string* LabeledPolygon::add_labels() {
  std::string* _s = _internal_add_labels();
  // @@protoc_insertion_point(field_add_mutable:v1.model.LabeledPolygon.labels)
  return _s;
}
inline const std::string& LabeledPolygon::_internal_labels(int index) const {
  return labels_.Get(index);
}
inline const std::string& LabeledPolygon::labels(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.LabeledPolygon.labels)
  return _internal_labels(index);
}
inline std::string* LabeledPolygon::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.LabeledPolygon.labels)
  return labels_.Mutable(index);
}
inline void LabeledPolygon::set_labels(int index, const std::string& value) {
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:v1.model.LabeledPolygon.labels)
}
inline void LabeledPolygon::set_labels(int index, std::string&& value) {
  labels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:v1.model.LabeledPolygon.labels)
}
inline void LabeledPolygon::set_labels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  labels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.model.LabeledPolygon.labels)
}
inline void LabeledPolygon::set_labels(int index, const char* value, size_t size) {
  labels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.model.LabeledPolygon.labels)
}
inline std::string* LabeledPolygon::_internal_add_labels() {
  return labels_.Add();
}
inline void LabeledPolygon::add_labels(const std::string& value) {
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.model.LabeledPolygon.labels)
}
inline void LabeledPolygon::add_labels(std::string&& value) {
  labels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.model.LabeledPolygon.labels)
}
inline void LabeledPolygon::add_labels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  labels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.model.LabeledPolygon.labels)
}
inline void LabeledPolygon::add_labels(const char* value, size_t size) {
  labels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.model.LabeledPolygon.labels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LabeledPolygon::labels() const {
  // @@protoc_insertion_point(field_list:v1.model.LabeledPolygon.labels)
  return labels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LabeledPolygon::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.LabeledPolygon.labels)
  return &labels_;
}

// -------------------------------------------------------------------

// Vertex

// double x = 1 [json_name = "x"];
inline void Vertex::clear_x() {
  x_ = 0;
}
inline double Vertex::_internal_x() const {
  return x_;
}
inline double Vertex::x() const {
  // @@protoc_insertion_point(field_get:v1.model.Vertex.x)
  return _internal_x();
}
inline void Vertex::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vertex::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:v1.model.Vertex.x)
}

// double y = 2 [json_name = "y"];
inline void Vertex::clear_y() {
  y_ = 0;
}
inline double Vertex::_internal_y() const {
  return y_;
}
inline double Vertex::y() const {
  // @@protoc_insertion_point(field_get:v1.model.Vertex.y)
  return _internal_y();
}
inline void Vertex::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vertex::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:v1.model.Vertex.y)
}

// -------------------------------------------------------------------

// LabelingRequest

// string title = 1 [json_name = "title"];
inline void LabelingRequest::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& LabelingRequest::title() const {
  // @@protoc_insertion_point(field_get:v1.model.LabelingRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelingRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.LabelingRequest.title)
}
inline std::string* LabelingRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:v1.model.LabelingRequest.title)
  return _s;
}
inline const std::string& LabelingRequest::_internal_title() const {
  return title_.Get();
}
inline void LabelingRequest::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelingRequest::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelingRequest::release_title() {
  // @@protoc_insertion_point(field_release:v1.model.LabelingRequest.title)
  return title_.Release();
}
inline void LabelingRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.LabelingRequest.title)
}

// string instruction = 2 [json_name = "instruction"];
inline void LabelingRequest::clear_instruction() {
  instruction_.ClearToEmpty();
}
inline const std::string& LabelingRequest::instruction() const {
  // @@protoc_insertion_point(field_get:v1.model.LabelingRequest.instruction)
  return _internal_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LabelingRequest::set_instruction(ArgT0&& arg0, ArgT... args) {
 
 instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.LabelingRequest.instruction)
}
inline std::string* LabelingRequest::mutable_instruction() {
  std::string* _s = _internal_mutable_instruction();
  // @@protoc_insertion_point(field_mutable:v1.model.LabelingRequest.instruction)
  return _s;
}
inline const std::string& LabelingRequest::_internal_instruction() const {
  return instruction_.Get();
}
inline void LabelingRequest::_internal_set_instruction(const std::string& value) {
  
  instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* LabelingRequest::_internal_mutable_instruction() {
  
  return instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* LabelingRequest::release_instruction() {
  // @@protoc_insertion_point(field_release:v1.model.LabelingRequest.instruction)
  return instruction_.Release();
}
inline void LabelingRequest::set_allocated_instruction(std::string* instruction) {
  if (instruction != nullptr) {
    
  } else {
    
  }
  instruction_.SetAllocated(instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instruction_.IsDefault()) {
    instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.LabelingRequest.instruction)
}

// .v1.model.Image image = 3 [json_name = "image"];
inline bool LabelingRequest::_internal_has_image() const {
  return this != internal_default_instance() && image_ != nullptr;
}
inline bool LabelingRequest::has_image() const {
  return _internal_has_image();
}
inline const ::v1::model::Image& LabelingRequest::_internal_image() const {
  const ::v1::model::Image* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::v1::model::Image&>(
      ::v1::model::_Image_default_instance_);
}
inline const ::v1::model::Image& LabelingRequest::image() const {
  // @@protoc_insertion_point(field_get:v1.model.LabelingRequest.image)
  return _internal_image();
}
inline void LabelingRequest::unsafe_arena_set_allocated_image(
    ::v1::model::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.LabelingRequest.image)
}
inline ::v1::model::Image* LabelingRequest::release_image() {
  
  ::v1::model::Image* temp = image_;
  image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::v1::model::Image* LabelingRequest::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:v1.model.LabelingRequest.image)
  
  ::v1::model::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::v1::model::Image* LabelingRequest::_internal_mutable_image() {
  
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::v1::model::Image>(GetArenaForAllocation());
    image_ = p;
  }
  return image_;
}
inline ::v1::model::Image* LabelingRequest::mutable_image() {
  ::v1::model::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:v1.model.LabelingRequest.image)
  return _msg;
}
inline void LabelingRequest::set_allocated_image(::v1::model::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image));
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    
  } else {
    
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:v1.model.LabelingRequest.image)
}

// repeated .v1.model.Label labels = 4 [json_name = "labels"];
inline int LabelingRequest::_internal_labels_size() const {
  return labels_.size();
}
inline int LabelingRequest::labels_size() const {
  return _internal_labels_size();
}
inline void LabelingRequest::clear_labels() {
  labels_.Clear();
}
inline ::v1::model::Label* LabelingRequest::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.LabelingRequest.labels)
  return labels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Label >*
LabelingRequest::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.LabelingRequest.labels)
  return &labels_;
}
inline const ::v1::model::Label& LabelingRequest::_internal_labels(int index) const {
  return labels_.Get(index);
}
inline const ::v1::model::Label& LabelingRequest::labels(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.LabelingRequest.labels)
  return _internal_labels(index);
}
inline ::v1::model::Label* LabelingRequest::_internal_add_labels() {
  return labels_.Add();
}
inline ::v1::model::Label* LabelingRequest::add_labels() {
  ::v1::model::Label* _add = _internal_add_labels();
  // @@protoc_insertion_point(field_add:v1.model.LabelingRequest.labels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::Label >&
LabelingRequest::labels() const {
  // @@protoc_insertion_point(field_list:v1.model.LabelingRequest.labels)
  return labels_;
}

// repeated .v1.model.LabeledPolygon hint = 5 [json_name = "hint"];
inline int LabelingRequest::_internal_hint_size() const {
  return hint_.size();
}
inline int LabelingRequest::hint_size() const {
  return _internal_hint_size();
}
inline void LabelingRequest::clear_hint() {
  hint_.Clear();
}
inline ::v1::model::LabeledPolygon* LabelingRequest::mutable_hint(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.LabelingRequest.hint)
  return hint_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >*
LabelingRequest::mutable_hint() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.LabelingRequest.hint)
  return &hint_;
}
inline const ::v1::model::LabeledPolygon& LabelingRequest::_internal_hint(int index) const {
  return hint_.Get(index);
}
inline const ::v1::model::LabeledPolygon& LabelingRequest::hint(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.LabelingRequest.hint)
  return _internal_hint(index);
}
inline ::v1::model::LabeledPolygon* LabelingRequest::_internal_add_hint() {
  return hint_.Add();
}
inline ::v1::model::LabeledPolygon* LabelingRequest::add_hint() {
  ::v1::model::LabeledPolygon* _add = _internal_add_hint();
  // @@protoc_insertion_point(field_add:v1.model.LabelingRequest.hint)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >&
LabelingRequest::hint() const {
  // @@protoc_insertion_point(field_list:v1.model.LabelingRequest.hint)
  return hint_;
}

// -------------------------------------------------------------------

// LabelingResponse

// repeated .v1.model.LabeledPolygon value = 1 [json_name = "value"];
inline int LabelingResponse::_internal_value_size() const {
  return value_.size();
}
inline int LabelingResponse::value_size() const {
  return _internal_value_size();
}
inline void LabelingResponse::clear_value() {
  value_.Clear();
}
inline ::v1::model::LabeledPolygon* LabelingResponse::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.LabelingResponse.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >*
LabelingResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.LabelingResponse.value)
  return &value_;
}
inline const ::v1::model::LabeledPolygon& LabelingResponse::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::v1::model::LabeledPolygon& LabelingResponse::value(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.LabelingResponse.value)
  return _internal_value(index);
}
inline ::v1::model::LabeledPolygon* LabelingResponse::_internal_add_value() {
  return value_.Add();
}
inline ::v1::model::LabeledPolygon* LabelingResponse::add_value() {
  ::v1::model::LabeledPolygon* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:v1.model.LabelingResponse.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::v1::model::LabeledPolygon >&
LabelingResponse::value() const {
  // @@protoc_insertion_point(field_list:v1.model.LabelingResponse.value)
  return value_;
}

// -------------------------------------------------------------------

// SelectionRequest

// string title = 1 [json_name = "title"];
inline void SelectionRequest::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& SelectionRequest::title() const {
  // @@protoc_insertion_point(field_get:v1.model.SelectionRequest.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectionRequest::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.SelectionRequest.title)
}
inline std::string* SelectionRequest::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:v1.model.SelectionRequest.title)
  return _s;
}
inline const std::string& SelectionRequest::_internal_title() const {
  return title_.Get();
}
inline void SelectionRequest::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectionRequest::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectionRequest::release_title() {
  // @@protoc_insertion_point(field_release:v1.model.SelectionRequest.title)
  return title_.Release();
}
inline void SelectionRequest::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.SelectionRequest.title)
}

// .v1.model.Image image = 2 [json_name = "image"];
inline bool SelectionRequest::_internal_has_image() const {
  return data_case() == kImage;
}
inline bool SelectionRequest::has_image() const {
  return _internal_has_image();
}
inline void SelectionRequest::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline ::v1::model::Image* SelectionRequest::release_image() {
  // @@protoc_insertion_point(field_release:v1.model.SelectionRequest.image)
  if (_internal_has_image()) {
    clear_has_data();
    ::v1::model::Image* temp = data_.image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Image& SelectionRequest::_internal_image() const {
  return _internal_has_image()
      ? *data_.image_
      : reinterpret_cast< ::v1::model::Image&>(::v1::model::_Image_default_instance_);
}
inline const ::v1::model::Image& SelectionRequest::image() const {
  // @@protoc_insertion_point(field_get:v1.model.SelectionRequest.image)
  return _internal_image();
}
inline ::v1::model::Image* SelectionRequest::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.SelectionRequest.image)
  if (_internal_has_image()) {
    clear_has_data();
    ::v1::model::Image* temp = data_.image_;
    data_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SelectionRequest::unsafe_arena_set_allocated_image(::v1::model::Image* image) {
  clear_data();
  if (image) {
    set_has_image();
    data_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.SelectionRequest.image)
}
inline ::v1::model::Image* SelectionRequest::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_data();
    set_has_image();
    data_.image_ = CreateMaybeMessage< ::v1::model::Image >(GetArenaForAllocation());
  }
  return data_.image_;
}
inline ::v1::model::Image* SelectionRequest::mutable_image() {
  ::v1::model::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:v1.model.SelectionRequest.image)
  return _msg;
}

// string instruction = 3 [json_name = "instruction"];
inline void SelectionRequest::clear_instruction() {
  instruction_.ClearToEmpty();
}
inline const std::string& SelectionRequest::instruction() const {
  // @@protoc_insertion_point(field_get:v1.model.SelectionRequest.instruction)
  return _internal_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SelectionRequest::set_instruction(ArgT0&& arg0, ArgT... args) {
 
 instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.SelectionRequest.instruction)
}
inline std::string* SelectionRequest::mutable_instruction() {
  std::string* _s = _internal_mutable_instruction();
  // @@protoc_insertion_point(field_mutable:v1.model.SelectionRequest.instruction)
  return _s;
}
inline const std::string& SelectionRequest::_internal_instruction() const {
  return instruction_.Get();
}
inline void SelectionRequest::_internal_set_instruction(const std::string& value) {
  
  instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* SelectionRequest::_internal_mutable_instruction() {
  
  return instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* SelectionRequest::release_instruction() {
  // @@protoc_insertion_point(field_release:v1.model.SelectionRequest.instruction)
  return instruction_.Release();
}
inline void SelectionRequest::set_allocated_instruction(std::string* instruction) {
  if (instruction != nullptr) {
    
  } else {
    
  }
  instruction_.SetAllocated(instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instruction_.IsDefault()) {
    instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.SelectionRequest.instruction)
}

// repeated string options = 4 [json_name = "options"];
inline int SelectionRequest::_internal_options_size() const {
  return options_.size();
}
inline int SelectionRequest::options_size() const {
  return _internal_options_size();
}
inline void SelectionRequest::clear_options() {
  options_.Clear();
}
inline std::string* SelectionRequest::add_options() {
  std::string* _s = _internal_add_options();
  // @@protoc_insertion_point(field_add_mutable:v1.model.SelectionRequest.options)
  return _s;
}
inline const std::string& SelectionRequest::_internal_options(int index) const {
  return options_.Get(index);
}
inline const std::string& SelectionRequest::options(int index) const {
  // @@protoc_insertion_point(field_get:v1.model.SelectionRequest.options)
  return _internal_options(index);
}
inline std::string* SelectionRequest::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:v1.model.SelectionRequest.options)
  return options_.Mutable(index);
}
inline void SelectionRequest::set_options(int index, const std::string& value) {
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:v1.model.SelectionRequest.options)
}
inline void SelectionRequest::set_options(int index, std::string&& value) {
  options_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:v1.model.SelectionRequest.options)
}
inline void SelectionRequest::set_options(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  options_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:v1.model.SelectionRequest.options)
}
inline void SelectionRequest::set_options(int index, const char* value, size_t size) {
  options_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:v1.model.SelectionRequest.options)
}
inline std::string* SelectionRequest::_internal_add_options() {
  return options_.Add();
}
inline void SelectionRequest::add_options(const std::string& value) {
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:v1.model.SelectionRequest.options)
}
inline void SelectionRequest::add_options(std::string&& value) {
  options_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:v1.model.SelectionRequest.options)
}
inline void SelectionRequest::add_options(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  options_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:v1.model.SelectionRequest.options)
}
inline void SelectionRequest::add_options(const char* value, size_t size) {
  options_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:v1.model.SelectionRequest.options)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectionRequest::options() const {
  // @@protoc_insertion_point(field_list:v1.model.SelectionRequest.options)
  return options_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectionRequest::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:v1.model.SelectionRequest.options)
  return &options_;
}

// uint32 hint = 5 [json_name = "hint"];
inline void SelectionRequest::clear_hint() {
  hint_ = 0u;
}
inline uint32_t SelectionRequest::_internal_hint() const {
  return hint_;
}
inline uint32_t SelectionRequest::hint() const {
  // @@protoc_insertion_point(field_get:v1.model.SelectionRequest.hint)
  return _internal_hint();
}
inline void SelectionRequest::_internal_set_hint(uint32_t value) {
  
  hint_ = value;
}
inline void SelectionRequest::set_hint(uint32_t value) {
  _internal_set_hint(value);
  // @@protoc_insertion_point(field_set:v1.model.SelectionRequest.hint)
}

inline bool SelectionRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SelectionRequest::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline SelectionRequest::DataCase SelectionRequest::data_case() const {
  return SelectionRequest::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SelectionResponse

// uint32 value = 1 [json_name = "value"];
inline void SelectionResponse::clear_value() {
  value_ = 0u;
}
inline uint32_t SelectionResponse::_internal_value() const {
  return value_;
}
inline uint32_t SelectionResponse::value() const {
  // @@protoc_insertion_point(field_get:v1.model.SelectionResponse.value)
  return _internal_value();
}
inline void SelectionResponse::_internal_set_value(uint32_t value) {
  
  value_ = value;
}
inline void SelectionResponse::set_value(uint32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:v1.model.SelectionResponse.value)
}

// -------------------------------------------------------------------

// TeleopRequest

// string instruction = 1 [json_name = "instruction"];
inline void TeleopRequest::clear_instruction() {
  instruction_.ClearToEmpty();
}
inline const std::string& TeleopRequest::instruction() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopRequest.instruction)
  return _internal_instruction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopRequest::set_instruction(ArgT0&& arg0, ArgT... args) {
 
 instruction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopRequest.instruction)
}
inline std::string* TeleopRequest::mutable_instruction() {
  std::string* _s = _internal_mutable_instruction();
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopRequest.instruction)
  return _s;
}
inline const std::string& TeleopRequest::_internal_instruction() const {
  return instruction_.Get();
}
inline void TeleopRequest::_internal_set_instruction(const std::string& value) {
  
  instruction_.Set(value, GetArenaForAllocation());
}
inline std::string* TeleopRequest::_internal_mutable_instruction() {
  
  return instruction_.Mutable(GetArenaForAllocation());
}
inline std::string* TeleopRequest::release_instruction() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopRequest.instruction)
  return instruction_.Release();
}
inline void TeleopRequest::set_allocated_instruction(std::string* instruction) {
  if (instruction != nullptr) {
    
  } else {
    
  }
  instruction_.SetAllocated(instruction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (instruction_.IsDefault()) {
    instruction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopRequest.instruction)
}

// -------------------------------------------------------------------

// TeleopResponse

// string state = 1 [json_name = "state"];
inline void TeleopResponse::clear_state() {
  state_.ClearToEmpty();
}
inline const std::string& TeleopResponse::state() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopResponse.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopResponse::set_state(ArgT0&& arg0, ArgT... args) {
 
 state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopResponse.state)
}
inline std::string* TeleopResponse::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopResponse.state)
  return _s;
}
inline const std::string& TeleopResponse::_internal_state() const {
  return state_.Get();
}
inline void TeleopResponse::_internal_set_state(const std::string& value) {
  
  state_.Set(value, GetArenaForAllocation());
}
inline std::string* TeleopResponse::_internal_mutable_state() {
  
  return state_.Mutable(GetArenaForAllocation());
}
inline std::string* TeleopResponse::release_state() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopResponse.state)
  return state_.Release();
}
inline void TeleopResponse::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault()) {
    state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopResponse.state)
}

// string notes = 2 [json_name = "notes"];
inline void TeleopResponse::clear_notes() {
  notes_.ClearToEmpty();
}
inline const std::string& TeleopResponse::notes() const {
  // @@protoc_insertion_point(field_get:v1.model.TeleopResponse.notes)
  return _internal_notes();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TeleopResponse::set_notes(ArgT0&& arg0, ArgT... args) {
 
 notes_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.TeleopResponse.notes)
}
inline std::string* TeleopResponse::mutable_notes() {
  std::string* _s = _internal_mutable_notes();
  // @@protoc_insertion_point(field_mutable:v1.model.TeleopResponse.notes)
  return _s;
}
inline const std::string& TeleopResponse::_internal_notes() const {
  return notes_.Get();
}
inline void TeleopResponse::_internal_set_notes(const std::string& value) {
  
  notes_.Set(value, GetArenaForAllocation());
}
inline std::string* TeleopResponse::_internal_mutable_notes() {
  
  return notes_.Mutable(GetArenaForAllocation());
}
inline std::string* TeleopResponse::release_notes() {
  // @@protoc_insertion_point(field_release:v1.model.TeleopResponse.notes)
  return notes_.Release();
}
inline void TeleopResponse::set_allocated_notes(std::string* notes) {
  if (notes != nullptr) {
    
  } else {
    
  }
  notes_.SetAllocated(notes, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (notes_.IsDefault()) {
    notes_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:v1.model.TeleopResponse.notes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace v1

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fintervention_2eproto
