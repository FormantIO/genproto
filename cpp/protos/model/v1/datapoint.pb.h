// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protos/model/v1/datapoint.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "protos/model/v1/file.pb.h"
#include "protos/model/v1/health.pb.h"
#include "protos/model/v1/math.pb.h"
#include "protos/model/v1/navigation.pb.h"
#include "protos/model/v1/text.pb.h"
#include "protos/model/v1/media.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_protos_2fmodel_2fv1_2fdatapoint_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_protos_2fmodel_2fv1_2fdatapoint_2eproto;
namespace v1 {
namespace model {
class ControlDatapoint;
struct ControlDatapointDefaultTypeInternal;
extern ControlDatapointDefaultTypeInternal _ControlDatapoint_default_instance_;
class Datapoint;
struct DatapointDefaultTypeInternal;
extern DatapointDefaultTypeInternal _Datapoint_default_instance_;
class Datapoint_TagsEntry_DoNotUse;
struct Datapoint_TagsEntry_DoNotUseDefaultTypeInternal;
extern Datapoint_TagsEntry_DoNotUseDefaultTypeInternal _Datapoint_TagsEntry_DoNotUse_default_instance_;
}  // namespace model
}  // namespace v1
PROTOBUF_NAMESPACE_OPEN
template<> ::v1::model::ControlDatapoint* Arena::CreateMaybeMessage<::v1::model::ControlDatapoint>(Arena*);
template<> ::v1::model::Datapoint* Arena::CreateMaybeMessage<::v1::model::Datapoint>(Arena*);
template<> ::v1::model::Datapoint_TagsEntry_DoNotUse* Arena::CreateMaybeMessage<::v1::model::Datapoint_TagsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace v1 {
namespace model {

// ===================================================================

class Datapoint_TagsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Datapoint_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Datapoint_TagsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  Datapoint_TagsEntry_DoNotUse();
  explicit constexpr Datapoint_TagsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Datapoint_TagsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Datapoint_TagsEntry_DoNotUse& other);
  static const Datapoint_TagsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Datapoint_TagsEntry_DoNotUse*>(&_Datapoint_TagsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.Datapoint.TagsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "v1.model.Datapoint.TagsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Datapoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.Datapoint) */ {
 public:
  inline Datapoint() : Datapoint(nullptr) {}
  ~Datapoint() override;
  explicit constexpr Datapoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Datapoint(const Datapoint& from);
  Datapoint(Datapoint&& from) noexcept
    : Datapoint() {
    *this = ::std::move(from);
  }

  inline Datapoint& operator=(const Datapoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline Datapoint& operator=(Datapoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Datapoint& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kText = 4,
    kNumeric = 5,
    kNumericSet = 17,
    kBitset = 7,
    kFile = 8,
    kImage = 9,
    kPointCloud = 10,
    kLocation = 11,
    kLocalization = 12,
    kHealth = 13,
    kJson = 14,
    kBattery = 15,
    kVideo = 16,
    kTransformTree = 18,
    DATA_NOT_SET = 0,
  };

  static inline const Datapoint* internal_default_instance() {
    return reinterpret_cast<const Datapoint*>(
               &_Datapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Datapoint& a, Datapoint& b) {
    a.Swap(&b);
  }
  inline void Swap(Datapoint* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Datapoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Datapoint* New() const final {
    return new Datapoint();
  }

  Datapoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Datapoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Datapoint& from);
  void MergeFrom(const Datapoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datapoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.Datapoint";
  }
  protected:
  explicit Datapoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 3,
    kStreamFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kTextFieldNumber = 4,
    kNumericFieldNumber = 5,
    kNumericSetFieldNumber = 17,
    kBitsetFieldNumber = 7,
    kFileFieldNumber = 8,
    kImageFieldNumber = 9,
    kPointCloudFieldNumber = 10,
    kLocationFieldNumber = 11,
    kLocalizationFieldNumber = 12,
    kHealthFieldNumber = 13,
    kJsonFieldNumber = 14,
    kBatteryFieldNumber = 15,
    kVideoFieldNumber = 16,
    kTransformTreeFieldNumber = 18,
  };
  // map<string, string> tags = 3 [json_name = "tags"];
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_tags();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      tags() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_tags();

  // string stream = 1 [json_name = "stream"];
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // int64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .v1.model.Text text = 4 [json_name = "text"];
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::v1::model::Text& text() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Text* release_text();
  ::v1::model::Text* mutable_text();
  void set_allocated_text(::v1::model::Text* text);
  private:
  const ::v1::model::Text& _internal_text() const;
  ::v1::model::Text* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::v1::model::Text* text);
  ::v1::model::Text* unsafe_arena_release_text();

  // .v1.model.Numeric numeric = 5 [json_name = "numeric"];
  bool has_numeric() const;
  private:
  bool _internal_has_numeric() const;
  public:
  void clear_numeric();
  const ::v1::model::Numeric& numeric() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Numeric* release_numeric();
  ::v1::model::Numeric* mutable_numeric();
  void set_allocated_numeric(::v1::model::Numeric* numeric);
  private:
  const ::v1::model::Numeric& _internal_numeric() const;
  ::v1::model::Numeric* _internal_mutable_numeric();
  public:
  void unsafe_arena_set_allocated_numeric(
      ::v1::model::Numeric* numeric);
  ::v1::model::Numeric* unsafe_arena_release_numeric();

  // .v1.model.NumericSet numeric_set = 17 [json_name = "numericSet"];
  bool has_numeric_set() const;
  private:
  bool _internal_has_numeric_set() const;
  public:
  void clear_numeric_set();
  const ::v1::model::NumericSet& numeric_set() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::NumericSet* release_numeric_set();
  ::v1::model::NumericSet* mutable_numeric_set();
  void set_allocated_numeric_set(::v1::model::NumericSet* numeric_set);
  private:
  const ::v1::model::NumericSet& _internal_numeric_set() const;
  ::v1::model::NumericSet* _internal_mutable_numeric_set();
  public:
  void unsafe_arena_set_allocated_numeric_set(
      ::v1::model::NumericSet* numeric_set);
  ::v1::model::NumericSet* unsafe_arena_release_numeric_set();

  // .v1.model.Bitset bitset = 7 [json_name = "bitset"];
  bool has_bitset() const;
  private:
  bool _internal_has_bitset() const;
  public:
  void clear_bitset();
  const ::v1::model::Bitset& bitset() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Bitset* release_bitset();
  ::v1::model::Bitset* mutable_bitset();
  void set_allocated_bitset(::v1::model::Bitset* bitset);
  private:
  const ::v1::model::Bitset& _internal_bitset() const;
  ::v1::model::Bitset* _internal_mutable_bitset();
  public:
  void unsafe_arena_set_allocated_bitset(
      ::v1::model::Bitset* bitset);
  ::v1::model::Bitset* unsafe_arena_release_bitset();

  // .v1.model.File file = 8 [json_name = "file"];
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::v1::model::File& file() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::File* release_file();
  ::v1::model::File* mutable_file();
  void set_allocated_file(::v1::model::File* file);
  private:
  const ::v1::model::File& _internal_file() const;
  ::v1::model::File* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::v1::model::File* file);
  ::v1::model::File* unsafe_arena_release_file();

  // .v1.model.Image image = 9 [json_name = "image"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::v1::model::Image& image() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Image* release_image();
  ::v1::model::Image* mutable_image();
  void set_allocated_image(::v1::model::Image* image);
  private:
  const ::v1::model::Image& _internal_image() const;
  ::v1::model::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::v1::model::Image* image);
  ::v1::model::Image* unsafe_arena_release_image();

  // .v1.model.PointCloud point_cloud = 10 [json_name = "pointCloud"];
  bool has_point_cloud() const;
  private:
  bool _internal_has_point_cloud() const;
  public:
  void clear_point_cloud();
  const ::v1::model::PointCloud& point_cloud() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::PointCloud* release_point_cloud();
  ::v1::model::PointCloud* mutable_point_cloud();
  void set_allocated_point_cloud(::v1::model::PointCloud* point_cloud);
  private:
  const ::v1::model::PointCloud& _internal_point_cloud() const;
  ::v1::model::PointCloud* _internal_mutable_point_cloud();
  public:
  void unsafe_arena_set_allocated_point_cloud(
      ::v1::model::PointCloud* point_cloud);
  ::v1::model::PointCloud* unsafe_arena_release_point_cloud();

  // .v1.model.Location location = 11 [json_name = "location"];
  bool has_location() const;
  private:
  bool _internal_has_location() const;
  public:
  void clear_location();
  const ::v1::model::Location& location() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Location* release_location();
  ::v1::model::Location* mutable_location();
  void set_allocated_location(::v1::model::Location* location);
  private:
  const ::v1::model::Location& _internal_location() const;
  ::v1::model::Location* _internal_mutable_location();
  public:
  void unsafe_arena_set_allocated_location(
      ::v1::model::Location* location);
  ::v1::model::Location* unsafe_arena_release_location();

  // .v1.model.Localization localization = 12 [json_name = "localization"];
  bool has_localization() const;
  private:
  bool _internal_has_localization() const;
  public:
  void clear_localization();
  const ::v1::model::Localization& localization() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Localization* release_localization();
  ::v1::model::Localization* mutable_localization();
  void set_allocated_localization(::v1::model::Localization* localization);
  private:
  const ::v1::model::Localization& _internal_localization() const;
  ::v1::model::Localization* _internal_mutable_localization();
  public:
  void unsafe_arena_set_allocated_localization(
      ::v1::model::Localization* localization);
  ::v1::model::Localization* unsafe_arena_release_localization();

  // .v1.model.Health health = 13 [json_name = "health"];
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const ::v1::model::Health& health() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Health* release_health();
  ::v1::model::Health* mutable_health();
  void set_allocated_health(::v1::model::Health* health);
  private:
  const ::v1::model::Health& _internal_health() const;
  ::v1::model::Health* _internal_mutable_health();
  public:
  void unsafe_arena_set_allocated_health(
      ::v1::model::Health* health);
  ::v1::model::Health* unsafe_arena_release_health();

  // .v1.model.Json json = 14 [json_name = "json"];
  bool has_json() const;
  private:
  bool _internal_has_json() const;
  public:
  void clear_json();
  const ::v1::model::Json& json() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Json* release_json();
  ::v1::model::Json* mutable_json();
  void set_allocated_json(::v1::model::Json* json);
  private:
  const ::v1::model::Json& _internal_json() const;
  ::v1::model::Json* _internal_mutable_json();
  public:
  void unsafe_arena_set_allocated_json(
      ::v1::model::Json* json);
  ::v1::model::Json* unsafe_arena_release_json();

  // .v1.model.Battery battery = 15 [json_name = "battery"];
  bool has_battery() const;
  private:
  bool _internal_has_battery() const;
  public:
  void clear_battery();
  const ::v1::model::Battery& battery() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Battery* release_battery();
  ::v1::model::Battery* mutable_battery();
  void set_allocated_battery(::v1::model::Battery* battery);
  private:
  const ::v1::model::Battery& _internal_battery() const;
  ::v1::model::Battery* _internal_mutable_battery();
  public:
  void unsafe_arena_set_allocated_battery(
      ::v1::model::Battery* battery);
  ::v1::model::Battery* unsafe_arena_release_battery();

  // .v1.model.Video video = 16 [json_name = "video"];
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::v1::model::Video& video() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Video* release_video();
  ::v1::model::Video* mutable_video();
  void set_allocated_video(::v1::model::Video* video);
  private:
  const ::v1::model::Video& _internal_video() const;
  ::v1::model::Video* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::v1::model::Video* video);
  ::v1::model::Video* unsafe_arena_release_video();

  // .v1.model.TransformTree transform_tree = 18 [json_name = "transformTree"];
  bool has_transform_tree() const;
  private:
  bool _internal_has_transform_tree() const;
  public:
  void clear_transform_tree();
  const ::v1::model::TransformTree& transform_tree() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::TransformTree* release_transform_tree();
  ::v1::model::TransformTree* mutable_transform_tree();
  void set_allocated_transform_tree(::v1::model::TransformTree* transform_tree);
  private:
  const ::v1::model::TransformTree& _internal_transform_tree() const;
  ::v1::model::TransformTree* _internal_mutable_transform_tree();
  public:
  void unsafe_arena_set_allocated_transform_tree(
      ::v1::model::TransformTree* transform_tree);
  ::v1::model::TransformTree* unsafe_arena_release_transform_tree();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.Datapoint)
 private:
  class _Internal;
  void set_has_text();
  void set_has_numeric();
  void set_has_numeric_set();
  void set_has_bitset();
  void set_has_file();
  void set_has_image();
  void set_has_point_cloud();
  void set_has_location();
  void set_has_localization();
  void set_has_health();
  void set_has_json();
  void set_has_battery();
  void set_has_video();
  void set_has_transform_tree();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Datapoint_TagsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> tags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::Text* text_;
    ::v1::model::Numeric* numeric_;
    ::v1::model::NumericSet* numeric_set_;
    ::v1::model::Bitset* bitset_;
    ::v1::model::File* file_;
    ::v1::model::Image* image_;
    ::v1::model::PointCloud* point_cloud_;
    ::v1::model::Location* location_;
    ::v1::model::Localization* localization_;
    ::v1::model::Health* health_;
    ::v1::model::Json* json_;
    ::v1::model::Battery* battery_;
    ::v1::model::Video* video_;
    ::v1::model::TransformTree* transform_tree_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto;
};
// -------------------------------------------------------------------

class ControlDatapoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:v1.model.ControlDatapoint) */ {
 public:
  inline ControlDatapoint() : ControlDatapoint(nullptr) {}
  ~ControlDatapoint() override;
  explicit constexpr ControlDatapoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlDatapoint(const ControlDatapoint& from);
  ControlDatapoint(ControlDatapoint&& from) noexcept
    : ControlDatapoint() {
    *this = ::std::move(from);
  }

  inline ControlDatapoint& operator=(const ControlDatapoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlDatapoint& operator=(ControlDatapoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlDatapoint& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kBitset = 3,
    kTwist = 4,
    kPose = 5,
    kNumeric = 6,
    kPoseWithCovariance = 7,
    kPoint = 8,
    DATA_NOT_SET = 0,
  };

  static inline const ControlDatapoint* internal_default_instance() {
    return reinterpret_cast<const ControlDatapoint*>(
               &_ControlDatapoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ControlDatapoint& a, ControlDatapoint& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlDatapoint* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlDatapoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlDatapoint* New() const final {
    return new ControlDatapoint();
  }

  ControlDatapoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlDatapoint>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlDatapoint& from);
  void MergeFrom(const ControlDatapoint& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlDatapoint* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "v1.model.ControlDatapoint";
  }
  protected:
  explicit ControlDatapoint(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kTimestampFieldNumber = 2,
    kBitsetFieldNumber = 3,
    kTwistFieldNumber = 4,
    kPoseFieldNumber = 5,
    kNumericFieldNumber = 6,
    kPoseWithCovarianceFieldNumber = 7,
    kPointFieldNumber = 8,
  };
  // string stream = 1 [json_name = "stream"];
  void clear_stream();
  const std::string& stream() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream();
  PROTOBUF_FUTURE_MUST_USE_RESULT std::string* release_stream();
  void set_allocated_stream(std::string* stream);
  private:
  const std::string& _internal_stream() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream(const std::string& value);
  std::string* _internal_mutable_stream();
  public:

  // int64 timestamp = 2 [json_name = "timestamp"];
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .v1.model.Bitset bitset = 3 [json_name = "bitset"];
  bool has_bitset() const;
  private:
  bool _internal_has_bitset() const;
  public:
  void clear_bitset();
  const ::v1::model::Bitset& bitset() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Bitset* release_bitset();
  ::v1::model::Bitset* mutable_bitset();
  void set_allocated_bitset(::v1::model::Bitset* bitset);
  private:
  const ::v1::model::Bitset& _internal_bitset() const;
  ::v1::model::Bitset* _internal_mutable_bitset();
  public:
  void unsafe_arena_set_allocated_bitset(
      ::v1::model::Bitset* bitset);
  ::v1::model::Bitset* unsafe_arena_release_bitset();

  // .v1.model.Twist twist = 4 [json_name = "twist"];
  bool has_twist() const;
  private:
  bool _internal_has_twist() const;
  public:
  void clear_twist();
  const ::v1::model::Twist& twist() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Twist* release_twist();
  ::v1::model::Twist* mutable_twist();
  void set_allocated_twist(::v1::model::Twist* twist);
  private:
  const ::v1::model::Twist& _internal_twist() const;
  ::v1::model::Twist* _internal_mutable_twist();
  public:
  void unsafe_arena_set_allocated_twist(
      ::v1::model::Twist* twist);
  ::v1::model::Twist* unsafe_arena_release_twist();

  // .v1.model.Transform pose = 5 [json_name = "pose"];
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::v1::model::Transform& pose() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Transform* release_pose();
  ::v1::model::Transform* mutable_pose();
  void set_allocated_pose(::v1::model::Transform* pose);
  private:
  const ::v1::model::Transform& _internal_pose() const;
  ::v1::model::Transform* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::v1::model::Transform* pose);
  ::v1::model::Transform* unsafe_arena_release_pose();

  // .v1.model.Numeric numeric = 6 [json_name = "numeric"];
  bool has_numeric() const;
  private:
  bool _internal_has_numeric() const;
  public:
  void clear_numeric();
  const ::v1::model::Numeric& numeric() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Numeric* release_numeric();
  ::v1::model::Numeric* mutable_numeric();
  void set_allocated_numeric(::v1::model::Numeric* numeric);
  private:
  const ::v1::model::Numeric& _internal_numeric() const;
  ::v1::model::Numeric* _internal_mutable_numeric();
  public:
  void unsafe_arena_set_allocated_numeric(
      ::v1::model::Numeric* numeric);
  ::v1::model::Numeric* unsafe_arena_release_numeric();

  // .v1.model.PoseWithCovariance pose_with_covariance = 7 [json_name = "poseWithCovariance"];
  bool has_pose_with_covariance() const;
  private:
  bool _internal_has_pose_with_covariance() const;
  public:
  void clear_pose_with_covariance();
  const ::v1::model::PoseWithCovariance& pose_with_covariance() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::PoseWithCovariance* release_pose_with_covariance();
  ::v1::model::PoseWithCovariance* mutable_pose_with_covariance();
  void set_allocated_pose_with_covariance(::v1::model::PoseWithCovariance* pose_with_covariance);
  private:
  const ::v1::model::PoseWithCovariance& _internal_pose_with_covariance() const;
  ::v1::model::PoseWithCovariance* _internal_mutable_pose_with_covariance();
  public:
  void unsafe_arena_set_allocated_pose_with_covariance(
      ::v1::model::PoseWithCovariance* pose_with_covariance);
  ::v1::model::PoseWithCovariance* unsafe_arena_release_pose_with_covariance();

  // .v1.model.Point point = 8 [json_name = "point"];
  bool has_point() const;
  private:
  bool _internal_has_point() const;
  public:
  void clear_point();
  const ::v1::model::Point& point() const;
  PROTOBUF_FUTURE_MUST_USE_RESULT ::v1::model::Point* release_point();
  ::v1::model::Point* mutable_point();
  void set_allocated_point(::v1::model::Point* point);
  private:
  const ::v1::model::Point& _internal_point() const;
  ::v1::model::Point* _internal_mutable_point();
  public:
  void unsafe_arena_set_allocated_point(
      ::v1::model::Point* point);
  ::v1::model::Point* unsafe_arena_release_point();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:v1.model.ControlDatapoint)
 private:
  class _Internal;
  void set_has_bitset();
  void set_has_twist();
  void set_has_pose();
  void set_has_numeric();
  void set_has_pose_with_covariance();
  void set_has_point();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_;
  ::PROTOBUF_NAMESPACE_ID::int64 timestamp_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::v1::model::Bitset* bitset_;
    ::v1::model::Twist* twist_;
    ::v1::model::Transform* pose_;
    ::v1::model::Numeric* numeric_;
    ::v1::model::PoseWithCovariance* pose_with_covariance_;
    ::v1::model::Point* point_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_protos_2fmodel_2fv1_2fdatapoint_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Datapoint

// string stream = 1 [json_name = "stream"];
inline void Datapoint::clear_stream() {
  stream_.ClearToEmpty();
}
inline const std::string& Datapoint::stream() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Datapoint::set_stream(ArgT0&& arg0, ArgT... args) {
 
 stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.Datapoint.stream)
}
inline std::string* Datapoint::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.stream)
  return _internal_mutable_stream();
}
inline const std::string& Datapoint::_internal_stream() const {
  return stream_.Get();
}
inline void Datapoint::_internal_set_stream(const std::string& value) {
  
  stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Datapoint::_internal_mutable_stream() {
  
  return stream_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Datapoint::release_stream() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.stream)
  return stream_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Datapoint::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  stream_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.Datapoint.stream)
}

// int64 timestamp = 2 [json_name = "timestamp"];
inline void Datapoint::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Datapoint::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Datapoint::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.timestamp)
  return _internal_timestamp();
}
inline void Datapoint::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void Datapoint::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.Datapoint.timestamp)
}

// map<string, string> tags = 3 [json_name = "tags"];
inline int Datapoint::_internal_tags_size() const {
  return tags_.size();
}
inline int Datapoint::tags_size() const {
  return _internal_tags_size();
}
inline void Datapoint::clear_tags() {
  tags_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Datapoint::_internal_tags() const {
  return tags_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Datapoint::tags() const {
  // @@protoc_insertion_point(field_map:v1.model.Datapoint.tags)
  return _internal_tags();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Datapoint::_internal_mutable_tags() {
  return tags_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Datapoint::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_map:v1.model.Datapoint.tags)
  return _internal_mutable_tags();
}

// .v1.model.Text text = 4 [json_name = "text"];
inline bool Datapoint::_internal_has_text() const {
  return data_case() == kText;
}
inline bool Datapoint::has_text() const {
  return _internal_has_text();
}
inline void Datapoint::set_has_text() {
  _oneof_case_[0] = kText;
}
inline ::v1::model::Text* Datapoint::release_text() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.text)
  if (_internal_has_text()) {
    clear_has_data();
      ::v1::model::Text* temp = data_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Text& Datapoint::_internal_text() const {
  return _internal_has_text()
      ? *data_.text_
      : reinterpret_cast< ::v1::model::Text&>(::v1::model::_Text_default_instance_);
}
inline const ::v1::model::Text& Datapoint::text() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.text)
  return _internal_text();
}
inline ::v1::model::Text* Datapoint::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.text)
  if (_internal_has_text()) {
    clear_has_data();
    ::v1::model::Text* temp = data_.text_;
    data_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_text(::v1::model::Text* text) {
  clear_data();
  if (text) {
    set_has_text();
    data_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.text)
}
inline ::v1::model::Text* Datapoint::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    data_.text_ = CreateMaybeMessage< ::v1::model::Text >(GetArenaForAllocation());
  }
  return data_.text_;
}
inline ::v1::model::Text* Datapoint::mutable_text() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.text)
  return _internal_mutable_text();
}

// .v1.model.Numeric numeric = 5 [json_name = "numeric"];
inline bool Datapoint::_internal_has_numeric() const {
  return data_case() == kNumeric;
}
inline bool Datapoint::has_numeric() const {
  return _internal_has_numeric();
}
inline void Datapoint::set_has_numeric() {
  _oneof_case_[0] = kNumeric;
}
inline ::v1::model::Numeric* Datapoint::release_numeric() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.numeric)
  if (_internal_has_numeric()) {
    clear_has_data();
      ::v1::model::Numeric* temp = data_.numeric_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Numeric& Datapoint::_internal_numeric() const {
  return _internal_has_numeric()
      ? *data_.numeric_
      : reinterpret_cast< ::v1::model::Numeric&>(::v1::model::_Numeric_default_instance_);
}
inline const ::v1::model::Numeric& Datapoint::numeric() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.numeric)
  return _internal_numeric();
}
inline ::v1::model::Numeric* Datapoint::unsafe_arena_release_numeric() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.numeric)
  if (_internal_has_numeric()) {
    clear_has_data();
    ::v1::model::Numeric* temp = data_.numeric_;
    data_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_numeric(::v1::model::Numeric* numeric) {
  clear_data();
  if (numeric) {
    set_has_numeric();
    data_.numeric_ = numeric;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.numeric)
}
inline ::v1::model::Numeric* Datapoint::_internal_mutable_numeric() {
  if (!_internal_has_numeric()) {
    clear_data();
    set_has_numeric();
    data_.numeric_ = CreateMaybeMessage< ::v1::model::Numeric >(GetArenaForAllocation());
  }
  return data_.numeric_;
}
inline ::v1::model::Numeric* Datapoint::mutable_numeric() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.numeric)
  return _internal_mutable_numeric();
}

// .v1.model.NumericSet numeric_set = 17 [json_name = "numericSet"];
inline bool Datapoint::_internal_has_numeric_set() const {
  return data_case() == kNumericSet;
}
inline bool Datapoint::has_numeric_set() const {
  return _internal_has_numeric_set();
}
inline void Datapoint::set_has_numeric_set() {
  _oneof_case_[0] = kNumericSet;
}
inline ::v1::model::NumericSet* Datapoint::release_numeric_set() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.numeric_set)
  if (_internal_has_numeric_set()) {
    clear_has_data();
      ::v1::model::NumericSet* temp = data_.numeric_set_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.numeric_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::NumericSet& Datapoint::_internal_numeric_set() const {
  return _internal_has_numeric_set()
      ? *data_.numeric_set_
      : reinterpret_cast< ::v1::model::NumericSet&>(::v1::model::_NumericSet_default_instance_);
}
inline const ::v1::model::NumericSet& Datapoint::numeric_set() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.numeric_set)
  return _internal_numeric_set();
}
inline ::v1::model::NumericSet* Datapoint::unsafe_arena_release_numeric_set() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.numeric_set)
  if (_internal_has_numeric_set()) {
    clear_has_data();
    ::v1::model::NumericSet* temp = data_.numeric_set_;
    data_.numeric_set_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_numeric_set(::v1::model::NumericSet* numeric_set) {
  clear_data();
  if (numeric_set) {
    set_has_numeric_set();
    data_.numeric_set_ = numeric_set;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.numeric_set)
}
inline ::v1::model::NumericSet* Datapoint::_internal_mutable_numeric_set() {
  if (!_internal_has_numeric_set()) {
    clear_data();
    set_has_numeric_set();
    data_.numeric_set_ = CreateMaybeMessage< ::v1::model::NumericSet >(GetArenaForAllocation());
  }
  return data_.numeric_set_;
}
inline ::v1::model::NumericSet* Datapoint::mutable_numeric_set() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.numeric_set)
  return _internal_mutable_numeric_set();
}

// .v1.model.Bitset bitset = 7 [json_name = "bitset"];
inline bool Datapoint::_internal_has_bitset() const {
  return data_case() == kBitset;
}
inline bool Datapoint::has_bitset() const {
  return _internal_has_bitset();
}
inline void Datapoint::set_has_bitset() {
  _oneof_case_[0] = kBitset;
}
inline ::v1::model::Bitset* Datapoint::release_bitset() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.bitset)
  if (_internal_has_bitset()) {
    clear_has_data();
      ::v1::model::Bitset* temp = data_.bitset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Bitset& Datapoint::_internal_bitset() const {
  return _internal_has_bitset()
      ? *data_.bitset_
      : reinterpret_cast< ::v1::model::Bitset&>(::v1::model::_Bitset_default_instance_);
}
inline const ::v1::model::Bitset& Datapoint::bitset() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.bitset)
  return _internal_bitset();
}
inline ::v1::model::Bitset* Datapoint::unsafe_arena_release_bitset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.bitset)
  if (_internal_has_bitset()) {
    clear_has_data();
    ::v1::model::Bitset* temp = data_.bitset_;
    data_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_bitset(::v1::model::Bitset* bitset) {
  clear_data();
  if (bitset) {
    set_has_bitset();
    data_.bitset_ = bitset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.bitset)
}
inline ::v1::model::Bitset* Datapoint::_internal_mutable_bitset() {
  if (!_internal_has_bitset()) {
    clear_data();
    set_has_bitset();
    data_.bitset_ = CreateMaybeMessage< ::v1::model::Bitset >(GetArenaForAllocation());
  }
  return data_.bitset_;
}
inline ::v1::model::Bitset* Datapoint::mutable_bitset() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.bitset)
  return _internal_mutable_bitset();
}

// .v1.model.File file = 8 [json_name = "file"];
inline bool Datapoint::_internal_has_file() const {
  return data_case() == kFile;
}
inline bool Datapoint::has_file() const {
  return _internal_has_file();
}
inline void Datapoint::set_has_file() {
  _oneof_case_[0] = kFile;
}
inline ::v1::model::File* Datapoint::release_file() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.file)
  if (_internal_has_file()) {
    clear_has_data();
      ::v1::model::File* temp = data_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::File& Datapoint::_internal_file() const {
  return _internal_has_file()
      ? *data_.file_
      : reinterpret_cast< ::v1::model::File&>(::v1::model::_File_default_instance_);
}
inline const ::v1::model::File& Datapoint::file() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.file)
  return _internal_file();
}
inline ::v1::model::File* Datapoint::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.file)
  if (_internal_has_file()) {
    clear_has_data();
    ::v1::model::File* temp = data_.file_;
    data_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_file(::v1::model::File* file) {
  clear_data();
  if (file) {
    set_has_file();
    data_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.file)
}
inline ::v1::model::File* Datapoint::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_data();
    set_has_file();
    data_.file_ = CreateMaybeMessage< ::v1::model::File >(GetArenaForAllocation());
  }
  return data_.file_;
}
inline ::v1::model::File* Datapoint::mutable_file() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.file)
  return _internal_mutable_file();
}

// .v1.model.Image image = 9 [json_name = "image"];
inline bool Datapoint::_internal_has_image() const {
  return data_case() == kImage;
}
inline bool Datapoint::has_image() const {
  return _internal_has_image();
}
inline void Datapoint::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline ::v1::model::Image* Datapoint::release_image() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.image)
  if (_internal_has_image()) {
    clear_has_data();
      ::v1::model::Image* temp = data_.image_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Image& Datapoint::_internal_image() const {
  return _internal_has_image()
      ? *data_.image_
      : reinterpret_cast< ::v1::model::Image&>(::v1::model::_Image_default_instance_);
}
inline const ::v1::model::Image& Datapoint::image() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.image)
  return _internal_image();
}
inline ::v1::model::Image* Datapoint::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.image)
  if (_internal_has_image()) {
    clear_has_data();
    ::v1::model::Image* temp = data_.image_;
    data_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_image(::v1::model::Image* image) {
  clear_data();
  if (image) {
    set_has_image();
    data_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.image)
}
inline ::v1::model::Image* Datapoint::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_data();
    set_has_image();
    data_.image_ = CreateMaybeMessage< ::v1::model::Image >(GetArenaForAllocation());
  }
  return data_.image_;
}
inline ::v1::model::Image* Datapoint::mutable_image() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.image)
  return _internal_mutable_image();
}

// .v1.model.PointCloud point_cloud = 10 [json_name = "pointCloud"];
inline bool Datapoint::_internal_has_point_cloud() const {
  return data_case() == kPointCloud;
}
inline bool Datapoint::has_point_cloud() const {
  return _internal_has_point_cloud();
}
inline void Datapoint::set_has_point_cloud() {
  _oneof_case_[0] = kPointCloud;
}
inline ::v1::model::PointCloud* Datapoint::release_point_cloud() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.point_cloud)
  if (_internal_has_point_cloud()) {
    clear_has_data();
      ::v1::model::PointCloud* temp = data_.point_cloud_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.point_cloud_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::PointCloud& Datapoint::_internal_point_cloud() const {
  return _internal_has_point_cloud()
      ? *data_.point_cloud_
      : reinterpret_cast< ::v1::model::PointCloud&>(::v1::model::_PointCloud_default_instance_);
}
inline const ::v1::model::PointCloud& Datapoint::point_cloud() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.point_cloud)
  return _internal_point_cloud();
}
inline ::v1::model::PointCloud* Datapoint::unsafe_arena_release_point_cloud() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.point_cloud)
  if (_internal_has_point_cloud()) {
    clear_has_data();
    ::v1::model::PointCloud* temp = data_.point_cloud_;
    data_.point_cloud_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_point_cloud(::v1::model::PointCloud* point_cloud) {
  clear_data();
  if (point_cloud) {
    set_has_point_cloud();
    data_.point_cloud_ = point_cloud;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.point_cloud)
}
inline ::v1::model::PointCloud* Datapoint::_internal_mutable_point_cloud() {
  if (!_internal_has_point_cloud()) {
    clear_data();
    set_has_point_cloud();
    data_.point_cloud_ = CreateMaybeMessage< ::v1::model::PointCloud >(GetArenaForAllocation());
  }
  return data_.point_cloud_;
}
inline ::v1::model::PointCloud* Datapoint::mutable_point_cloud() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.point_cloud)
  return _internal_mutable_point_cloud();
}

// .v1.model.Location location = 11 [json_name = "location"];
inline bool Datapoint::_internal_has_location() const {
  return data_case() == kLocation;
}
inline bool Datapoint::has_location() const {
  return _internal_has_location();
}
inline void Datapoint::set_has_location() {
  _oneof_case_[0] = kLocation;
}
inline ::v1::model::Location* Datapoint::release_location() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.location)
  if (_internal_has_location()) {
    clear_has_data();
      ::v1::model::Location* temp = data_.location_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Location& Datapoint::_internal_location() const {
  return _internal_has_location()
      ? *data_.location_
      : reinterpret_cast< ::v1::model::Location&>(::v1::model::_Location_default_instance_);
}
inline const ::v1::model::Location& Datapoint::location() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.location)
  return _internal_location();
}
inline ::v1::model::Location* Datapoint::unsafe_arena_release_location() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.location)
  if (_internal_has_location()) {
    clear_has_data();
    ::v1::model::Location* temp = data_.location_;
    data_.location_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_location(::v1::model::Location* location) {
  clear_data();
  if (location) {
    set_has_location();
    data_.location_ = location;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.location)
}
inline ::v1::model::Location* Datapoint::_internal_mutable_location() {
  if (!_internal_has_location()) {
    clear_data();
    set_has_location();
    data_.location_ = CreateMaybeMessage< ::v1::model::Location >(GetArenaForAllocation());
  }
  return data_.location_;
}
inline ::v1::model::Location* Datapoint::mutable_location() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.location)
  return _internal_mutable_location();
}

// .v1.model.Localization localization = 12 [json_name = "localization"];
inline bool Datapoint::_internal_has_localization() const {
  return data_case() == kLocalization;
}
inline bool Datapoint::has_localization() const {
  return _internal_has_localization();
}
inline void Datapoint::set_has_localization() {
  _oneof_case_[0] = kLocalization;
}
inline ::v1::model::Localization* Datapoint::release_localization() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.localization)
  if (_internal_has_localization()) {
    clear_has_data();
      ::v1::model::Localization* temp = data_.localization_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.localization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Localization& Datapoint::_internal_localization() const {
  return _internal_has_localization()
      ? *data_.localization_
      : reinterpret_cast< ::v1::model::Localization&>(::v1::model::_Localization_default_instance_);
}
inline const ::v1::model::Localization& Datapoint::localization() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.localization)
  return _internal_localization();
}
inline ::v1::model::Localization* Datapoint::unsafe_arena_release_localization() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.localization)
  if (_internal_has_localization()) {
    clear_has_data();
    ::v1::model::Localization* temp = data_.localization_;
    data_.localization_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_localization(::v1::model::Localization* localization) {
  clear_data();
  if (localization) {
    set_has_localization();
    data_.localization_ = localization;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.localization)
}
inline ::v1::model::Localization* Datapoint::_internal_mutable_localization() {
  if (!_internal_has_localization()) {
    clear_data();
    set_has_localization();
    data_.localization_ = CreateMaybeMessage< ::v1::model::Localization >(GetArenaForAllocation());
  }
  return data_.localization_;
}
inline ::v1::model::Localization* Datapoint::mutable_localization() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.localization)
  return _internal_mutable_localization();
}

// .v1.model.Health health = 13 [json_name = "health"];
inline bool Datapoint::_internal_has_health() const {
  return data_case() == kHealth;
}
inline bool Datapoint::has_health() const {
  return _internal_has_health();
}
inline void Datapoint::set_has_health() {
  _oneof_case_[0] = kHealth;
}
inline ::v1::model::Health* Datapoint::release_health() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.health)
  if (_internal_has_health()) {
    clear_has_data();
      ::v1::model::Health* temp = data_.health_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.health_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Health& Datapoint::_internal_health() const {
  return _internal_has_health()
      ? *data_.health_
      : reinterpret_cast< ::v1::model::Health&>(::v1::model::_Health_default_instance_);
}
inline const ::v1::model::Health& Datapoint::health() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.health)
  return _internal_health();
}
inline ::v1::model::Health* Datapoint::unsafe_arena_release_health() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.health)
  if (_internal_has_health()) {
    clear_has_data();
    ::v1::model::Health* temp = data_.health_;
    data_.health_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_health(::v1::model::Health* health) {
  clear_data();
  if (health) {
    set_has_health();
    data_.health_ = health;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.health)
}
inline ::v1::model::Health* Datapoint::_internal_mutable_health() {
  if (!_internal_has_health()) {
    clear_data();
    set_has_health();
    data_.health_ = CreateMaybeMessage< ::v1::model::Health >(GetArenaForAllocation());
  }
  return data_.health_;
}
inline ::v1::model::Health* Datapoint::mutable_health() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.health)
  return _internal_mutable_health();
}

// .v1.model.Json json = 14 [json_name = "json"];
inline bool Datapoint::_internal_has_json() const {
  return data_case() == kJson;
}
inline bool Datapoint::has_json() const {
  return _internal_has_json();
}
inline void Datapoint::set_has_json() {
  _oneof_case_[0] = kJson;
}
inline ::v1::model::Json* Datapoint::release_json() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.json)
  if (_internal_has_json()) {
    clear_has_data();
      ::v1::model::Json* temp = data_.json_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Json& Datapoint::_internal_json() const {
  return _internal_has_json()
      ? *data_.json_
      : reinterpret_cast< ::v1::model::Json&>(::v1::model::_Json_default_instance_);
}
inline const ::v1::model::Json& Datapoint::json() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.json)
  return _internal_json();
}
inline ::v1::model::Json* Datapoint::unsafe_arena_release_json() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.json)
  if (_internal_has_json()) {
    clear_has_data();
    ::v1::model::Json* temp = data_.json_;
    data_.json_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_json(::v1::model::Json* json) {
  clear_data();
  if (json) {
    set_has_json();
    data_.json_ = json;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.json)
}
inline ::v1::model::Json* Datapoint::_internal_mutable_json() {
  if (!_internal_has_json()) {
    clear_data();
    set_has_json();
    data_.json_ = CreateMaybeMessage< ::v1::model::Json >(GetArenaForAllocation());
  }
  return data_.json_;
}
inline ::v1::model::Json* Datapoint::mutable_json() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.json)
  return _internal_mutable_json();
}

// .v1.model.Battery battery = 15 [json_name = "battery"];
inline bool Datapoint::_internal_has_battery() const {
  return data_case() == kBattery;
}
inline bool Datapoint::has_battery() const {
  return _internal_has_battery();
}
inline void Datapoint::set_has_battery() {
  _oneof_case_[0] = kBattery;
}
inline ::v1::model::Battery* Datapoint::release_battery() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.battery)
  if (_internal_has_battery()) {
    clear_has_data();
      ::v1::model::Battery* temp = data_.battery_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Battery& Datapoint::_internal_battery() const {
  return _internal_has_battery()
      ? *data_.battery_
      : reinterpret_cast< ::v1::model::Battery&>(::v1::model::_Battery_default_instance_);
}
inline const ::v1::model::Battery& Datapoint::battery() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.battery)
  return _internal_battery();
}
inline ::v1::model::Battery* Datapoint::unsafe_arena_release_battery() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.battery)
  if (_internal_has_battery()) {
    clear_has_data();
    ::v1::model::Battery* temp = data_.battery_;
    data_.battery_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_battery(::v1::model::Battery* battery) {
  clear_data();
  if (battery) {
    set_has_battery();
    data_.battery_ = battery;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.battery)
}
inline ::v1::model::Battery* Datapoint::_internal_mutable_battery() {
  if (!_internal_has_battery()) {
    clear_data();
    set_has_battery();
    data_.battery_ = CreateMaybeMessage< ::v1::model::Battery >(GetArenaForAllocation());
  }
  return data_.battery_;
}
inline ::v1::model::Battery* Datapoint::mutable_battery() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.battery)
  return _internal_mutable_battery();
}

// .v1.model.Video video = 16 [json_name = "video"];
inline bool Datapoint::_internal_has_video() const {
  return data_case() == kVideo;
}
inline bool Datapoint::has_video() const {
  return _internal_has_video();
}
inline void Datapoint::set_has_video() {
  _oneof_case_[0] = kVideo;
}
inline ::v1::model::Video* Datapoint::release_video() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.video)
  if (_internal_has_video()) {
    clear_has_data();
      ::v1::model::Video* temp = data_.video_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.video_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Video& Datapoint::_internal_video() const {
  return _internal_has_video()
      ? *data_.video_
      : reinterpret_cast< ::v1::model::Video&>(::v1::model::_Video_default_instance_);
}
inline const ::v1::model::Video& Datapoint::video() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.video)
  return _internal_video();
}
inline ::v1::model::Video* Datapoint::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.video)
  if (_internal_has_video()) {
    clear_has_data();
    ::v1::model::Video* temp = data_.video_;
    data_.video_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_video(::v1::model::Video* video) {
  clear_data();
  if (video) {
    set_has_video();
    data_.video_ = video;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.video)
}
inline ::v1::model::Video* Datapoint::_internal_mutable_video() {
  if (!_internal_has_video()) {
    clear_data();
    set_has_video();
    data_.video_ = CreateMaybeMessage< ::v1::model::Video >(GetArenaForAllocation());
  }
  return data_.video_;
}
inline ::v1::model::Video* Datapoint::mutable_video() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.video)
  return _internal_mutable_video();
}

// .v1.model.TransformTree transform_tree = 18 [json_name = "transformTree"];
inline bool Datapoint::_internal_has_transform_tree() const {
  return data_case() == kTransformTree;
}
inline bool Datapoint::has_transform_tree() const {
  return _internal_has_transform_tree();
}
inline void Datapoint::set_has_transform_tree() {
  _oneof_case_[0] = kTransformTree;
}
inline ::v1::model::TransformTree* Datapoint::release_transform_tree() {
  // @@protoc_insertion_point(field_release:v1.model.Datapoint.transform_tree)
  if (_internal_has_transform_tree()) {
    clear_has_data();
      ::v1::model::TransformTree* temp = data_.transform_tree_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.transform_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::TransformTree& Datapoint::_internal_transform_tree() const {
  return _internal_has_transform_tree()
      ? *data_.transform_tree_
      : reinterpret_cast< ::v1::model::TransformTree&>(::v1::model::_TransformTree_default_instance_);
}
inline const ::v1::model::TransformTree& Datapoint::transform_tree() const {
  // @@protoc_insertion_point(field_get:v1.model.Datapoint.transform_tree)
  return _internal_transform_tree();
}
inline ::v1::model::TransformTree* Datapoint::unsafe_arena_release_transform_tree() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.Datapoint.transform_tree)
  if (_internal_has_transform_tree()) {
    clear_has_data();
    ::v1::model::TransformTree* temp = data_.transform_tree_;
    data_.transform_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Datapoint::unsafe_arena_set_allocated_transform_tree(::v1::model::TransformTree* transform_tree) {
  clear_data();
  if (transform_tree) {
    set_has_transform_tree();
    data_.transform_tree_ = transform_tree;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.Datapoint.transform_tree)
}
inline ::v1::model::TransformTree* Datapoint::_internal_mutable_transform_tree() {
  if (!_internal_has_transform_tree()) {
    clear_data();
    set_has_transform_tree();
    data_.transform_tree_ = CreateMaybeMessage< ::v1::model::TransformTree >(GetArenaForAllocation());
  }
  return data_.transform_tree_;
}
inline ::v1::model::TransformTree* Datapoint::mutable_transform_tree() {
  // @@protoc_insertion_point(field_mutable:v1.model.Datapoint.transform_tree)
  return _internal_mutable_transform_tree();
}

inline bool Datapoint::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Datapoint::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Datapoint::DataCase Datapoint::data_case() const {
  return Datapoint::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ControlDatapoint

// string stream = 1 [json_name = "stream"];
inline void ControlDatapoint::clear_stream() {
  stream_.ClearToEmpty();
}
inline const std::string& ControlDatapoint::stream() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.stream)
  return _internal_stream();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ControlDatapoint::set_stream(ArgT0&& arg0, ArgT... args) {
 
 stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:v1.model.ControlDatapoint.stream)
}
inline std::string* ControlDatapoint::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.stream)
  return _internal_mutable_stream();
}
inline const std::string& ControlDatapoint::_internal_stream() const {
  return stream_.Get();
}
inline void ControlDatapoint::_internal_set_stream(const std::string& value) {
  
  stream_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ControlDatapoint::_internal_mutable_stream() {
  
  return stream_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ControlDatapoint::release_stream() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.stream)
  return stream_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ControlDatapoint::set_allocated_stream(std::string* stream) {
  if (stream != nullptr) {
    
  } else {
    
  }
  stream_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stream,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:v1.model.ControlDatapoint.stream)
}

// int64 timestamp = 2 [json_name = "timestamp"];
inline void ControlDatapoint::clear_timestamp() {
  timestamp_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ControlDatapoint::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ControlDatapoint::timestamp() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.timestamp)
  return _internal_timestamp();
}
inline void ControlDatapoint::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  timestamp_ = value;
}
inline void ControlDatapoint::set_timestamp(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:v1.model.ControlDatapoint.timestamp)
}

// .v1.model.Bitset bitset = 3 [json_name = "bitset"];
inline bool ControlDatapoint::_internal_has_bitset() const {
  return data_case() == kBitset;
}
inline bool ControlDatapoint::has_bitset() const {
  return _internal_has_bitset();
}
inline void ControlDatapoint::set_has_bitset() {
  _oneof_case_[0] = kBitset;
}
inline ::v1::model::Bitset* ControlDatapoint::release_bitset() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.bitset)
  if (_internal_has_bitset()) {
    clear_has_data();
      ::v1::model::Bitset* temp = data_.bitset_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Bitset& ControlDatapoint::_internal_bitset() const {
  return _internal_has_bitset()
      ? *data_.bitset_
      : reinterpret_cast< ::v1::model::Bitset&>(::v1::model::_Bitset_default_instance_);
}
inline const ::v1::model::Bitset& ControlDatapoint::bitset() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.bitset)
  return _internal_bitset();
}
inline ::v1::model::Bitset* ControlDatapoint::unsafe_arena_release_bitset() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.ControlDatapoint.bitset)
  if (_internal_has_bitset()) {
    clear_has_data();
    ::v1::model::Bitset* temp = data_.bitset_;
    data_.bitset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlDatapoint::unsafe_arena_set_allocated_bitset(::v1::model::Bitset* bitset) {
  clear_data();
  if (bitset) {
    set_has_bitset();
    data_.bitset_ = bitset;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ControlDatapoint.bitset)
}
inline ::v1::model::Bitset* ControlDatapoint::_internal_mutable_bitset() {
  if (!_internal_has_bitset()) {
    clear_data();
    set_has_bitset();
    data_.bitset_ = CreateMaybeMessage< ::v1::model::Bitset >(GetArenaForAllocation());
  }
  return data_.bitset_;
}
inline ::v1::model::Bitset* ControlDatapoint::mutable_bitset() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.bitset)
  return _internal_mutable_bitset();
}

// .v1.model.Twist twist = 4 [json_name = "twist"];
inline bool ControlDatapoint::_internal_has_twist() const {
  return data_case() == kTwist;
}
inline bool ControlDatapoint::has_twist() const {
  return _internal_has_twist();
}
inline void ControlDatapoint::set_has_twist() {
  _oneof_case_[0] = kTwist;
}
inline ::v1::model::Twist* ControlDatapoint::release_twist() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.twist)
  if (_internal_has_twist()) {
    clear_has_data();
      ::v1::model::Twist* temp = data_.twist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.twist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Twist& ControlDatapoint::_internal_twist() const {
  return _internal_has_twist()
      ? *data_.twist_
      : reinterpret_cast< ::v1::model::Twist&>(::v1::model::_Twist_default_instance_);
}
inline const ::v1::model::Twist& ControlDatapoint::twist() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.twist)
  return _internal_twist();
}
inline ::v1::model::Twist* ControlDatapoint::unsafe_arena_release_twist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.ControlDatapoint.twist)
  if (_internal_has_twist()) {
    clear_has_data();
    ::v1::model::Twist* temp = data_.twist_;
    data_.twist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlDatapoint::unsafe_arena_set_allocated_twist(::v1::model::Twist* twist) {
  clear_data();
  if (twist) {
    set_has_twist();
    data_.twist_ = twist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ControlDatapoint.twist)
}
inline ::v1::model::Twist* ControlDatapoint::_internal_mutable_twist() {
  if (!_internal_has_twist()) {
    clear_data();
    set_has_twist();
    data_.twist_ = CreateMaybeMessage< ::v1::model::Twist >(GetArenaForAllocation());
  }
  return data_.twist_;
}
inline ::v1::model::Twist* ControlDatapoint::mutable_twist() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.twist)
  return _internal_mutable_twist();
}

// .v1.model.Transform pose = 5 [json_name = "pose"];
inline bool ControlDatapoint::_internal_has_pose() const {
  return data_case() == kPose;
}
inline bool ControlDatapoint::has_pose() const {
  return _internal_has_pose();
}
inline void ControlDatapoint::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline ::v1::model::Transform* ControlDatapoint::release_pose() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.pose)
  if (_internal_has_pose()) {
    clear_has_data();
      ::v1::model::Transform* temp = data_.pose_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Transform& ControlDatapoint::_internal_pose() const {
  return _internal_has_pose()
      ? *data_.pose_
      : reinterpret_cast< ::v1::model::Transform&>(::v1::model::_Transform_default_instance_);
}
inline const ::v1::model::Transform& ControlDatapoint::pose() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.pose)
  return _internal_pose();
}
inline ::v1::model::Transform* ControlDatapoint::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.ControlDatapoint.pose)
  if (_internal_has_pose()) {
    clear_has_data();
    ::v1::model::Transform* temp = data_.pose_;
    data_.pose_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlDatapoint::unsafe_arena_set_allocated_pose(::v1::model::Transform* pose) {
  clear_data();
  if (pose) {
    set_has_pose();
    data_.pose_ = pose;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ControlDatapoint.pose)
}
inline ::v1::model::Transform* ControlDatapoint::_internal_mutable_pose() {
  if (!_internal_has_pose()) {
    clear_data();
    set_has_pose();
    data_.pose_ = CreateMaybeMessage< ::v1::model::Transform >(GetArenaForAllocation());
  }
  return data_.pose_;
}
inline ::v1::model::Transform* ControlDatapoint::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.pose)
  return _internal_mutable_pose();
}

// .v1.model.Numeric numeric = 6 [json_name = "numeric"];
inline bool ControlDatapoint::_internal_has_numeric() const {
  return data_case() == kNumeric;
}
inline bool ControlDatapoint::has_numeric() const {
  return _internal_has_numeric();
}
inline void ControlDatapoint::set_has_numeric() {
  _oneof_case_[0] = kNumeric;
}
inline ::v1::model::Numeric* ControlDatapoint::release_numeric() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.numeric)
  if (_internal_has_numeric()) {
    clear_has_data();
      ::v1::model::Numeric* temp = data_.numeric_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Numeric& ControlDatapoint::_internal_numeric() const {
  return _internal_has_numeric()
      ? *data_.numeric_
      : reinterpret_cast< ::v1::model::Numeric&>(::v1::model::_Numeric_default_instance_);
}
inline const ::v1::model::Numeric& ControlDatapoint::numeric() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.numeric)
  return _internal_numeric();
}
inline ::v1::model::Numeric* ControlDatapoint::unsafe_arena_release_numeric() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.ControlDatapoint.numeric)
  if (_internal_has_numeric()) {
    clear_has_data();
    ::v1::model::Numeric* temp = data_.numeric_;
    data_.numeric_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlDatapoint::unsafe_arena_set_allocated_numeric(::v1::model::Numeric* numeric) {
  clear_data();
  if (numeric) {
    set_has_numeric();
    data_.numeric_ = numeric;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ControlDatapoint.numeric)
}
inline ::v1::model::Numeric* ControlDatapoint::_internal_mutable_numeric() {
  if (!_internal_has_numeric()) {
    clear_data();
    set_has_numeric();
    data_.numeric_ = CreateMaybeMessage< ::v1::model::Numeric >(GetArenaForAllocation());
  }
  return data_.numeric_;
}
inline ::v1::model::Numeric* ControlDatapoint::mutable_numeric() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.numeric)
  return _internal_mutable_numeric();
}

// .v1.model.PoseWithCovariance pose_with_covariance = 7 [json_name = "poseWithCovariance"];
inline bool ControlDatapoint::_internal_has_pose_with_covariance() const {
  return data_case() == kPoseWithCovariance;
}
inline bool ControlDatapoint::has_pose_with_covariance() const {
  return _internal_has_pose_with_covariance();
}
inline void ControlDatapoint::set_has_pose_with_covariance() {
  _oneof_case_[0] = kPoseWithCovariance;
}
inline ::v1::model::PoseWithCovariance* ControlDatapoint::release_pose_with_covariance() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.pose_with_covariance)
  if (_internal_has_pose_with_covariance()) {
    clear_has_data();
      ::v1::model::PoseWithCovariance* temp = data_.pose_with_covariance_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.pose_with_covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::PoseWithCovariance& ControlDatapoint::_internal_pose_with_covariance() const {
  return _internal_has_pose_with_covariance()
      ? *data_.pose_with_covariance_
      : reinterpret_cast< ::v1::model::PoseWithCovariance&>(::v1::model::_PoseWithCovariance_default_instance_);
}
inline const ::v1::model::PoseWithCovariance& ControlDatapoint::pose_with_covariance() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.pose_with_covariance)
  return _internal_pose_with_covariance();
}
inline ::v1::model::PoseWithCovariance* ControlDatapoint::unsafe_arena_release_pose_with_covariance() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.ControlDatapoint.pose_with_covariance)
  if (_internal_has_pose_with_covariance()) {
    clear_has_data();
    ::v1::model::PoseWithCovariance* temp = data_.pose_with_covariance_;
    data_.pose_with_covariance_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlDatapoint::unsafe_arena_set_allocated_pose_with_covariance(::v1::model::PoseWithCovariance* pose_with_covariance) {
  clear_data();
  if (pose_with_covariance) {
    set_has_pose_with_covariance();
    data_.pose_with_covariance_ = pose_with_covariance;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ControlDatapoint.pose_with_covariance)
}
inline ::v1::model::PoseWithCovariance* ControlDatapoint::_internal_mutable_pose_with_covariance() {
  if (!_internal_has_pose_with_covariance()) {
    clear_data();
    set_has_pose_with_covariance();
    data_.pose_with_covariance_ = CreateMaybeMessage< ::v1::model::PoseWithCovariance >(GetArenaForAllocation());
  }
  return data_.pose_with_covariance_;
}
inline ::v1::model::PoseWithCovariance* ControlDatapoint::mutable_pose_with_covariance() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.pose_with_covariance)
  return _internal_mutable_pose_with_covariance();
}

// .v1.model.Point point = 8 [json_name = "point"];
inline bool ControlDatapoint::_internal_has_point() const {
  return data_case() == kPoint;
}
inline bool ControlDatapoint::has_point() const {
  return _internal_has_point();
}
inline void ControlDatapoint::set_has_point() {
  _oneof_case_[0] = kPoint;
}
inline ::v1::model::Point* ControlDatapoint::release_point() {
  // @@protoc_insertion_point(field_release:v1.model.ControlDatapoint.point)
  if (_internal_has_point()) {
    clear_has_data();
      ::v1::model::Point* temp = data_.point_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::v1::model::Point& ControlDatapoint::_internal_point() const {
  return _internal_has_point()
      ? *data_.point_
      : reinterpret_cast< ::v1::model::Point&>(::v1::model::_Point_default_instance_);
}
inline const ::v1::model::Point& ControlDatapoint::point() const {
  // @@protoc_insertion_point(field_get:v1.model.ControlDatapoint.point)
  return _internal_point();
}
inline ::v1::model::Point* ControlDatapoint::unsafe_arena_release_point() {
  // @@protoc_insertion_point(field_unsafe_arena_release:v1.model.ControlDatapoint.point)
  if (_internal_has_point()) {
    clear_has_data();
    ::v1::model::Point* temp = data_.point_;
    data_.point_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControlDatapoint::unsafe_arena_set_allocated_point(::v1::model::Point* point) {
  clear_data();
  if (point) {
    set_has_point();
    data_.point_ = point;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:v1.model.ControlDatapoint.point)
}
inline ::v1::model::Point* ControlDatapoint::_internal_mutable_point() {
  if (!_internal_has_point()) {
    clear_data();
    set_has_point();
    data_.point_ = CreateMaybeMessage< ::v1::model::Point >(GetArenaForAllocation());
  }
  return data_.point_;
}
inline ::v1::model::Point* ControlDatapoint::mutable_point() {
  // @@protoc_insertion_point(field_mutable:v1.model.ControlDatapoint.point)
  return _internal_mutable_point();
}

inline bool ControlDatapoint::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void ControlDatapoint::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline ControlDatapoint::DataCase ControlDatapoint::data_case() const {
  return ControlDatapoint::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace model
}  // namespace v1

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_protos_2fmodel_2fv1_2fdatapoint_2eproto
